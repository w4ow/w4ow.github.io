<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSH中scp命令的使用</title>
      <link href="/2019/11/06/computer_science/Tools/ssh_scp/"/>
      <url>/2019/11/06/computer_science/Tools/ssh_scp/</url>
      
        <content type="html"><![CDATA[<p>在SSH中，scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。<br>类似的工具有rsync。scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><hr><a id="more"></a><h2 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1. 命令格式"></a>1. 命令格式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br></pre></td></tr></table></figure><h2 id="2-命令参数"><a href="#2-命令参数" class="headerlink" title="2. 命令参数"></a>2. 命令参数</h2><ul><li><strong>-1</strong> 强制scp命令使用协议ssh1</li><li><strong>-2</strong> 强制scp命令使用协议ssh2</li><li><strong>-4</strong> 强制scp命令只使用IPv4寻址</li><li><strong>-6</strong> 强制scp命令只使用IPv6寻址</li><li><strong>-B</strong> 使用批处理模式（传输过程中不询问传输口令或短语）</li><li><strong>-C</strong> 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li><strong>-p</strong> 留原文件的修改时间，访问时间和访问权限。</li><li><strong>-q</strong> 不显示传输进度条。</li><li><strong>-r</strong> 递归复制整个目录。</li><li><strong>-v</strong> 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li><strong>-c</strong> cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li><strong>-F</strong> ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li><strong>-i</strong> identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li><strong>-l</strong> limit 限定用户所能使用的带宽，以Kbit/s为单位。</li><li><strong>-o</strong> ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li><strong>-P</strong> port 注意是大写的P, port是指定数据传输用到的端口号</li><li><strong>-S</strong> program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li></ul><h2 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程拷贝到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash">scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从本地拷贝到远程</span></span><br><span class="line"><span class="meta">$</span><span class="bash">scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook中添加、删除Python kernel的方法</title>
      <link href="/2019/10/20/computer_science/Tools/manage_kernel_of_notebook/"/>
      <url>/2019/10/20/computer_science/Tools/manage_kernel_of_notebook/</url>
      
        <content type="html"><![CDATA[<p>在通过Anaconda使用Jupyter时，有时我们创建了多个Python环境(包括虚拟环境)，但是启动Jupyter Notebook后，在<em>新建</em>notebook选项中却找不到我们所创建的Python环境，此时我们可以通过向notebook中添加Python kernel解决该问题。</p><hr><a id="more"></a><h2 id="1-添加Kernel"><a href="#1-添加Kernel" class="headerlink" title="1. 添加Kernel"></a>1. 添加Kernel</h2><h3 id="1-1-切换环境，安装内核"><a href="#1-1-切换环境，安装内核" class="headerlink" title="1.1 切换环境，安装内核"></a>1.1 切换环境，安装内核</h3><p>首先切换到想要使用的Python环境中，若是虚拟环境则激活该虚拟环境。随后可以使用如下命令查看该环境下搜索并安装Python内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda search ipykernel      # 搜索内核</span><br><span class="line"></span><br><span class="line">conda install ipykernel     # 安装内核</span><br></pre></td></tr></table></figure><h3 id="1-2-在notebook中安装内核"><a href="#1-2-在notebook中安装内核" class="headerlink" title="1.2 在notebook中安装内核"></a>1.2 在notebook中安装内核</h3><p>使用以下命令安装notebook内核，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --name name_you_want (--user)</span><br></pre></td></tr></table></figure><p>其中name_you_want是将在notebook的<em>新建</em>中所显示的Python环境名字，安装时若权限不够，则添加–user</p><h3 id="1-3-重新启动Jupyter-Notebook"><a href="#1-3-重新启动Jupyter-Notebook" class="headerlink" title="1.3 重新启动Jupyter Notebook"></a>1.3 重新启动Jupyter Notebook</h3><p>重启Notebook，可以在<em>新建</em>下拉菜单中看到name_you_want选项，大功告成。</p><h2 id="2-查看kernel"><a href="#2-查看kernel" class="headerlink" title="2. 查看kernel"></a>2. 查看kernel</h2><p>使用该命令可以查看notebook所有已安装kernel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure><h2 id="3-删除kernel"><a href="#3-删除kernel" class="headerlink" title="3. 删除kernel"></a>3. 删除kernel</h2><p>使用以下命令可以删除指定kernel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec remove kernel_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改jupyter notebook默认工作路径</title>
      <link href="/2019/10/15/computer_science/Tools/change_work_dir_of_notebook/"/>
      <url>/2019/10/15/computer_science/Tools/change_work_dir_of_notebook/</url>
      
        <content type="html"><![CDATA[<p>修改jupyter notebook默认工作路径</p><hr><a id="more"></a><p><strong>1. 生成配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Mac &amp; Ubuntu &amp; Windows在Terminal中运行下面命令</span></span><br><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>如果在Windows中出现<em>‘jupyter’不是内部或外部命令，也不是可运行的批处理文件</em>，可以通过下面命令安装notebook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook</span><br></pre></td></tr></table></figure><p><strong>2. 修改配置文件</strong></p><p>找到如下所示的两行，第二行去注释并改成工作路径即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">macOS:</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># The directory to use for notebooks and kernels.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">c.NotebookApp.notebook_dir = <span class="string">''</span></span></span><br><span class="line"></span><br><span class="line">Ubuntu &amp; Windows:</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># The default URL to redirect to from `/`</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">c.NotebookApp.default_url = <span class="string">'/tree'</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性MBA表达式存在定理证明</title>
      <link href="/2019/10/10/computer_science/Information-Security/Linear%20MBA%20Expressions/"/>
      <url>/2019/10/10/computer_science/Information-Security/Linear%20MBA%20Expressions/</url>
      
        <content type="html"><![CDATA[<p>定理来源参见论文<em>Information Hiding in Software with Mixed Boolean-Arithmetic Transforms</em>中定理1.</p><hr><a id="more"></a><h2 id="1-MBA表达式的定义"><a href="#1-MBA表达式的定义" class="headerlink" title="1. MBA表达式的定义"></a>1. MBA表达式的定义</h2><p><strong>多项式MBA表达式</strong>形如：<br>$$\sum_{i \in I} a_i (\prod_{j \in J} e_{i,j}(x_1,…,x_t))$$<br>其中$a_i$是整数，$x_i$是在$B^n$上的变量，$e_{i,j}$是对变量$x_i$的按位表达式。例如：<br>$$f(x,y,z,t)=8458(x \lor y \land z)^3((xy)\land x \lor t) + x + 9(x \lor y)yz^3$$<br>是一个多项式MBA表达式，其中，表达式中变量总共有4个，即$t = 4$,即$x_1 = x, x_2 = y, x_3 = z$, $x_4 = t$，另外，$a$总共有3个值，分别是$a_0=8458, a_1=1, a_2 = 9$。<br>对于$a_0$，总共有4个$e_{i,j}$作为其右部累积，即$e_{0,0}=e_{0,1}=e_{0,2}=x \lor y \land z,e_{0,3}=(xy) \land x \lor t$。<br>同样的，$a_1$仅又结合了一个$e_{0,0}=x$。<br>至此算是比较清晰的解释了什么是MBA表达式</p><p><strong>线性MBA表达式</strong>形如：<br>$$\sum_{i \in I}a_i e_i(x_1,…x_t)$$<br>线性MBA表达式是多项式MBA表达式的子集，例如：<br>$$f(x,y)=x+y-(x \oplus (\lnot y)) - 2(x \lor y) + 12564$$<br>是一个线性MBA表达式，其变量仅两个$x,y$，而$a=\lbrace 1,1,-1,-2,12564 \rbrace$，对于每个$a_i$，<strong>仅右结合一个$e_i$</strong>，这是线性MBA和多项式MBA的区别。</p><h2 id="2-定理1-线性MBA表达式存在定理"><a href="#2-定理1-线性MBA表达式存在定理" class="headerlink" title="2. 定理1:线性MBA表达式存在定理"></a>2. 定理1:线性MBA表达式存在定理</h2><p>假设$n,s,t$为正整数，</p><ol><li>变量$x_i \in B^n, i=1,…,t$，即$x_i$形如$1011…010_{(n)}$；</li><li>$a_j$是一个正整数，$j=0,1,…,s-1$;</li><li>$e_j$是对$x_i$的<strong>按位表达式</strong>，$j=0,1,…,s-1$。由于该定理适用于线性MBA，因此对每个$a_j$仅右结合一个$e_j$，例如$e_j(x_1,x_2,x_3)=x_1 \lor x_2 \oplus x_3$,尤其需要注意的是，由于$e_j$是按位运算，因此有：$e_j(x_1,…,x_t)=\left( \begin{matrix} f_j(x_{1,0},…,x_{t,0}) \\ \vdots \\f_j(x_{1,n-1},…,x_{t,n-1}) \end{matrix} \right) = \left( \begin{matrix} f_j(y_0) \\ \vdots \\f_j(y_0) \end{matrix} \right)$</li><li>$e=\sum_{j=0}^{s-1}a_j e_j$是一个线性MBA表达式，则$e_j$是一个映射：$e_j:B^{n \times t} \to B$，由于$B$这个二进制数可以转换成模$2^n$的整数(在计算机中整数由补码表示，假设所有整数的二进制位数为$n$，则计算机中所有的数都需要模$2^n$)，因此$e_j:B^{n \times t} \to Z/2^n$，同样的,$e:B^{n \times t} \to Z/2^t$；</li><li>$F=\left( \begin{matrix} f_0(0) \cdots f_{s-1}(0) \\ \vdots \\f_0(2^t-1) \cdots f_{s-1}(2^t-1) \end{matrix} \right)$是一个$2^t \times s$的矩阵，表示$f_j$对每一bit位操作的所有可能的值，在Zhou的论文中说$F$是一个真值表；</li><li>$V=(a_0,…,a_{s-1})^T$；</li></ol><p>$e=0$当且仅当$F \cdot V = 0$在环$Z/2^n$上有非平凡的解。</p><h2 id="3-证明"><a href="#3-证明" class="headerlink" title="3. 证明"></a>3. 证明</h2><p>对于定理中的第5点，$F$为什么是$2^t \times s$，原因是，首先$f_j$也就是$e_j$总共有$s-1$个不同的表达式，这是列数为$s$的原因，其次，$y_i$是一个$t \times 1$的向量，$y_i$中的每个分量都是从$x_j$中第$i$个位置取出，例如$y_i=(1,0,1)$，那么对这个$t$位的$y_i$，其可能取值自然是$(0,1,…,2^t-1)$，也就有了$f_j$所有可能的取值是$(f(0),f(1),…,f(2^t-1))$，矩阵因此而来。</p><p>假设$F \cdot V = 0$，有：<br>$\forall x_1,…x_t \in B^n, y_i = (x_{1,i},…,x_{t,i}), i=0,…,n-1$,<br>$$<br>e(x_1,…,x_t)=\sum_{j=0}^{s-1}a_je_j(x_1,…,x_t)<br>$$</p><p>对于$e_j$有:<br>$$e_j(x_1,…,x_t) = [f_j(y_0),…,f_j(y_{n-1})] = \sum_{i=0}^{n-1}2^i f_j(y_i) \tag{1}$$<br>例如，$(x_1,x_2,x_3) = (101,110,001)$，且$e_j(x_1,x_2,x_3)=x_1 \land x_2 \oplus x_3$,则将$x_1,x_2,x_3$代入后可得$e_j(x_1,x_2,x_3)=101=5$,因为$e_j$是按位运算，因此可以把$e_j$拆分为$n$个$f_j$，每个$f_j$都是相同的，且每个$f_j$都是对一个不同变量的同一bit位操作的，这样就可以得到$e_j(x_1,x_2,x_3) = e_j(101,110,001)=[f_j(110), f_j(010), f_j(101)]=2^0f_j(110) + 2^1f_j(010) + 2^2f_j(101) = 5$;<br>将$(1)$带入$e$中可以得到：<br>$$e = \sum_{j=0}^{s-1}a_j e_j(x_1,…x_t) = \sum_{j=0}^{s-1}a_j \sum_{i=0}^{n-1}2^if_j(y_i)=\sum_{i=0}^{n-1}2^i \sum_{j=0}^{s-1}a_j f_j (y_i) \tag{2}$$<br>在$F \cdot V=0$中，有$\left(\begin{matrix} \vdots \\f_0(y_i) \cdots f_{s-1}(y_i) \\ \vdots \end{matrix} \right) \cdot \left( \begin{matrix} a_0 \\ a_1 \\ \vdots \\ a_{s-1}\end{matrix} \right) = \left( \begin{matrix} 0 \\ 0 \\ \vdots \\ 0\end{matrix} \right)$,即$\sum_{j=0}^{s-1}a_j f_j(y_i)=0$,代入$(2)$中可以得到：<br>$$<br>(2)=\sum_{i=0}^{n-1}2^i \sum_{j=0}^{s-1}a_j f_j (y_i)=\sum_{i=0}^{n-1}2^i \times 0 = 0<br>$$<br>以上证明了$F \cdot V = 0 \Rightarrow e = 0$,下面证明$e=0 \Rightarrow F \cdot V = 0$:</p><p>假设$e \equiv 0$，令$m_i = \sum_{j=0}^{s-1}a_j f_j (x_{1,i}, … , x_{t,i})$，则有：<br>$$e=\sum_{i=0}^{n-1}2^i \cdot m_i = 2^0m_0 + 2^1m_1 +…+2^{n-1}m_{n-1} \equiv 0 \tag{3}$$<br>假定我们有任意输入$x_{1,k},…,x_{t,k}$，且其$m_k = \bar{m} \not = 0$,则将其代入$(3)$中有：<br>$$e=2^0 \bar{m} + 2^1 \bar{m} +…+2^{n-1} \bar{m} \equiv 0 \Rightarrow \bar{m} = 0$$<br>但是$\bar{m}=0$与假设的$\bar{m} \not = 0$矛盾，因此可以得出结论对任意的$m_i$都有$m_i=0$，即$\sum_{j=0}^{s-1}a_j f_j (x_{1,i}, … , x_{t,i})=0$，进而有$F \cdot V = 0$.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MBA Obfuscation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex常见数学符号整理</title>
      <link href="/2019/09/22/computer_science/Tools/tex/"/>
      <url>/2019/09/22/computer_science/Tools/tex/</url>
      
        <content type="html"><![CDATA[<p>LaTeX常见数学符号整理</p><hr><a id="more"></a><h2 id="1-数学模式重音符"><a href="#1-数学模式重音符" class="headerlink" title="1. 数学模式重音符"></a>1. 数学模式重音符</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\hat{a}$</td><td>\hat{a}</td><td>$\check{a}$</td><td>\check{a}</td><td>$\tilde{a}$</td><td>\tilde{a}</td><td>$\acute{a}$</td><td>\acute{a}</td></tr><tr><td>$\grave{a}$</td><td>\grave{a}</td><td>$\dot{a}$</td><td>\dot{a}</td><td>$\ddot{a}$</td><td>\ddot{a}</td><td>$\breve{a}$</td><td>\breve{a}</td></tr><tr><td>$\bar{a}$</td><td>\bar{a}</td><td>$\vec{a}$</td><td>\vec{a}</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="2-小写希腊字母"><a href="#2-小写希腊字母" class="headerlink" title="2. 小写希腊字母"></a>2. 小写希腊字母</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\alpha$</td><td>\alpha</td><td>$\theta$</td><td>\theta</td><td>$o$</td><td>o</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\beta$</td><td>\beta</td><td>$\vartheta$</td><td>\vartheta</td><td>$\pi$</td><td>\pi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>$\gamma$</td><td>\gamma</td><td>$\iota$</td><td>\iota</td><td>$\varpi$</td><td>\varpi</td><td>$\varphi$</td><td>\varphi</td></tr><tr><td>$\delta$</td><td>\delta</td><td>$\kappa$</td><td>\kappa</td><td>$\rho$</td><td>\rho</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\epsilon$</td><td>\epsilon</td><td>$\lambda$</td><td>\lambda</td><td>$\varrho$</td><td>\varrho</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\varepsilon$</td><td>\varepsilon</td><td>$\mu$</td><td>\mu</td><td>$\sigma$</td><td>\sigma</td><td>$\omega$</td><td>\omega</td></tr><tr><td>$\zeta$</td><td>\zeta</td><td>$\nu$</td><td>\nu</td><td>$\varsigma$</td><td>\varsigma</td><td></td><td></td></tr><tr><td>$\eta$</td><td>\eta</td><td>$\xi$</td><td>\xi</td><td>$\tau$</td><td>\tau</td><td></td><td></td></tr></tbody></table><h2 id="3-大写希腊字母"><a href="#3-大写希腊字母" class="headerlink" title="3. 大写希腊字母"></a>3. 大写希腊字母</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\Lambda$</td><td>\Lambda</td><td>$\Sigma$</td><td>\Sigma</td><td>$\Psi$</td><td>\Psi</td></tr><tr><td>$\Delta$</td><td>\Delta</td><td>$\Xi$</td><td>\Xi</td><td>$\Upsilon$</td><td>\Upsilon</td><td>$\Omega$</td><td>\Omega</td></tr><tr><td>$\Theta$</td><td>\Theta</td><td>$\Pi$</td><td>\Pi</td><td>$\Phi$</td><td>\Phi</td><td></td><td></td></tr></tbody></table><h2 id="4-二元关系符"><a href="#4-二元关系符" class="headerlink" title="4. 二元关系符"></a>4. 二元关系符</h2><p>该表中的所有符号都可以通过在代码前加上<strong>\not</strong>来得到其否定形式。</p><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$&lt;$</td><td>&lt;</td><td>$&gt;$</td><td>&gt;</td><td>$=$</td><td>=</td></tr><tr><td>$\le$</td><td>\le</td><td>$\ge$</td><td>\ge</td><td>$\equiv$</td><td>\equiv</td></tr><tr><td>$\ll$</td><td>\ll</td><td>$\gg$</td><td>\gg</td><td>$\doteq$</td><td>\doteq</td></tr><tr><td>$\sim$</td><td>\sim</td><td>$\simeq$</td><td>\simeq</td><td>$\approx$</td><td>\approx</td></tr><tr><td>$\subset$</td><td>\subset</td><td>$\supset$</td><td>\supset</td><td>$\cong$</td><td>\cong</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td><td>$\supseteq$</td><td>\supseteq</td><td>$\Join$</td><td>\Join$^a$</td></tr><tr><td>$\in$</td><td>\in</td><td>$\ni$</td><td>\ni</td><td>$\propto$</td><td>propto</td></tr><tr><td>$\mid$</td><td>\mid</td><td>$\parallel$</td><td>\parallel</td><td>$:$</td><td>:</td></tr></tbody></table><p>$^a$使用宏包latexsym来得到这个符号</p><h2 id="5-二元运算符"><a href="#5-二元运算符" class="headerlink" title="5. 二元运算符"></a>5. 二元运算符</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$+$</td><td>+</td><td>$-$</td><td>-</td><td>$\cdot$</td><td>\cdot</td></tr><tr><td>$\pm$</td><td>\pm</td><td>$\mp$</td><td>\mp</td><td>$\div$</td><td>\div</td></tr><tr><td>$\times$</td><td>\times</td><td>$/$</td><td>/</td><td>$\setminus$</td><td>\setminus</td></tr><tr><td>$\star$</td><td>\star</td><td>$\ast$</td><td>\ast</td><td>$\circ$</td><td>\circ</td></tr><tr><td>$\cup$</td><td>\cup</td><td>$\cap$</td><td>\cap</td><td>$\bullet$</td><td>\bullet</td></tr><tr><td>$\lor$</td><td>\lor</td><td>$\land$</td><td>\land</td><td>$\oplus$</td><td>\oplus</td></tr><tr><td>$\odot$</td><td>\odot</td><td>$\boxplus$</td><td>\boxplus</td><td></td><td></td></tr></tbody></table><h2 id="6-大尺度运算符"><a href="#6-大尺度运算符" class="headerlink" title="6. 大尺度运算符"></a>6. 大尺度运算符</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\sum_{1}^{2}$</td><td>\sum_{1}^{2}</td><td>$\prod_{1}^{2}$</td><td>\prod_{1}^{2}</td><td>$\int_{1}^{2}$</td><td>\int_{1}^{2}</td></tr></tbody></table><h2 id="7-箭头"><a href="#7-箭头" class="headerlink" title="7. 箭头"></a>7. 箭头</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\gets$</td><td>\gets</td><td>$\to$</td><td>\to</td><td>$\leftrightarrow$</td><td>\leftrightarrow</td></tr><tr><td>$\Leftarrow$</td><td>\Leftarrow</td><td>$\Rightarrow$</td><td>\Rightarrow</td><td>$\Leftrightarrow$</td><td>\Leftrightarrow</td></tr><tr><td>$\mapsto$</td><td>\mapsto</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="8-定界符"><a href="#8-定界符" class="headerlink" title="8. 定界符"></a>8. 定界符</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$($</td><td>(</td><td>$)$</td><td>)</td><td>$\left( \right)$</td><td>\left( \right)</td><td>$\lbrace \rbrace$</td><td>{ } or \lbrace \rbrace</td></tr></tbody></table><h2 id="9-其他符号"><a href="#9-其他符号" class="headerlink" title="9. 其他符号"></a>9. 其他符号</h2><table><thead><tr><th>Show</th><th>Code</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$…$</td><td>…</td><td>$\cdots$</td><td>\cdots</td><td>$\forall$</td><td>\forall</td><td>$\exists$</td><td>\exists</td></tr><tr><td>$’$</td><td>‘</td><td>$\prime$</td><td>\prime</td><td>$\triangle$</td><td>\triangle</td><td>$\infty$</td><td>\infty</td></tr><tr><td>$\bot$</td><td>\bot</td><td>$\top$</td><td>\top</td><td>$\angle$</td><td>\angle</td><td>$\surd$</td><td>\surd</td></tr><tr><td>$\nabla$</td><td>\nabla</td><td>$\heartsuit$</td><td>\heartsuit</td><td>$\clubsuit$</td><td>\clubsuit</td><td>$\spadesuit$</td><td>\spadesuit</td></tr><tr><td>$\neg$</td><td>\neg or \lnot</td><td>$\vdots$</td><td>\vdots</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="10-数学字母"><a href="#10-数学字母" class="headerlink" title="10. 数学字母"></a>10. 数学字母</h2><table><thead><tr><th>字样</th><th>命令</th><th>宏包</th></tr></thead><tbody><tr><td>$\mathrm{ABCabc}$</td><td>\mathrm{ABCabc}</td><td></td></tr><tr><td>$\mathit{ABCabc}$</td><td>\mathit{ABCabc}</td><td></td></tr><tr><td>$\mathcal{ABCabc}$</td><td>\mathcal{ABCabc}</td><td></td></tr><tr><td>$\mathfrak{ABCabc}$</td><td>\mathfrak{ABCabc}</td><td>eufrak</td></tr><tr><td>$\mathbb{ABCabc}$</td><td>\mathbb{ABCabc}</td><td>amsfonts or asmsymb</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Mixed Boolean-Arithmetic的混淆</title>
      <link href="/2019/09/16/computer_science/Information-Security/Obfuscation%20with%20Mixed%20Boolean-Arithmetic/"/>
      <url>/2019/09/16/computer_science/Information-Security/Obfuscation%20with%20Mixed%20Boolean-Arithmetic/</url>
      
        <content type="html"><![CDATA[<p>基础介绍</p><hr><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>软件保护用于保护程序免受不必要的分析，程序混淆是软件保护的一种手段。<strong>程序混淆</strong>是指对代码进行转换使程序变的难以理解。混淆以两种主要方式隐藏程序的语义：1.改变code和data(例如，改变数据的值)，2.添加无关信息(例如垃圾代码)。MBA(Mixed Boolean-Arithmetic)混淆技术结合两种方法来混淆常见的数学表达式，例如重写运算符、引入新的运算符和常量等。</p><h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h2><h3 id="1-1-程序混淆的定义及应用"><a href="#1-1-程序混淆的定义及应用" class="headerlink" title="1.1 程序混淆的定义及应用"></a>1.1 程序混淆的定义及应用</h3><p><strong>混淆是对程序的动态转换行为，其目的是使程序的分析变的困难，同时保证程序的可观察性</strong>。</p><p>混淆通常有四个属性：</p><ul><li>功能：混淆后的程序必须具有与原始程序相同的功能；</li><li>效率：与原始程序相比，混淆后的程序的大小和执行时间必须是可接受的；</li><li>健壮性：混淆程序必须比原始程序更难分析；</li><li>正确性：混淆后的程序应当与源程序有相同的语义和功能。</li></ul><p>软件混淆应用领域包括软件加密、打包、反调试或防篡改等，应用范围包括但不限于：</p><ul><li>恶意检测：避免恶意软件的恶意检测；</li><li>保护知识产权：保护商业软件中的算法或协议；</li><li>权限管理：无论是通过许可检查来保护对软件的访问，还是通过数字版权管理(DRM)方案保护数字内容，这些技术通常都会嵌入关键信息(例如加密密钥和协议)，并且使用混淆来保护这些信息。嵌入在程序中的DRM方案(例如VOD服务或视频游戏保护)目前是现代环境中混淆的主要来源之一；</li><li>保护个人敏感数据：例如，在移动应用程序中，设备中保存了大量敏感数据(例如银行帐户详细信息)。混淆可以保护这些数据以及处理数据的协议。</li></ul><h3 id="1-2-理论混淆和实际混淆"><a href="#1-2-理论混淆和实际混淆" class="headerlink" title="1.2 理论混淆和实际混淆"></a>1.2 理论混淆和实际混淆</h3><h4 id="1-2-1-密码混淆"><a href="#1-2-1-密码混淆" class="headerlink" title="1.2.1 密码混淆"></a>1.2.1 密码混淆</h4><p>密码混淆旨在为混淆提供一个正式的上下文，特别是围绕量化分析给定程序$P$的混淆程序$\mathcal O(P)$的难度。</p><p>软件混淆的正式研究由Barak等人发起，他们引入了虚拟黑匣子(VBB)的概念作为混淆程序的最佳属性。VBB保证任何可以从程序$\mathcal O(P)$的输入/输出行为中学到的，从$P$中也可以学到。 Barak提出了<strong>不可区分混淆</strong>的定义：如果两个相同大小的程序P1和P2实现相同的功能，则它们的混淆$\mathcal O(P_1)$和$\mathcal O(P_2)$应无法区分。</p><p>Goldwasser等人提供了<strong>最佳可能混淆</strong>的定义：从$\mathcal O(P)$中提取的任何信息都可以通过类似大小的其他功能相同的的程序取得。 他们还证明，对于有效的混淆器，不可区分混淆和最佳混淆是等价的。</p><p>2013年，Garg等人提出了通用的不可区分混淆，该混淆基于三个组成部分：作为计算模型的分支程序，完全同态加密和多线性映射。</p><h4 id="1-2-2-实际混淆"><a href="#1-2-2-实际混淆" class="headerlink" title="1.2.2 实际混淆"></a>1.2.2 实际混淆</h4><p>密码混淆在实际上难以应用，因此商用混淆一般都是基于不同程序转换的组合。一些最常用的商用混淆有strong.protect和Arxan3。混淆主要在以下三个层次上工作：</p><p><strong>源代码混淆</strong><br>在源代码上操作的混淆，这种混淆能够充分利用编程语言的特性。因为混淆步骤是在编译之前进行的，因此它也更容易集成到现有的编译链中。这种方法的主要缺点是对不同的语言需要设计不同的混淆。</p><p><strong>中间代码混淆</strong><br>IR设计的目的之一是独立于任何源语言或目标语言，因此在IR上进行混淆更加通用，能够处理不同高级语言和汇编语言的程序，但同时这种混淆集成更加困难，因为很难将混淆器添加到现有的编译工具链中。</p><p><strong>汇编语言混淆</strong><br>与IR和源码相比，汇编级混淆会导致大量信息的丢失，因此很难实现仅在汇编时工作的通用混淆器。</p><h3 id="1-3-程序分析"><a href="#1-3-程序分析" class="headerlink" title="1.3 程序分析"></a>1.3 程序分析</h3><p>程序分析指对程序进行分析，从而得到有用信息。从反汇编程序中可以推断出控制流和数据流两种不同的信息，因此可以从数据流和控制流两种不同的角度分析程序。</p><p><strong>控制流</strong>：程序的控制流规定了程序的执行过程，通常用<strong>Control Flow Graph(CFG)</strong>和<strong>Call Graph(CG)</strong>表示控制流。在CFG中，节点被称为Basic Block(BB)，每一个BB包含多条指令，并且BB中的代码都是顺序执行的。而CFG中的edge则表示BB之间的可能执行路径。在CG中，节点代表一个函数，边代表函数之间的调用。</p><p><strong>数据流</strong>：和控制流不同，数据流没有固定的图形表示：不同的数据流分析会产生不同的表示。典型的数据流分析是<strong>到达定义</strong>，该分析中包括确定每个变量可能已定义的位置。这些信息可以从CFG中观察每个BB的输入和输出提取。</p><p>程序分析的手段也分为两类：</p><p><strong>静态分析</strong><br>程序的静态分析无需执行程序，而是分析程序源码(可通过反汇编获得，但反汇编通常比较困难)。静态分析的第一步通常是重建函数的CFG或程序的CG(可以利用工具)。为了模拟程序的运行，可以使用<strong>符号执行</strong>。静态分析可以安全分析潜在恶意二进制文件，因为不需要执行。但是由于静态分析会分析程序所有可能的执行路径，所以可能会导致过度分析。</p><p><strong>动态分析</strong><br>程序的动态分析是在特定输入上完成的，并推断出所采用的执行路径和数据修改的信息。由于仅分析了可能的执行路径的子集，因此可能导致分析不足。动态分析的例子包括：</p><ul><li>调试：在执行期间，逐步或使用断点以交互方式观察程序。</li><li>跟踪：记录每条执行的指令，并离线分析(执行后)。</li><li>数据污染：标记一个或多个变量，并在程序执行时观察它们对程序的影响。</li></ul><p>大多数动态分析技术也可以静态地用于符号执行。</p><h3 id="1-4-经典混淆技术"><a href="#1-4-经典混淆技术" class="headerlink" title="1.4 经典混淆技术"></a>1.4 经典混淆技术</h3><h4 id="1-4-1-控制流混淆"><a href="#1-4-1-控制流混淆" class="headerlink" title="1.4.1 控制流混淆"></a>1.4.1 控制流混淆</h4><p>几种简单地控制流混淆技术：inlining和outlining、Opaque Predicate、Control Flow Flattening等</p><p><strong>inlining &amp; outlining</strong><br>内联指用程序本身来代替对函数g的调用。即，若函数$f$调用函数$g$，则可以使用内联将函数$g$的代码插入到函数$f$中，使两者成为一体，从而省去调用。外联则相反，是将函数内一段代码独立成一个函数。这两种技术都能够达到修改函数的CFG和CG的目的，但不修改程序的功能，从而达到控制流混淆的技术。</p><p><strong>Opaque Predicate</strong><br>不透明谓词是是控制流复杂化的混淆技术，这种方法可以再混淆工具Obfuscator-LLVM中找到。传统的不透明谓词用于在CFG中创建伪分支。例如，<br>$$\forall x, y \in \mathbb{N}, \mathrm{if} \ x = y^2,<br>\mathrm{then} \ P = (x \equiv 0\ mod\ 4) \vee (x \equiv 1\ mod\ 4) \equiv True $$<br>上面的例子中$P$的值始终为$true$，则$P=flase$的分支将永远不会执行，那么就可以在这些不会被执行的路径中插入垃圾代码以达到混淆的目的。<br>应对不透明谓词的方法通常是通过使用符号执行来收集不透明谓词，并使用SMT求解器来解决混淆。</p><p><strong>Control Flow Flattening</strong><br>控制流扁平化的想法是通过在数据流中编码控制流的信息来完全改变函数CFG的结构。实现此目的的一种方法是为BB编号，并创建一个使用变量管理执行的调度程序，该变量确定BB的执行顺序。在每个BB的末尾，变量都会更新，执行将返回到调度程序。</p><h4 id="1-4-2-数据流混淆"><a href="#1-4-2-数据流混淆" class="headerlink" title="1.4.2 数据流混淆"></a>1.4.2 数据流混淆</h4><p>常见数据流混淆技术：变量拆分、改变变量表示、编码等。</p><p><strong>变量拆分</strong><br>将一个变量拆分为多个变量，可以增加程序分析的难度。例如：<br>$$\mathcal{O}(x) \to x_1 \times a + x_2$$<br>其中$\mathcal{O}(x)$代表混淆转换，即将变量$x$拆分为$x_1, x_2$等。</p><p><strong>改变变量表示</strong><br>通过改变变量的表示形式，可以隐藏变量的值以及应用与于变量的操作。例如，一般计算机中使用二进制表示整数，可以通过改成使用三进制表示整数从而达到隐藏数据的目的</p><p><strong>编码</strong><br>编码是最常见的数据流混淆技术之一。编码旨在防止变量的值在程序执行过程中显式的出现在内存中。这项技术被借用到密码白盒领域。实际上，混淆中的编码通常是仿射函数，因为它们很容易相互转换并且在性能开销较小。传统上，变量必须在进行计算之前先解码，计算之后还需重新编码。</p><h4 id="1-4-3-白盒"><a href="#1-4-3-白盒" class="headerlink" title="1.4.3 白盒"></a>1.4.3 白盒</h4><p>白盒加密技术是加密技术和实际混淆技术之间的交叉领域，其目的是在<strong>白盒攻击环境</strong>中保护程序中的加密算法，即程序的运行环境是可控的。与理论上可以应用于任何程序并隐藏数据或算法的混淆相比，只有加密算法是白盒，并且该过程可以使用算法的特殊性来帮助隐藏所使用的密钥。白盒密码术是混淆密码算法中的重要概念，通常是混淆器中必不可少的。</p><h3 id="1-5-混淆技术的评价指标"><a href="#1-5-混淆技术的评价指标" class="headerlink" title="1.5 混淆技术的评价指标"></a>1.5 混淆技术的评价指标</h3><p>程序的复杂性是指其：</p><ul><li>指令数量</li><li>控制流复杂性</li><li>数据流复杂性</li></ul><p>因此Collberg等人基于此提出了三种指标来评价混淆转换：</p><ol><li><em>Potency</em>：即上述提及的程序的复杂度，如果混淆转换增加了程序复杂性，则它是有效的转换。在论文<em>MBA-Blast</em>中提到可以通过4中方法增加程序复杂性：(1)增加布尔运算符和算术运算符的数量；(2)引入新的整数或bit向量；(3)隐藏真实参数；(4)打乱计算顺序。</li><li><em>Resilience</em>：即混淆对反混淆的健壮性。</li><li><em>Cost</em>：主要分为两部分：产生混淆程序的代价，以及与原始程序相比，混淆程序所需的额外执行时间和空间。</li><li><em>Correctness</em>：混淆后的程序应当与源程序有相同的语义和功能。</li></ol><p>另一个常见的度量标准是<strong>隐身性</strong>，即检测到混淆的难度。Collberg定义了<strong>隐秘隐身</strong>(分析人员无法确定是否已应用混淆)和<strong>局部隐身</strong>(分析人员无法确定在何处应用了混淆)。</p><h2 id="2-已有工作"><a href="#2-已有工作" class="headerlink" title="2. 已有工作"></a>2. 已有工作</h2><h3 id="2-1-MBA表达式"><a href="#2-1-MBA表达式" class="headerlink" title="2.1 MBA表达式"></a>2.1 MBA表达式</h3><p>MBA(混合布尔算数)表达式是混合了算术运算符(加法、乘法等)和布尔运算符(与、或、非等)的表达式。</p><h4 id="2-1-1-多项式MBA表达式"><a href="#2-1-1-多项式MBA表达式" class="headerlink" title="2.1.1 多项式MBA表达式"></a>2.1.1 多项式MBA表达式</h4><p>下面给出了一些有关MBA表达式的定义：</p><p><strong>Definition 1</strong>(多项式MBA表达式)<br>MBA表达式$E$，<br>$$E = \sum_{i \in I} a_i \left( \prod_{j \in J_i} e_{i,j}(x_0,…,x_{t-1}) \right)$$<br>其中累和与累积是模$2^n$的，$a_i$是一个常数，$e_{i,j}$是变量$x_0,…,x_{t-1} \ in \ \lbrace 0,1 \rbrace ^n$的按位表达式，具体公式参加论文。<br>根据定义，多项式MBA表达式的组合仍然是多项式MBA表达式。<br>为简洁起见，本文其余部分中的“MBA表达式”一词代表多项式MBA表达式。此外，本研究仅限于常用的运算符：算术{+，-，×}和布尔值{∧，∨，⊕，¬}，对于此类运算符，我们同时使用按位和布尔项。</p><h4 id="2-1-2-基于MBA的混淆"><a href="#2-1-2-基于MBA的混淆" class="headerlink" title="2.1.2 基于MBA的混淆"></a>2.1.2 基于MBA的混淆</h4><p><strong>表达式的混淆</strong><br>使用MBA表达式混淆运算符的过程依赖于两部分：</p><ul><li>MBA重写：用等效的MBA表达式重写所选的运算符。</li><li>身份的插入：假定$e$是将被混淆的表达式的一部分，那么$e$可以被写为$f(f^{-1}(e))$，其中$f$为在$\mathbb{Z}/2^n \mathbb{Z}$上的可逆函数。在周等人的工作中，$f$是仿射函数。由于该过程与编码过程非常接近，因此我们通常将此步骤称为编码步骤。<br>为了强化混淆的效果，还可以交替多次使用上述两个方法，交替多次使用在现实场景中十分流行。</li></ul><p><strong>不透明常量</strong><br>对于常量也可以使用MBA表达式来混淆隐藏。隐藏常量使用<strong>置换多项式</strong>，它们是$\mathbb{Z}/2^n \mathbb{Z}$上的可逆多项式。常数混淆(或不透明常数)按以下方式构造：</p><ul><li>令多项式$P \in P_m(\mathbb{Z}/2^n \mathbb{Z})$，$Q$是$P$的反函数：$P(Q(X))=X, \forall X \in \mathbb{Z}/2^n \mathbb{Z}$</li><li>令$K\in \mathbb{Z}/2^n \mathbb{Z}$是想要隐藏的常量</li><li>令$E$是变量$(x_1,…,x_t)\in (\mathbb{Z}/2^n \mathbb{Z})^t$非平凡等于0的MBA表达式，例如$E=x+y-(x\oplus y)-2\times (x\land y)$</li></ul><p>那么$K$可以被$P(E+Q(K))=P(Q(K))=K$替换，无论$(x_1,…,x_t)$取何值该替换始终成立。</p><h4 id="2-1-3-生成新的MBA等式"><a href="#2-1-3-生成新的MBA等式" class="headerlink" title="2.1.3 生成新的MBA等式"></a>2.1.3 生成新的MBA等式</h4><p>Zhou等人提供了一个生成新的MBA等式的方法，该方法是从<strong>定理1</strong>中推导出来的的：</p><p><strong>Theorem 1</strong><br>令$n$是bit位数，$s$为按位表达式的数量，$t$为变量的数量，令</p><ul><li>$(X_1,…,X_k,…,X_t) \in \lbrace \lbrace 0, 1 \rbrace ^n \rbrace ^t$是变量的n位表示的向量</li><li>$e_0,…,e_j,…,e_{s-1}$是按位表达式</li><li>$e = \sum_{j=0}^{s-1} a_j e_j$是一个线性MBA表达式，有$a_j$个整数</li><li>后续见论文</li></ul><h3 id="2-2-表达式简化"><a href="#2-2-表达式简化" class="headerlink" title="2.2 表达式简化"></a>2.2 表达式简化</h3><p>对表达式进行简化有两种方法：</p><ol><li>计算两个相等对象的统一表示(规范形式)</li><li>寻找一个相等，但更简洁的表示形式</li></ol><p>第一种简化方法是研究最多的，因为它可以证明表达式的等价性并检查是否等于零。但是，规范形式未必是最简单的形式。<br>由于混淆的设计既可以应对人工分析和自动分析，因此程序和表达式的<strong>简洁性</strong>定义是二义的：对于人类而言，<strong>可读性</strong>更重要；而对于机器而言，性能问题则更重要。</p><p>算术多项式的简洁性难以定义，例如：<br>$$(x-3)^2-x^2+7x-7=x+2$$<br>$$(1+x)^100=1+100x+…+100x^99+x^100$$<br>有时多项式展开后更简洁，有时不展开更易读。</p><p>布尔函数的简化通常是将表达式规约为范式。</p><h3 id="2-3-比特向量逻辑"><a href="#2-3-比特向量逻辑" class="headerlink" title="2.3 比特向量逻辑"></a>2.3 比特向量逻辑</h3><p>计算机系统需要一个适合于机器逻辑的框架，用以描述元素和对这些元素的操作。在机器级别上，对象使用位向量(例如二进制)表示，处理器上任意可用的运算可以用来构建表达式。<br>位向量逻辑适用于这种机器表示形式：每个对象都由一个位向量表示，传统上考虑的运算符为：算术$+,-,\times,/$，布尔值$\oplus,\wedge,\lor,\lnot$，移位$\ll,\gg$，串联$\circ$等。<br>通常实现位向量逻辑的工具是SMT求解器，例如Z3和Boolector。尽管它们是约束求解器，而不是简化器，但它们有时提供简化，例如Z3的简化函数。</p><h3 id="2-4-术语重写"><a href="#2-4-术语重写" class="headerlink" title="2.4 术语重写"></a>2.4 术语重写</h3><p>重写系统由一组对象以及转换这些对象的操作组成。在术语重写的情况下，那些对象是术语(或表达式)。</p><h3 id="2-5-DAG表示"><a href="#2-5-DAG表示" class="headerlink" title="2.5 DAG表示"></a>2.5 DAG表示</h3><p>在计算机中，程序可以用抽象语法树AST和有向无环图DAG表示，同样的，表达式也可以用这两种图来表示。</p><p><strong>Definition 5</strong>：DAG representation.<br>MBA表达式的DAG表示是一个有下列特征的有向无环图：</p><ul><li>所有的叶子节点表示常量或变量，其他节点表示算术操作或位操作；</li><li>边代表操作顺序；</li><li>仅有一个根节点；</li><li>公共表达式在图中仅出现一次。</li></ul><p>值得注意的是，DAG表示与紧凑术语图表示是等价的。</p><h3 id="2-6-优化与反混淆"><a href="#2-6-优化与反混淆" class="headerlink" title="2.6 优化与反混淆"></a>2.6 优化与反混淆</h3><p>编译器通常具有与机器无关的优化阶段，该阶段程序的以IR表示(例如LLVM)。执行效率更高的代码其可读性较差，优化有时与反混淆有一个共同的目标。例如，消除死代码或常量替换(使用常量代替值不会改变的变量)能够提高代码可读性。某些混淆技术甚至可能无法抵抗优化过程，这类混淆实在是毫无用处。在本节中，我们介绍两种可以在理论上对任何程序进行混淆的优化技术，它们基于程序的行为而不是基于其描述：<strong>超优化</strong>和<strong>程序合成</strong>。</p><h4 id="2-6-1-超优化"><a href="#2-6-1-超优化" class="headerlink" title="2.6.1 超优化"></a>2.6.1 超优化</h4><p>超优化即为单个无循环汇编指令序列找到最佳代码。一般最佳代码是指执行最快的代码，或者时代码体积择最小的代码。<br>Massalin等提出的超优化方法时暴力法，它列举了增加长度的指令序列，并选择与目标序列等价的最低成本序列。</p><p>尽管超优化在一些混淆中是有用的，但它不能运行在我们定义的上下文中，否则会导致两个问题：</p><ul><li>对于超优化来说，最佳代码的定义基于性能(更快、更小)，这与我们的可读性目标不同；</li><li>与混淆相比，优化的对象的代码长度较小(例如优化只能操作10余条指定，而混淆可以操作更多)。</li></ul><h4 id="2-6-2-程序合成"><a href="#2-6-2-程序合成" class="headerlink" title="2.6.2 程序合成"></a>2.6.2 程序合成</h4><p>程序合成是根据用户意图自动寻找可执行程序的过程，这种意图是通过各种形式的约束来表达的，例如输入输出示例、演示、自然语言等。程序合成已经有了许多实际应用：生成最佳代码序列（超优化可以看作是程序合成的特殊情况）、自动执行重复的编程任务、优化对性能至关重要的内部循环等。</p><h2 id="3-MBA简化的难点"><a href="#3-MBA简化的难点" class="headerlink" title="3. MBA简化的难点"></a>3. MBA简化的难点</h2><h3 id="3-1-操作符不兼容"><a href="#3-1-操作符不兼容" class="headerlink" title="3.1 操作符不兼容"></a>3.1 操作符不兼容</h3><p>布尔运算和算术运算难以交互，因此需要特殊方法来处理混合计算。IDEA是90年代提出分组密码，以结合使用整数算术和按位运算符而闻名。IDEA的主要特征之一是缺少S盒，取而代之的是，它依赖于三个关键组件：</p><ul><li>乘法$\odot$</li><li>加法$\boxplus$</li><li>位异或$\oplus$</li></ul><p>IDEA的方法为本工作中的混合计算提供了灵感。同样的，密码学中加密的研究和混淆也有许多相似之处。</p><h3 id="3-2-已有的MBA简化工具"><a href="#3-2-已有的MBA简化工具" class="headerlink" title="3.2 已有的MBA简化工具"></a>3.2 已有的MBA简化工具</h3><p><strong>1. SMT求解器</strong></p><p>位向量逻辑是处理MBA表达式的良好理论框架，实现位向量逻辑的工具有SMT求解器。SMT求解器包括Z3、Boolector、Yices。<br>Z3使用位向量的原理，提供了多项式简化以及布尔运算简化，同时prove方法能够实现证明MBA表达式及其简化之间的等价性。但是Z3对于本文要解决的MBA表达式，其处理效率并不高，Z3中提出的两个步骤很有启发：第一个是<strong>重写</strong>，用以执行基本简化，重写通常是SMT求解器中所谓的预处理部分。第二步称为<strong>位爆破</strong>(也称为<strong>平整化</strong>)，即用二进制数代替整数重写整个公式。Boolector和Yices不能简化MBA表达式，只能证明MBA表达及其简化是等效的。</p><p><strong>编译器中的优化pass</strong></p><p>现代编译器(如LLVM)中的优化pass可以简化部分的MBA表达式，但是对复杂MBA就显得无能为力了。</p><h3 id="3-3-表达式的复杂性指标"><a href="#3-3-表达式的复杂性指标" class="headerlink" title="3.3 表达式的复杂性指标"></a>3.3 表达式的复杂性指标</h3><p>对一个MBA表达式，其复杂性的定义是比较困难的。例如表达式$x+y$和$(x \lor y) + (\lnot x \lor y) - (\lnot x)$，两个表达式对任意输入$x,y$，其计算结果都是相同的，但是左侧明显比右侧更简洁。<br>如何科学的定义表达式的复杂性，这里介绍几个常用的指标。</p><p><strong>1. DAG节点数</strong></p><p>由于可以使用DAG来表示一个expression，因此可以用DAG的节点数来衡量表达式的复杂性，节点越多越复杂。</p><p><strong>2. MBA交替</strong></p><p>MBA运算之所以复杂，是因为它混合了布尔计算和算术计算，因此可以使用MBA交替来衡量连接不同类型操作的操作数。例如$x \land y + x$，该表达式的MBA交替为1。纯算术或纯布尔表达式的MBA替换为0。<br>我们定义操作符$op \in \lbrace +,-,\times, \oplus,\wedge,\lor,\lnot \rbrace$，则MBA交替是DAG中连接不同类型的运算符的边的数目。即：对于一个图$G=(V,E)$，其MBA交替$alt_{MBA}(G)$是：<br>$$alt_{MBA}(G) = |\lbrace (v_1, v_2), type(v_1) \not = type(v_2) \rbrace |, (v_1, v_2) \in E$$<br>这些边代表了简化MBA表达式的难点，因为包含相同类型边的子图可以通过经典简化技术进行简化，而包含不同类型的子图则很难简化。</p><p><strong>3. 平均位向量大小</strong></p><p>在<a href="https://tel.archives-ouvertes.fr/tel-01623849/" target="_blank" rel="noopener">Obfuscation with Mixed Boolean-Arithmetic Expressions</a>这篇文献中还提到了一个称为平均位向量大小的指标。在DAG中，对于一个节点$v$，其位向量大小$bvsize(v)$是：</p><ul><li>若$v$是不是操作符，则它表示变量或常量的位数，位数可以从上下文中推导。</li><li>若$v$是操作符：<ul><li>若$v \in \lbrace +,-,\times, \oplus, \lor \rbrace$，且$v_1,v_2$为操作对象，则$bvsize(v)=max(bvsize(v_1),bvsize(v_2))$，即位数最大的那个；</li><li>若$v$为布尔操作$\land$，则$bvsize(v)=min(bvsize(v_1),bvsize(v_2))$，即位数最小的那个，例如$0b10110101 \land 0b1111$，前者的高四位经操作后都为0，所以取后者位数；</li><li>若$v$为一元操作符$\lbrace \lnot, - \rbrace$，则$bvsize(v)=bvsize(v_1)$。</li></ul></li></ul><p>增加变量的位数，可能会使混淆的破解变难罢了，但是变量位数的增加对表达式的复杂性并无影响，因此位向量大小作为评价表达式的复杂性无多大意义。</p><h2 id="4-MBA混淆技术分析"><a href="#4-MBA混淆技术分析" class="headerlink" title="4. MBA混淆技术分析"></a>4. MBA混淆技术分析</h2><p>本章介绍如何对表达式进行混淆和去混淆。随后提出了基于位和基于字的两种方法。两种方法在GitHub上都可找到：arybo是用C和Python实现的，并且是基于位爆方法的；SSPAM是用Python实现的，并且可以通过使用模式匹配在字级上工作。</p><h3 id="4-1-手动重建混淆过程"><a href="#4-1-手动重建混淆过程" class="headerlink" title="4.1 手动重建混淆过程"></a>4.1 手动重建混淆过程</h3><h4 id="4-1-1-从汇编到源码"><a href="#4-1-1-从汇编到源码" class="headerlink" title="4.1.1 从汇编到源码"></a>4.1.1 从汇编到源码</h4><p>使用Miasm逆向工程框架生成了混淆表达式的Python代码，并删除了与标志有关的表达式。源码以及反汇编的Python代码可参见论文图4.1、图4.2，得到的最终表达式见论文。</p><h4 id="4-1-2-其他混淆"><a href="#4-1-2-其他混淆" class="headerlink" title="4.1.2 其他混淆"></a>4.1.2 其他混淆</h4><p>在分析该MBA混淆表达的示例时，必须对其进行简化，以便排除与MBA混淆不相关的技术。</p><p><strong>位向量尺寸扩展</strong><br>在4.1.1中得到的表达式中，有两条是这样的：<br>$$f=((0x0D000000+0x67000000 \times (e+e-(0xFF \land d))) \gg 0x18)$$<br>$$R = (0xFF \land (0xC2 + 0xE5 \times (0x22 \lor (0xAE)f) + (0xFFFFB22D)f))$$<br>最终结果$R$是8位的(因为与上8位的0xFF)，所以可以将所有的表达式都简化为8位。但是由于存在位移操作，作者的做法是将$f$中的常量右移了24位，其余的都是直接截取后8位，最后再将16进制数转换成10进制。</p><p><strong>编码</strong><br>1.4.2节中介绍了使用编码的数据流混淆技术：相关变量在写入内存之前先进行编码，然后在读取时进行解码。传统上编码是一个仿射函数。 因此，此处作者使用了编码函数$x \mapsto 229x + 247$，解码函数为$x \mapsto 237 \times (x-247)$。</p><h4 id="4-1-3-MBA表达式的反混淆"><a href="#4-1-3-MBA表达式的反混淆" class="headerlink" title="4.1.3 MBA表达式的反混淆"></a>4.1.3 MBA表达式的反混淆</h4><p>本节举例介绍了如何得出混淆表达式，很多推导没看懂，在此不再整理。</p><h3 id="4-2-使用位爆炸的简化"><a href="#4-2-使用位爆炸的简化" class="headerlink" title="4.2 使用位爆炸的简化"></a>4.2 使用位爆炸的简化</h3><p>第一个简化方法是基于比特向量逻辑，即位爆炸方法。</p><h4 id="4-2-1-描述"><a href="#4-2-1-描述" class="headerlink" title="4.2.1 描述"></a>4.2.1 描述</h4><p>操作布尔表达式的范式是<strong>代数范式ANF</strong>，ANF是只包含$\oplus$和$\land$的表达式。</p><h2 id="5-MBA混淆技术的健壮性"><a href="#5-MBA混淆技术的健壮性" class="headerlink" title="5. MBA混淆技术的健壮性"></a>5. MBA混淆技术的健壮性</h2><h3 id="5-1-MBA混淆应对黑盒攻击的健壮性"><a href="#5-1-MBA混淆应对黑盒攻击的健壮性" class="headerlink" title="5.1 MBA混淆应对黑盒攻击的健壮性"></a>5.1 MBA混淆应对黑盒攻击的健壮性</h3><p>黑盒共计通过程序的输入和输出来推断程序的信息，为此通常要考虑两个问题：找到一个函数的良好近似需要多少个输入/输出对，以及应该使用哪种算法来构建该近似，在黑盒中重构函数的难度通常取决于函数本身，有几种策略可以提高重构函数的难度：</p><ul><li>添加不影响计算结果的变量；</li><li>增加位向量的大小，因为这会增加可能的重构函数的解空间；</li><li>增加表达式的节点数，因为这也会减慢输入/输出对的计算。<br>操作符混合并不能明显提高对黑盒攻击的抵抗性，因为它仅能减缓黑盒攻击的速度，而不能使反混淆攻击失败。</li></ul><h3 id="5-2-针对简化工具的弹性"><a href="#5-2-针对简化工具的弹性" class="headerlink" title="5.2 针对简化工具的弹性"></a>5.2 针对简化工具的弹性</h3><p>因为简化工具使用表达式的实际描述，因此它是白盒攻击。</p><h4 id="5-2-1-位爆炸"><a href="#5-2-1-位爆炸" class="headerlink" title="5.2.1 位爆炸"></a>5.2.1 位爆炸</h4><p>爆破方法的最大优势是将MBA简化问题转换为布尔表达式简化问题，该领域已经有很多前人展开过工作。使用位爆炸法时，我们可以使用几种范式来为任何表达式提供唯一的表示形式。<br>位爆炸的主要缺点是布尔表达式的规范化在内存和时间上代价很高。<br>另一个问题是，从布尔表达式到字级表达式的识别并不容易。在尝试识别一个运算符时，我们提供了一些技巧，但是识别包含多个运算符的更复杂表达式的问题显然是将来需要解决的问题。<br>作者使用<em>arybo</em>工具反混淆了几个MBA混淆表达式，当表达式位数为8位时只用了0.09s就能正确识别出原始表达式，但是当表达式位数为12位时，解析时间达到了61.32s。对于位数量较少的表达式，使用位爆破的简化非常有效。因此，可以通过提高位数来提高MBA混淆表达式的弹性。不过，作者在3.4.3节中介绍的还原方法可以轻松简化这种混淆。</p><h4 id="5-2-2-符号简化"><a href="#5-2-2-符号简化" class="headerlink" title="5.2.2 符号简化"></a>5.2.2 符号简化</h4><p>因为使用符号简化的算法在字级别上起作用，所以简化不受表达式位数增加的影响，另外，AST表达式的“大小”也远小于位爆破方法中的表示。例如，x+y在字级具有3个节点，可容纳任意数量的位；而4位的位爆破法则有3、6、17、41个节点。<br>这种方法的主要缺点是，它高度依赖于所选的重写规则集。即使具有所有混淆规则的列表，也不能保证具有令人满意的反混淆。<br>对于该种方法，作者使用了SSPAM工具来进行测试。对于使用一般混淆(公共可用)的混淆方法混淆的表达式，SSPAM都能够很快的进行发混淆。随后作者又使用Algorithm 2对原表达式进行混淆，每个表达式都会生成20个混淆表达式，这些混淆表达式作为输入送入SSPAM中，SSPAM不能从20个混淆表达式中成功反混淆出原表达式。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MBA Obfuscation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《周恩来传》时间线整理</title>
      <link href="/2019/09/16/Literature/a%20biography%20of%20zhou%20en-lai/"/>
      <url>/2019/09/16/Literature/a%20biography%20of%20zhou%20en-lai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/23774456/" target="_blank" rel="noopener">周恩来传</a>时间线整理</p><hr><a id="more"></a><h2 id="1-求索"><a href="#1-求索" class="headerlink" title="1. 求索"></a>1. 求索</h2><h3 id="童年-1898-1913"><a href="#童年-1898-1913" class="headerlink" title="童年(1898~1913)"></a>童年(1898~1913)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1898.03.05</td><td>周恩来出生于淮安，并被过继给叔父周贻淦(gan)，并由叔母陈三姑养育到5岁</td></tr><tr><td>1907</td><td>生母万冬儿因病去世</td></tr><tr><td>1910年春</td><td>12岁的周远赴铁岭、沈阳等地投奔伯父，不久后在奉天入读东关模范学校</td></tr><tr><td>1913年</td><td>15岁的周于东关模范学校毕业</td></tr></tbody></table><h3 id="求学天津-1913-1917"><a href="#求学天津-1913-1917" class="headerlink" title="求学天津(1913~1917)"></a>求学天津(1913~1917)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1913年</td><td>周随四伯父周贻赓来到天津，入读南开中学</td></tr><tr><td>1914年初</td><td>和朋友建立课外学习社团敬业乐群会，创刊《敬业》</td></tr><tr><td>1914年</td><td>在《敬业》上开始诗作</td></tr><tr><td>1916年5月</td><td>发表《诚能动物论》</td></tr><tr><td>1917.06.26</td><td>于南开中学毕业，学习十分优异，文科全校第一，立刻名列前茅</td></tr></tbody></table><p><strong>春日偶成•其一</strong></p><p>极目青郊外，烟霾布正浓。<br>中原方逐鹿，博浪踵相踪。</p><p><strong>春日偶成•其二</strong></p><p>樱花红陌上，柳叶绿池边。<br>燕子声声里，相思有一年。</p><h3 id="东渡日本-1917-1919"><a href="#东渡日本-1917-1919" class="headerlink" title="东渡日本(1917~1919)"></a>东渡日本(1917~1919)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1917年9月</td><td>在朋友的邀请下赴日求学</td></tr><tr><td>1919年</td><td>因凡尔赛条约及五四运动，毅然返国</td></tr></tbody></table><p>周在日本的两年内，没有学到新的知识。但在此期间，周接触到了马克思主义与社会主义。</p><h3 id="身陷囹圄-1919-1920"><a href="#身陷囹圄-1919-1920" class="headerlink" title="身陷囹圄(1919~1920)"></a>身陷囹圄(1919~1920)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1919.09.16</td><td>创建觉悟社，办《觉悟》杂志</td></tr><tr><td>1919.09.25</td><td>入读南开大学，任《天津学生联合会报》编辑</td></tr><tr><td>1919.01.20</td><td>在《觉悟》上发表短诗《死人的享福》</td></tr><tr><td>1920.01.29</td><td>周等因抗议被捕入狱</td></tr><tr><td>1920年7月</td><td>释放周等学生代表</td></tr></tbody></table><h3 id="留学法国-1920-1924"><a href="#留学法国-1920-1924" class="headerlink" title="留学法国(1920~1924)"></a>留学法国(1920~1924)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1920.11.07</td><td>22岁的周只身赴法</td></tr><tr><td>1921.02.28</td><td>领导大使馆请愿事件</td></tr><tr><td>1921年7月</td><td>中国共产党在上海成立，此时周还在法国</td></tr><tr><td>1921.09.21</td><td>占领里昂大学事件</td></tr><tr><td>1922年初</td><td>来到伦敦，进行两个多月的考察</td></tr><tr><td>1922年3月</td><td>赴德国柏林并居住了将近一年，期间结识朱德并介绍其入党</td></tr><tr><td>1922年6月</td><td>周在巴黎参与成立了旅欧中国少年共产党</td></tr><tr><td>1922年10月</td><td>返回巴黎</td></tr><tr><td>1924年7月下旬</td><td>离开法国</td></tr></tbody></table><h2 id="2-奋斗"><a href="#2-奋斗" class="headerlink" title="2. 奋斗"></a>2. 奋斗</h2><h3 id="革命婚姻-1924-1927"><a href="#革命婚姻-1924-1927" class="headerlink" title="革命婚姻(1924~1927)"></a>革命婚姻(1924~1927)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1924年9月</td><td>回到广州，担任中共广东区委书记和军事部长，以及黄埔军校政治部主任</td></tr><tr><td>1925年</td><td>参与讨伐广东军阀陈炯明，因军功提拔负责军法处兼管国民革命军第一军政治部</td></tr><tr><td>1925年3月</td><td>孙中山逝世，国民党左翼和右翼(反共)摩擦加剧</td></tr><tr><td>1925年8月</td><td>周恩来和邓颖超结婚</td></tr><tr><td>1925年10月</td><td>参加对陈炯明的第二次东征，作为特派员负责东江地区的政治工作</td></tr><tr><td>1926年3月</td><td>中山舰事件，国民党左派遭到右派打击，右翼分子掌权</td></tr><tr><td>1926.04.11</td><td>周被蒋解除第一军政部主任职务，随后又被解除汕头特派员职务</td></tr><tr><td>1926.04.29</td><td>中共召开会议，周恩来主动为中山舰事件揽责</td></tr><tr><td>1926年7月</td><td>北伐战争开始，由于国民党需要借助苏俄力量，不得以恢复共产党人职务</td></tr><tr><td>1927.03.21</td><td>领导上海起义，剑指北洋军阀</td></tr><tr><td>1927.04.12</td><td>412事件，蒋介石武在上海装袭杀共产党员5000余人，周逃离上海</td></tr></tbody></table><h3 id="南昌起义-1927-1931"><a href="#南昌起义-1927-1931" class="headerlink" title="南昌起义(1927~1931)"></a>南昌起义(1927~1931)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1927年7月</td><td>由于陈独秀的软弱领导，陈被解除党最高领导人职务，周等5人小组负责党的工作</td></tr><tr><td>1927.07.26</td><td>周前往南昌，商议南昌起义事宜，并“策反”了国军将领朱德、贺龙、叶挺等</td></tr><tr><td>1927.09.24</td><td>周领导的南昌起义的部队南下到达汕头，随后来到香港躲避国军追杀</td></tr><tr><td>1927年11月</td><td>周离开香港来到上海党总部</td></tr><tr><td>1928年6月</td><td>周于莫斯科参加中共第六次代表大会</td></tr></tbody></table><h3 id="前往江西-1931-1934"><a href="#前往江西-1931-1934" class="headerlink" title="前往江西(1931~1934)"></a>前往江西(1931~1934)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1931年12月</td><td>前往江西瑞金由毛泽东建立的革命根据地</td></tr><tr><td>1933年3月</td><td>第四次反围剿胜利</td></tr><tr><td>1933年5月</td><td>第五次反围剿失利，被迫长征转移革命根据地</td></tr></tbody></table><h3 id="长征-1934-1936"><a href="#长征-1934-1936" class="headerlink" title="长征(1934~1936)"></a>长征(1934~1936)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1934.10.16</td><td>开始长征</td></tr><tr><td>1935年1月</td><td>长征军到达贵州遵义，召开遵义会议，确定毛的党内领导地位</td></tr><tr><td>1935年</td><td>到达陕西，并收养了一个女儿孙维世</td></tr><tr><td>1936年1月</td><td>发表《致东北全体将士书》，呼吁国共统一战线对抗日本</td></tr><tr><td>1936年4月</td><td>周和张学良在延安会晤，协商统一战线</td></tr></tbody></table><h3 id="统一战线-1936-1940"><a href="#统一战线-1936-1940" class="headerlink" title="统一战线(1936~1940)"></a>统一战线(1936~1940)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1936.12.12</td><td>西安事变(双十二事变)，张学良在西安捉拿蒋介石</td></tr><tr><td>1937年6月</td><td>庐山会谈</td></tr><tr><td>1937.07.07</td><td>庐山会谈期间发生七七事变</td></tr><tr><td>1937年9月</td><td>周开赴山西抗日前线</td></tr><tr><td>1938年</td><td>周作为共方代表随南京国民政府撤退到武汉</td></tr><tr><td>1938年秋</td><td>周随国民政府撤退到长沙，随后又迁往重庆</td></tr><tr><td>1939年9月</td><td>因胳膊摔断，去莫斯科访问</td></tr><tr><td>1940年3月</td><td>回国</td></tr></tbody></table><h3 id="统一中国-1940-1949"><a href="#统一中国-1940-1949" class="headerlink" title="统一中国(1940~1949)"></a>统一中国(1940~1949)</h3><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1940年12月</td><td>皖南事变发生，周不顾危险继续在重庆工作</td></tr><tr><td>1943年7月</td><td>周回到延安参加整风运动，并筹备中共第七次全国代表大会</td></tr><tr><td>1945年8月</td><td>周陪同毛前往重庆参加谈判</td></tr><tr><td>1946年5月</td><td>国民政府回迁南京，周随同移居到梅园新村，继续国共谈判</td></tr><tr><td>1946.11.19</td><td>因国共谈判破裂，周飞回延安</td></tr><tr><td>1937.03.18</td><td>国军进攻延安，周等撤离延安，来到河北西柏坡</td></tr></tbody></table><h2 id="3-开国总理"><a href="#3-开国总理" class="headerlink" title="3. 开国总理"></a>3. 开国总理</h2><table><thead><tr><th>A.D.</th><th>REMARKS</th></tr></thead><tbody><tr><td>1949年6月</td><td>任政治协商会议副主任</td></tr><tr><td>1949年10月</td><td>周任国务院总理，兼任外交部部长</td></tr><tr><td>1950.01.20</td><td>飞抵莫斯科参加谈判</td></tr><tr><td>1953年3月</td><td>代表毛泽东参加斯大林葬礼</td></tr><tr><td>1954年4月</td><td>率领中国代表团参加日内瓦会议</td></tr><tr><td>1955年4月</td><td>率队参加万隆会议</td></tr><tr><td>1959年7月</td><td>庐山会议</td></tr><tr><td>1971年4月</td><td>促成乒乓外交</td></tr><tr><td>1976.01.08</td><td>09:57周恩来去世</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Literature </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Biography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用conda管理Python虚拟环境</title>
      <link href="/2019/09/09/computer_science/Tools/python_virtualenv_conda/"/>
      <url>/2019/09/09/computer_science/Tools/python_virtualenv_conda/</url>
      
        <content type="html"><![CDATA[<p>使用conda管理Python虚拟环境</p><hr><a id="more"></a><h2 id="1-安装Anaconda"><a href="#1-安装Anaconda" class="headerlink" title="1. 安装Anaconda"></a>1. 安装Anaconda</h2><p>可以在Anaconda官网下载相应Python版本的软件</p><h2 id="2-创建Python虚拟环境"><a href="#2-创建Python虚拟环境" class="headerlink" title="2. 创建Python虚拟环境"></a>2. 创建Python虚拟环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n virtual_env_name python=x.x</span><br></pre></td></tr></table></figure><h2 id="3-激活-关闭虚拟环境"><a href="#3-激活-关闭虚拟环境" class="headerlink" title="3. 激活/关闭虚拟环境"></a>3. 激活/关闭虚拟环境</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活</span></span><br><span class="line">source activate virtual_env_name</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">source deactivate</span><br></pre></td></tr></table></figure><h2 id="4-为相应的虚拟环境安装包"><a href="#4-为相应的虚拟环境安装包" class="headerlink" title="4. 为相应的虚拟环境安装包"></a>4. 为相应的虚拟环境安装包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n virtual_env_name [package]</span><br></pre></td></tr></table></figure><h2 id="5-删除虚拟环境"><a href="#5-删除虚拟环境" class="headerlink" title="5. 删除虚拟环境"></a>5. 删除虚拟环境</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n(--name) virtual_env_name</span><br></pre></td></tr></table></figure><h2 id="6-常用conda命令"><a href="#6-常用conda命令" class="headerlink" title="6. 常用conda命令"></a>6. 常用conda命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list  <span class="comment"># 列出所有已创建的虚拟环境</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Install Syntia with Ubuntu 18.04</title>
      <link href="/2019/09/09/computer_science/Information-Security/syntia_install/"/>
      <url>/2019/09/09/computer_science/Information-Security/syntia_install/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/RUB-SysSec/syntia" target="_blank" rel="noopener">Syntia</a>是基于程序合成的反混淆框架，它使用程序跟踪作为一个blackbox来产生随机的输入输出对，利用这些输入输出对，程序合成器可以学习代码的底层语义。本文介绍了Ubuntu下安装syntia</p><hr><a id="more"></a><h2 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/RUB-SysSec/syntia</span><br></pre></td></tr></table></figure><h2 id="2-安装第三方Python库Syntia"><a href="#2-安装第三方Python库Syntia" class="headerlink" title="2. 安装第三方Python库Syntia"></a>2. 安装第三方Python库Syntia</h2><p>syntia是一个第三方Python库，使用的是<strong>Python2</strong>。为了避免Python版本紊乱，可以使用conda创建一个Python2.7的虚拟环境，在该环境中安装syntia。在下载的源码中有setup.py文件，使用下面命令可以安装该Python库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h2 id="3-安装依赖软件"><a href="#3-安装依赖软件" class="headerlink" title="3. 安装依赖软件"></a>3. 安装依赖软件</h2><p>依赖软件包含在<em>install_deps.sh</em>脚本文件中，原则上可以通过执行该脚本文件来安装4个依赖，但是实际操作却总是报错。因此我使用手动安装</p><h3 id="3-1-安装Unicorn"><a href="#3-1-安装Unicorn" class="headerlink" title="3.1 安装Unicorn"></a>3.1 安装Unicorn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git下载源码</span></span><br><span class="line">git clone https://github.com/unicorn-engine/unicorn.git</span><br><span class="line"></span><br><span class="line">cd unicorn</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile</span></span><br><span class="line">./make.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># install</span></span><br><span class="line">sudo ./make.sh install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，命令执行后出现success，可认为是安装成功了</span></span><br><span class="line">./samples/sample_all.sh</span><br></pre></td></tr></table></figure><h3 id="3-2-安装Capstone"><a href="#3-2-安装Capstone" class="headerlink" title="3.2 安装Capstone"></a>3.2 安装Capstone</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git下载源码</span></span><br><span class="line">git clone https://github.com/aquynh/capstone.git</span><br><span class="line"></span><br><span class="line">cd capstone</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile</span></span><br><span class="line">./make.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># install</span></span><br><span class="line">sudo ./make.sh install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，我也不清楚验证结果是什么样代表正确安装</span></span><br><span class="line">./tests/test*</span><br></pre></td></tr></table></figure><h3 id="3-3-安装Miasm"><a href="#3-3-安装Miasm" class="headerlink" title="3.3 安装Miasm"></a>3.3 安装Miasm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装额外Python依赖库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用git下载源码</span></span><br><span class="line">git clone https://github.com/serpilliere/elfesteem.git elfesteem</span><br><span class="line"></span><br><span class="line">cd elfesteem</span><br><span class="line"></span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装miasm</span></span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line"><span class="comment"># 使用git下载源码</span></span><br><span class="line">git clone https://github.com/cea-sec/miasm.git</span><br><span class="line"></span><br><span class="line">cd miasm</span><br><span class="line"></span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line"><span class="comment"># 可以通过在Python编程环境中import miasm来验证，若不报错则说明成功安装</span></span><br></pre></td></tr></table></figure><h3 id="3-4-安装Z3"><a href="#3-4-安装Z3" class="headerlink" title="3.4 安装Z3"></a>3.4 安装Z3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git下载源码</span></span><br><span class="line">git clone https://github.com/Z3Prover/z3.git</span><br><span class="line"></span><br><span class="line">cd z3</span><br><span class="line"></span><br><span class="line">python scripts/mk_make.py --python</span><br><span class="line"></span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install    <span class="comment"># 该语句执行后会打印 Z3 was successfully installed.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MBA Obfuscation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熵权法</title>
      <link href="/2019/09/05/Mathematics/entropy_weight_method/"/>
      <url>/2019/09/05/Mathematics/entropy_weight_method/</url>
      
        <content type="html"><![CDATA[<p>熵权法计算权值，Python3实现</p><hr><a id="more"></a><h2 id="1-输入矩阵"><a href="#1-输入矩阵" class="headerlink" title="1. 输入矩阵"></a>1. 输入矩阵</h2><p>假设计算矩阵为：$x=[[1,2,2],[2,1,1]]$</p><h2 id="2-极差标准化"><a href="#2-极差标准化" class="headerlink" title="2. 极差标准化"></a>2. 极差标准化</h2><p>评价指标分为正指标和逆指标，计算公式如下</p><p>$$x_{ij}’=\frac{x_{ij} - \min_{j=1}^n x_{ij}}{\max_{j=1}^n x_{ij} - \min_{j=1}^n x_{ij}}$$</p><p>此处仅展示正指标计算公式。<br>将所有指标都视为正指标，标准化后的$x=[[0,1,1],[1,0,0]]$，可以使用scikit learn库中的MinMaxScaler()方法对数据进行最大最小归一化。</p><h2 id="3-计算指标信息熵"><a href="#3-计算指标信息熵" class="headerlink" title="3. 计算指标信息熵"></a>3. 计算指标信息熵</h2><p>信息熵是一个对象所能提供的信息量大小的量化指标，其范围在$(0,1)$之间。</p><p>$e$应当为$1*n$大小的矩阵，式中$e_j$代表第$j$项指标的信息熵，信息熵的计算公式为：<br>$$e_j = (-\frac{1}{\ln m})\sum_{i=1}^m (p_{ij} \cdot \ln p_{ij})$$<br>其中$p_{ij}$为第$j$个指标的状态为$i$时的概率，即<br>$$p_{ij}= \frac{x_{ij}}{\sum_{i=1}^m x_{ij}}$$<br>因此<br>$$e_j = (-\frac{1}{\ln m})\sum_{i=1}^m (\frac{x_{ij}}{\sum_{i=1}^m x_{ij}} \cdot \ln(\frac{x_{ij}}{\sum_{i=1}^m x_{ij}}))$$<br>应用到上述矩阵，可以得到$e=[0.9183, 0.9183, 0.9183]$即</p><table><thead><tr><th align="center">指标名称</th><th align="center">信息熵</th></tr></thead><tbody><tr><td align="center">指标1</td><td align="center">0.9183</td></tr><tr><td align="center">指标2</td><td align="center">0.9183</td></tr><tr><td align="center">指标3</td><td align="center">0.9183</td></tr></tbody></table><h2 id="4-计算指标权重"><a href="#4-计算指标权重" class="headerlink" title="4.计算指标权重"></a>4.计算指标权重</h2><p>$w$应当为$1*n$大小的矩阵，式中$w_j$代表第$j$项指标的权重<br>$$w_j = \frac{1 - e_j}{\sum_{j=1}^n (1-e_j)}$$<br>应用到上述$e$，可以得到$w=[0.33, 0.33, 0.33]$，即</p><table><thead><tr><th align="center">指标名称</th><th align="center">权重</th></tr></thead><tbody><tr><td align="center">指标1</td><td align="center">0.33</td></tr><tr><td align="center">指标2</td><td align="center">0.33</td></tr><tr><td align="center">指标3</td><td align="center">0.33</td></tr></tbody></table><h2 id="5-Coding"><a href="#5-Coding" class="headerlink" title="5. Coding"></a>5. Coding</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># language = python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">file = <span class="string">"test.csv"</span></span><br><span class="line">data = pd.read_csv(file, header = <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">x = data.values.astype(np.float64)</span><br><span class="line">x_std = MinMaxScaler().fit_transform(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Entropy_Weight</span><span class="params">(data)</span>:</span></span><br><span class="line">    m, n = np.shape(data)</span><br><span class="line">    p = data / data.sum(axis = <span class="number">0</span>)</span><br><span class="line">    p[np.where(data == <span class="number">0</span>)] = <span class="number">0.01</span></span><br><span class="line">    e = (<span class="number">-1.0</span> / np.log(m)) * np.nan_to_num(np.sum(p * np.log(p), axis = <span class="number">0</span>))</span><br><span class="line">    w = (<span class="number">1</span> - e) / np.sum(<span class="number">1</span> - e)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line">w = Entropy_Weight(x_std)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动2020校招笔试题</title>
      <link href="/2019/08/11/computer_science/Algorithm/byte-dance/"/>
      <url>/2019/08/11/computer_science/Algorithm/byte-dance/</url>
      
        <content type="html"><![CDATA[<p>字节跳动2020校招笔试真题</p><hr><a id="more"></a><h2 id="1-第二题"><a href="#1-第二题" class="headerlink" title="1. 第二题"></a>1. 第二题</h2><p>对于给定的一串0/1串，我们给定一种加密方式：</p><p>将字符串右移K-1次，每次右移一位，随后将这K串0/1串异或，得到的结果就是密文。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K = 2</span><br><span class="line">原始明文 = 101111</span><br><span class="line">右移一次 =  101111</span><br><span class="line">加密密文 = 1110001</span><br></pre></td></tr></table></figure><p>现给出加密后的密文、原文的长度以及K，求原文。</p><h2 id="2-第三题"><a href="#2-第三题" class="headerlink" title="2. 第三题"></a>2. 第三题</h2><p>第三题其实就是<a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">LeetCode第135题</a>。</p><p><strong>题目描述</strong></p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>解法</strong></p><p>使用一个数组C用来保存最终每个孩子分到的糖果数，先将数组C初始化为全1，表示每个孩子至少分到一个糖果。</p><p>随后从左边第1个元素开始向右遍历，如果当前孩子评分比前一个高，则该孩子分到的糖果比前一个孩子多1个，否则还是1个。</p><p>最后从右边第1个元素向左遍历，如果当前孩子比后一个评分高，如果当前孩子已有的糖果数比后一个孩子多，则不变，否则比后一个孩子多分一个糖果；如果当前孩子比后一个孩子评分低，则当前孩子分的糖果数不变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candy(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            candy[i] = (ratings[i] &gt; ratings[i - <span class="number">1</span>] ? (candy[i - <span class="number">1</span>] + <span class="number">1</span>): candy[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            candy[i] = (ratings[i] &gt; ratings[i + <span class="number">1</span>]) ? max(candy[i + <span class="number">1</span>] + <span class="number">1</span>, candy[i]) : candy[i];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            count += candy[i];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11/14/17新特性简单总结</title>
      <link href="/2019/08/11/computer_science/C-C++/C++14%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/08/11/computer_science/C-C++/C++14%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>C++11/14/17新特性简单总结</p><hr><a id="more"></a><h2 id="1-C-11新特性"><a href="#1-C-11新特性" class="headerlink" title="1. C++11新特性"></a>1. C++11新特性</h2><p>包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进</p><h3 id="1-auto关键字"><a href="#1-auto关键字" class="headerlink" title="1. auto关键字"></a>1. auto关键字</h3><p>C++11中引入auto第一种作用是为了自动类型推导，auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作。需要注意的是，<strong>使用auto声明一个变量时，必须对其进行初始化</strong>，因为auto是通过初始化表达式进行类型推导的。</p><h3 id="2-decltype关键字"><a href="#2-decltype关键字" class="headerlink" title="2. decltype关键字"></a>2. decltype关键字</h3><p>decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型</p><h3 id="3-nullptr"><a href="#3-nullptr" class="headerlink" title="3. nullptr"></a>3. nullptr</h3><p>nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0</p><h3 id="4-序列for循环"><a href="#4-序列for循环" class="headerlink" title="4. 序列for循环"></a>4. 序列for循环</h3><p>在C++中for循环可以使用类似python的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator）</p><h3 id="5-Lambda表达式"><a href="#5-Lambda表达式" class="headerlink" title="5. Lambda表达式"></a>5. Lambda表达式</h3><p>lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数]（操作符重载函数参数）-&gt;返回值类型&#123;函数体&#125;</span><br></pre></td></tr></table></figure><h3 id="6-其他。。。"><a href="#6-其他。。。" class="headerlink" title="6. 其他。。。"></a>6. 其他。。。</h3><h2 id="2-C-14新特性"><a href="#2-C-14新特性" class="headerlink" title="2. C++14新特性"></a>2. C++14新特性</h2><p>C++14的新特性主要分为三个领域：Lambda函数、constexpr和类型推导。</p><ul><li>函数返回类型auto</li><li>lambda参数auto</li><li>lambda捕获参数初始化</li><li>[[deprecated]]</li><li>二进制常量0b/0B</li><li>单引号分位符0b1111’0000</li><li>模板变量</li></ul><h2 id="3-C-17新特性"><a href="#3-C-17新特性" class="headerlink" title="3. C++17新特性"></a>3. C++17新特性</h2><ol><li>结构化绑定auto</li><li>[a, b]构造函数模板推导std::pair{1, 5.0}</li><li>inline变量</li><li>if constexpr</li><li>fold表达式</li><li>非类型模板参数auto</li><li>satic_assert自定义错误信息</li><li>typename代替class声明模板的模板参数</li><li>嵌套命名空间namespace X::Y {…}</li><li>新增加属性[[fallthrough]] [[maybe_unused]] [[nodiscard]]</li><li>if/switch初始化</li><li>string_view</li><li>variant/any/optional</li><li>void_t</li><li>container.extract</li><li>删除trigraphs（即三连字符??*)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中结构体和类的区别</title>
      <link href="/2019/08/10/computer_science/C-C++/different_between_struct_and_class/"/>
      <url>/2019/08/10/computer_science/C-C++/different_between_struct_and_class/</url>
      
        <content type="html"><![CDATA[<p>C++中结构体和类的区别</p><hr><a id="more"></a><h2 id="1-C和C-中struct的不同"><a href="#1-C和C-中struct的不同" class="headerlink" title="1. C和C++中struct的不同"></a>1. C和C++中struct的不同</h2><ol><li>C中的结构体只能定义成员变量，不能定义成员函数，C++可以；</li><li>C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性；</li><li>C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1;</li><li>C++中之所以要引入结构体，是为了保持和C程序的兼容性。C++中不使用结构体丝毫不会影响程序的表达能力，但有时仍会在C++中使用结构体，这是因为使用结构体将不同类型数据组成整体便于保存数据。（若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦。）</li></ol><h2 id="2-C-中struct和class的不同"><a href="#2-C-中struct和class的不同" class="headerlink" title="2. C++中struct和class的不同"></a>2. C++中struct和class的不同</h2><p>C++中struct和class唯一的不同是<strong>struct和class具有不同的默认访问控制属性</strong>，class中的成员的默认控制访问属性为private，而struct中的默认访问控制属性为public。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法总结与比较</title>
      <link href="/2019/08/08/computer_science/Algorithm/sort/"/>
      <url>/2019/08/08/computer_science/Algorithm/sort/</url>
      
        <content type="html"><![CDATA[<p>本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。</p><hr><a id="more"></a><h2 id="1-总体比较"><a href="#1-总体比较" class="headerlink" title="1. 总体比较"></a>1. 总体比较</h2><p><strong>时间复杂度与稳定性</strong></p><table><thead><tr><th align="center">类别</th><th align="center">名称</th><th align="center">平均复杂度</th><th align="center">最好情况</th><th align="center">最差情况</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">交换比较类</td><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">交换比较类</td><td align="center">快速排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(logn)$</td><td align="center">不稳定</td></tr><tr><td align="center">选择类</td><td align="center">选择排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">选择类</td><td align="center">堆排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">插入类</td><td align="center">直接插入</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">插入类</td><td align="center">二分排序</td><td align="center">$O(n^2)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(n^2)$</td><td align="center">–</td><td align="center">稳定</td></tr><tr><td align="center">插入类</td><td align="center">希尔排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">$O(n^s)1$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">其他</td><td align="center">归并排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">基数排序</td><td align="center">$O(log_R B)$</td><td align="center">–</td><td align="center">$O(log_R B)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">二叉排序</td><td align="center">$O(nlogn)$</td><td align="center">–</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">计数排序</td><td align="center">$O(n+k)$</td><td align="center">–</td><td align="center">$O(n+k)$</td><td align="center">$O(k)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">拓扑排序</td><td align="center">$O(n+e)$</td><td align="center">–</td><td align="center">–</td><td align="center">$O(n)$</td><td align="center">–</td></tr><tr><td align="center">其他</td><td align="center">枚举排序</td><td align="center">$O(n^2)$</td><td align="center">–</td><td align="center">–</td><td align="center">–</td><td align="center">–</td></tr></tbody></table><p><strong>算法特性</strong></p><table><thead><tr><th align="center">名称</th><th align="center">时间复杂度与初序</th><th align="center">移动次数与初序</th><th align="center">比较次数与初序</th><th align="center">排序趟数与初序</th><th align="center">每趟确定最终位置</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td align="center">快速排序</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td align="center">选择排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">-</td></tr><tr><td align="center">堆排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">-</td><td align="center">⭕️</td></tr><tr><td align="center">直接插入</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">二分排序</td><td align="center">-</td><td align="center">-</td><td align="center">❌</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">希尔排序</td><td align="center">⭕️</td><td align="center">-</td><td align="center">⭕️</td><td align="center">-</td><td align="center">❌</td></tr><tr><td align="center">归并排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">⭕️</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">基数排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">二叉排序</td><td align="center">⭕️</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">计数排序</td><td align="center">⭕️</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">拓扑排序</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">枚举排序</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p>冒泡排序是一种典型的交换排序算法，相邻两数两两⽐比较并交换，直到所有数据排序完成，每一趟排序总能够将无序队列中的最⼤/小置于队尾。<br><strong>适用情况</strong>: 待排序列列较小时性能较优。<br><strong>最坏情况</strong>: 初始序列基本有序但顺序相反<br><strong>最好情况</strong>: 初始序列列基本有序(没有插⼊快，因为要两两比较)<br><strong>应用</strong>: 对基本有序序列查前n个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.size() - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">                swap(<span class="built_in">array</span>[j + <span class="number">1</span>], <span class="built_in">array</span>[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p>反复选择未排序序列中最大或最小元素，并将其放于已排序序列尾部，直到未排序序列长度为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">array</span>.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-直接插入排序"><a href="#4-直接插入排序" class="headerlink" title="4. 直接插入排序"></a>4. 直接插入排序</h2><p>将数据分为有序和无序两部分，首先有序部分为空，依次从无序部分中拿出元素插入到有序序列中<br><strong>可能出现情况</strong>: 最后一趟开始前，所有元素都不在正确位置上<br><strong>最佳情况</strong>: 基本有序下，插⼊排序是最快的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[i], j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>n越⼤大越好<br><strong>优点</strong>: 当待排序列列较大，内存一次性放不不下时，需要外部排序，通常使用归并排序<br><strong>归并趟数</strong>: m个元素k路归并趟数$s = log_k m$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)<span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> MergeSort(<span class="built_in">array</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l1, j = l2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(<span class="built_in">array</span>.size());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[j])</span><br><span class="line">            temp[index++] = <span class="built_in">array</span>[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[index++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r1)</span><br><span class="line">        temp[index++] = <span class="built_in">array</span>[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r2)</span><br><span class="line">        temp[index++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        <span class="built_in">array</span>[l1 + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(<span class="built_in">array</span>, left, mid);</span><br><span class="line">        MergeSort(<span class="built_in">array</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        Merge(<span class="built_in">array</span>, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p>分治法<br><strong>优点</strong>: 平均最快，平均比较次数最少<br><strong>最好情况</strong>: 每次能够均匀划分<br><strong>最坏情况</strong>: 序列有序，或不均匀划分<br><strong>优化</strong>: 快排需要使用递归，因此处理左右子段时，先处理短子段可以减少时间复杂度。先处理短⼦段的话，每次递归深度都是短⼦段的长度<br><strong>对排序对象的要求</strong>: 待排序列的存储方式是顺序存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)<span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> QuickSort(<span class="built_in">array</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[right] &gt; temp)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="built_in">array</span>[left] = <span class="built_in">array</span>[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[left] &lt; temp)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="built_in">array</span>[right] = <span class="built_in">array</span>[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[left] = temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = Partition(<span class="built_in">array</span>, left, right);</span><br><span class="line">        QuickSort(<span class="built_in">array</span>, left, pos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(<span class="built_in">array</span>, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 探索初级算法 字符串</title>
      <link href="/2019/08/07/computer_science/Algorithm/Primary_Algorithm_String/"/>
      <url>/2019/08/07/computer_science/Algorithm/Primary_Algorithm_String/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://leetcode-cn.com/problems/reverse-string/submissions/" target="_blank" rel="noopener">反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">整数反转</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></li><li><a href="https://leetcode-cn.com/problems/valid-anagram/submissions/" target="_blank" rel="noopener">有效的字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文字符串</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">字符串转换整数(atoi)</a></li><li><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现strStr()</a></li><li>报数</li><li>最长公共前缀</li></ol><hr><a id="more"></a><h2 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><h3 id="解法1：双指针法"><a href="#解法1：双指针法" class="headerlink" title="解法1：双指针法"></a>解法1：双指针法</h3><p>设置双指针i、j分别指向头尾，交换头尾后各向中间进1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="解法2：reverse函数"><a href="#解法2：reverse函数" class="headerlink" title="解法2：reverse函数"></a>解法2：reverse函数</h3><p>直接使用reverse()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2. 整数反转"></a>2. 整数反转</h2><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><h3 id="解法：模拟栈"><a href="#解法：模拟栈" class="headerlink" title="解法：模拟栈"></a>解法：模拟栈</h3><p>每次对x取%10余，并将余数×10累加到res中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cur;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX/<span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; cur &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN/<span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; cur &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(log(x))$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="3-字符串中的第一个唯一字符"><a href="#3-字符串中的第一个唯一字符" class="headerlink" title="3. 字符串中的第一个唯一字符"></a>3. 字符串中的第一个唯一字符</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">返回2.</span><br></pre></td></tr></table></figure><h3 id="解法：hash表"><a href="#解法：hash表" class="headerlink" title="解法：hash表"></a>解法：hash表</h3><p>使用map保存字符-位置键对，且这一键对的值为该字符出现的次数。随后从头按字符出现的次序遍历map，第一个键值为1的便是解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            hash[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (hash[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">**复杂度分析**</span><br><span class="line"></span><br><span class="line">- 时间复杂度：$O(n)$</span><br><span class="line">- 空间复杂度：$O(n)$</span><br></pre></td></tr></table></figure><h2 id="4-有效的字母异位词"><a href="#4-有效的字母异位词" class="headerlink" title="4. 有效的字母异位词"></a>4. 有效的字母异位词</h2><p>给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aacc&quot;, t = &quot;ccac&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="解法：hash表-1"><a href="#解法：hash表-1" class="headerlink" title="解法：hash表"></a>解法：hash表</h3><p>使用26大小的数组作为hash表，同时遍历s和t，并在对应位分别++和–。最后再遍历一遍hash表，如果存在不为0的元素，则说明s和t字符不对应，即不是异位词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() != t.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            count[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            count[t[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : count)</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="5-验证回文字符串"><a href="#5-验证回文字符串" class="headerlink" title="5. 验证回文字符串"></a>5. 验证回文字符串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="解法：双指针法"><a href="#解法：双指针法" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h3><p>利用双指针分别从头和尾进行比较，两个关键函数：isalnum()判断是否为字母数字，以及tolower()转换成小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i++]) != <span class="built_in">tolower</span>(s[j--]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="6-字符串转换整数-atoi"><a href="#6-字符串转换整数-atoi" class="headerlink" title="6. 字符串转换整数(atoi)"></a>6. 字符串转换整数(atoi)</h2><p>请你来实现一个atoi函数，使其能将字符串转换成整数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这题实在是太麻烦了，各种意想不到的输入都需要考虑到，因此这里提供一个懒人方法，使用sstream库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">        is &gt;&gt; digit;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="7-实现strStr"><a href="#7-实现strStr" class="headerlink" title="7. 实现strStr()"></a>7. 实现strStr()</h2><p>给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置(从0开始)。如果不存在，则返回-1</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h3 id="解法1：暴力求解"><a href="#解法1：暴力求解" class="headerlink" title="解法1：暴力求解"></a>解法1：暴力求解</h3><p>从头至尾遍历一遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)) :</span><br><span class="line">            <span class="keyword">if</span> needle == haystack[i : i + len(needle)]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(nm)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="解法2：KMP算法"><a href="#解法2：KMP算法" class="headerlink" title="解法2：KMP算法"></a>解法2：KMP算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getnext(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=str.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next.push_back(<span class="number">-1</span>);<span class="comment">//next数组初值为-1</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">-1</span>||str[j]==str[k]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(str[j]!=str[k])</span><br><span class="line">                    next.push_back(k);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    next.push_back(next[k]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k=next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//源串</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//子串</span></span><br><span class="line">        <span class="keyword">int</span> len1=haystack.size();</span><br><span class="line">        <span class="keyword">int</span> len2=needle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next=getnext(needle);</span><br><span class="line">        <span class="keyword">while</span>((i&lt;len1)&amp;&amp;(j&lt;len2)) &#123;</span><br><span class="line">            <span class="keyword">if</span>((j==<span class="number">-1</span>)||(haystack[i]==needle[j])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j=next[j];<span class="comment">//获取下一次匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len2)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n+m)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="解法3：BM算法"><a href="#解法3：BM算法" class="headerlink" title="解法3：BM算法"></a>解法3：BM算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_bmB</span><span class="params">(<span class="built_in">string</span>&amp; T,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bmB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tlen=T.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">            bmB.push_back(tlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tlen<span class="number">-1</span>;i++) &#123;</span><br><span class="line">            bmB[T[i]]=tlen-i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_suff</span><span class="params">(<span class="built_in">string</span>&amp; T,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tlen=T.size();</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tlen<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            k=i;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;=<span class="number">0</span>&amp;&amp;T[k]==T[tlen<span class="number">-1</span>-i+k])</span><br><span class="line">                k--;</span><br><span class="line">            suff[i]=i-k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_bmG</span><span class="params">(<span class="built_in">string</span>&amp; T,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bmG)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> tlen=T.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suff(tlen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        get_suff(T,suff);<span class="comment">//suff存储子串的最长匹配长度</span></span><br><span class="line">        <span class="comment">//初始化 当没有好后缀也没有公共前缀时</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tlen;i++)</span><br><span class="line">            bmG[i]=tlen;</span><br><span class="line">        <span class="comment">//没有好后缀 有公共前缀 调用suff 但是要右移一位 类似KMP里的next数组</span></span><br><span class="line">        <span class="keyword">for</span>(i=tlen<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(suff[i]==i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;tlen<span class="number">-1</span>;j++)</span><br><span class="line">                    <span class="keyword">if</span>(bmG[j]==tlen)<span class="comment">//保证每个位置不会重复修改</span></span><br><span class="line">                        bmG[j]=tlen<span class="number">-1</span>-i;</span><br><span class="line">        <span class="comment">//有好后缀 有公共前缀</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tlen<span class="number">-1</span>;i++)</span><br><span class="line">            bmG[tlen<span class="number">-1</span>-suff[i]]=tlen<span class="number">-1</span>-i;<span class="comment">//移动距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tlen=needle.size();</span><br><span class="line">        <span class="keyword">int</span> slen=haystack.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bmG(tlen,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bmB;</span><br><span class="line">        get_bmB(needle,bmB);</span><br><span class="line">        get_bmG(needle,bmG);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=slen-tlen) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=tlen<span class="number">-1</span>;j&gt;<span class="number">-1</span>&amp;&amp;haystack[i+j]==needle[j];j--);</span><br><span class="line">            <span class="keyword">if</span>(j==(<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            i+=max(bmG[j],bmB[haystack[i+j]]-(tlen<span class="number">-1</span>-j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：最差$O(n+m)$，最好$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 探索初级算法 数组</title>
      <link href="/2019/08/03/computer_science/Algorithm/Primary_Algorithm_Array/"/>
      <url>/2019/08/03/computer_science/Algorithm/Primary_Algorithm_Array/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">从数组中删除重复项</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复</a></li><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集II</a></li><li><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></li><li><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">有效的数独</a></li><li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></li></ol><hr><a id="more"></a><h2 id="1-旋转数组"><a href="#1-旋转数组" class="headerlink" title="1. 旋转数组"></a>1. 旋转数组</h2><p>给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h3 id="解法1：暴力解法"><a href="#解法1：暴力解法" class="headerlink" title="解法1：暴力解法"></a>解法1：暴力解法</h3><p>旋转k次，每次将数组向右旋转移动一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre, tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[nums.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">            tmp = nums[j];</span><br><span class="line">            nums[j] = pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$</li><li>空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$</li></ul><h3 id="解法2：使用额外数组"><a href="#解法2：使用额外数组" class="headerlink" title="解法2：使用额外数组"></a>解法2：使用额外数组</h3><p>使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        arr[(i + k) % nums.size()] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        nums[i] = arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$</li><li>空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$</li></ul><h3 id="解法3：使用环状替换"><a href="#解法3：使用环状替换" class="headerlink" title="解法3：使用环状替换"></a>解法3：使用环状替换</h3><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.size(); start++) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = start;</span><br><span class="line">        <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> next = (current + k) % nums.size();</span><br><span class="line">            <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">            nums[next] = prev;</span><br><span class="line">            prev = temp;</span><br><span class="line">            current = next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：只遍历了一遍数组，$O(n)$</li><li>空间复杂度：只用了常数个额外空间，$O(1)$</li></ul><h3 id="解法4：数组反转"><a href="#解法4：数组反转" class="headerlink" title="解法4：数组反转"></a>解法4：数组反转</h3><p>先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.size())</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">    reverse(nums.begin(), nums.end());</span><br><span class="line">    reverse(nums.begin(), nums.begin() + k);</span><br><span class="line">    reverse(nums.begin() + k, nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$，没有使用额外空间</li></ul><h2 id="2-从数组中删除重复项"><a href="#2-从数组中删除重复项" class="headerlink" title="2. 从数组中删除重复项"></a>2. 从数组中删除重复项</h2><p>给定一个排序数组，你需要在<strong>原地删除重复出现的元素</strong>，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成.</p><h3 id="解法：双指针法"><a href="#解法：双指针法" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h3><p>数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜</span><br><span class="line"> i                   i                   i</span><br><span class="line"> j                   j                 j</span><br><span class="line"></span><br><span class="line">[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ...</span><br><span class="line">       i                 i                   i</span><br><span class="line">   j                   j                   j</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j:nums)</span><br><span class="line">            <span class="keyword">if</span> (!i || j &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[i++] = j;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="3-买卖股票的最佳时机II"><a href="#3-买卖股票的最佳时机II" class="headerlink" title="3. 买卖股票的最佳时机II"></a>3. 买卖股票的最佳时机II</h2><p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出,</span><br><span class="line">    　这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入，</span><br><span class="line">    　在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出,</span><br><span class="line">    　这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票，</span><br><span class="line">    　之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h3 id="解法：暴力解法"><a href="#解法：暴力解法" class="headerlink" title="解法：暴力解法"></a>解法：暴力解法</h3><p>首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论：</p><ul><li>一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断；</li><li>一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_buy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices[<span class="number">0</span>] &lt; prices[<span class="number">1</span>]) &#123;</span><br><span class="line">            profit -= prices[<span class="number">0</span>];</span><br><span class="line">            has_buy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (has_buy == <span class="literal">true</span> &amp;&amp; prices[i] &gt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                profit += prices[i];</span><br><span class="line">                has_buy = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_buy == <span class="literal">false</span> &amp;&amp; prices[i] &lt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                profit -= prices[i];</span><br><span class="line">                has_buy = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (has_buy == <span class="literal">true</span>)</span><br><span class="line">            profit += *(prices.end() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="4-存在重复"><a href="#4-存在重复" class="headerlink" title="4. 存在重复"></a>4. 存在重复</h2><p>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。</p><h3 id="解法：使用unorder-set"><a href="#解法：使用unorder-set" class="headerlink" title="解法：使用unorder_set"></a>解法：使用unorder_set</h3><p>使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.count(it) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">set</span>.insert(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="5-只出现一次的数字"><a href="#5-只出现一次的数字" class="headerlink" title="5. 只出现一次的数字"></a>5. 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h3 id="解法：使用异或"><a href="#解法：使用异或" class="headerlink" title="解法：使用异或"></a>解法：使用异或</h3><p>该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            ans ^= i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="6-两个数组的交集II"><a href="#6-两个数组的交集II" class="headerlink" title="6. 两个数组的交集II"></a>6. 两个数组的交集II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]</span><br><span class="line">输出: [2,3,5]</span><br></pre></td></tr></table></figure><h3 id="解法：使用find-函数"><a href="#解法：使用find-函数" class="headerlink" title="解法：使用find()函数"></a>解法：使用find()函数</h3><p>使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=find(nums2.begin(),nums2.end(),nums1[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=nums2.end()) &#123;</span><br><span class="line">                res.push_back(*it);</span><br><span class="line">                nums2.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \sim O(n^2)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="7-加一"><a href="#7-加一" class="headerlink" title="7. 加一"></a>7. 加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字123。</span><br></pre></td></tr></table></figure><h3 id="解法：反向遍历"><a href="#解法：反向遍历" class="headerlink" title="解法：反向遍历"></a>解法：反向遍历</h3><p>首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        digits[digits.size() - <span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = digits.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                digits[i - <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">10</span>) &#123;</span><br><span class="line">            digits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="8-移动零"><a href="#8-移动零" class="headerlink" title="8. 移动零"></a>8. 移动零</h2><p>给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br><span class="line">说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。</span><br></pre></td></tr></table></figure><h3 id="解法：双指针法-1"><a href="#解法：双指针法-1" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h3><p>设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="9-两数之和"><a href="#9-两数之和" class="headerlink" title="9. 两数之和"></a>9. 两数之和</h2><p>给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [0,1]</span><br><span class="line">说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h3><p>暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                    ans.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="解法2：两遍哈希表"><a href="#解法2：两遍哈希表" class="headerlink" title="解法2：两遍哈希表"></a>解法2：两遍哈希表</h3><p>以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash_set;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash_set.count(target - nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(hash_set[target - nums[i]]);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash_set[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="10-有效的数独"><a href="#10-有效的数独" class="headerlink" title="10. 有效的数独"></a>10. 有效的数独</h2><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="解法：一次遍历"><a href="#解法：一次遍历" class="headerlink" title="解法：一次遍历"></a>解法：一次遍历</h3><p>使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; rows(<span class="number">9</span>), cols(<span class="number">9</span>), boxes(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">int</span> box_index = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">char</span> n = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(n != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    rows[i][n] = <span class="number">1</span>;</span><br><span class="line">                    cols[j][n] = <span class="number">1</span>;</span><br><span class="line">                    boxes[box_index][n] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="11-旋转图像"><a href="#11-旋转图像" class="headerlink" title="11. 旋转图像"></a>11. 旋转图像</h2><p>给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定matrix= </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解法：翻转"><a href="#解法：翻转" class="headerlink" title="解法：翻转"></a>解法：翻转</h3><p>先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">            reverse(matrix[i].begin(), matrix[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的内联函数</title>
      <link href="/2019/07/30/computer_science/C-C++/inline_in_C++/"/>
      <url>/2019/07/30/computer_science/C-C++/inline_in_C++/</url>
      
        <content type="html"><![CDATA[<p>内联函数相关知识点梳理</p><hr><a id="more"></a><h2 id="1-内联函数的作用"><a href="#1-内联函数的作用" class="headerlink" title="1. 内联函数的作用"></a>1. 内联函数的作用</h2><p>引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Expression(a, b) (((a) + (b)) * ((a) - (b)))</span></span><br></pre></td></tr></table></figure><p>该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它<strong>使用预处理器实现</strong>，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏<strong>不能进行参数有效性检测</strong>，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。</p><p>另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。</p><p>为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。</p><h2 id="2-inline与宏定义的区别"><a href="#2-inline与宏定义的区别" class="headerlink" title="2. inline与宏定义的区别"></a>2. inline与宏定义的区别</h2><ul><li>inline函数的本质是一个函数，而宏不是；</li></ul><ul><li>inline函数在编译时展开，宏在预编译时展开；</li></ul><ul><li>在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换；</li></ul><ul><li>inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能；</li></ul><ul><li>宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。</li></ul><h2 id="3-inline的优点"><a href="#3-inline的优点" class="headerlink" title="3. inline的优点"></a>3. inline的优点</h2><ul><li>inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高；</li></ul><ul><li>类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性；</li></ul><ul><li>inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。</li></ul><h2 id="4-inline的使用场合"><a href="#4-inline的使用场合" class="headerlink" title="4. inline的使用场合"></a>4. inline的使用场合</h2><ul><li>用于取代表达式形式的宏定义；</li></ul><ul><li>用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，<strong>定义在类体内的函数会被自动转换成内联函数</strong>。</li></ul><h2 id="5-inline的缺点"><a href="#5-inline的缺点" class="headerlink" title="5. inline的缺点"></a>5. inline的缺点</h2><p><strong>inline是以代码复制为代价的</strong>，仅仅省去了函数调用的开销，从而提高函数的执行效率。<strong>若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低</strong>。另外，<strong>每一处内联函数的调用都需要复制代码</strong>，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline：</p><ul><li>函数体内代码较长：使用inline将导致较高的内存消耗；</li></ul><ul><li>函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大；</li></ul><ul><li>不用于类的构造函数和析构函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的数据类型及其大小</title>
      <link href="/2019/07/29/computer_science/C-C++/data_type_in_C++/"/>
      <url>/2019/07/29/computer_science/C-C++/data_type_in_C++/</url>
      
        <content type="html"><![CDATA[<p>在C/C++中的数据类型及其所占空间大小总结</p><hr><a id="more"></a><h2 id="1-内置数据类型"><a href="#1-内置数据类型" class="headerlink" title="1. 内置数据类型"></a>1. 内置数据类型</h2><p>常见的内置数据类型如下表所示，可以使用sizeof查看其大小：</p><table><thead><tr><th>type</th><th align="left">size</th></tr></thead><tbody><tr><td>char</td><td align="left">1B</td></tr><tr><td>unsigned char</td><td align="left">1B</td></tr><tr><td>signed char</td><td align="left">1B</td></tr><tr><td>int</td><td align="left">4B</td></tr><tr><td>unsigned int</td><td align="left">4B</td></tr><tr><td>signed int</td><td align="left">4B</td></tr><tr><td>short (int)</td><td align="left">2B</td></tr><tr><td>long (int)</td><td align="left">8B</td></tr><tr><td>float</td><td align="left">4B</td></tr><tr><td>double</td><td align="left">8B</td></tr><tr><td>long double</td><td align="left">16B</td></tr><tr><td>wchar_t</td><td align="left">2B or 4B</td></tr></tbody></table><p>其中wchar_t是宽字符型，其定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>也就是说，实际上wchar_t和short int是等价的。</p><h2 id="2-数组与字符串"><a href="#2-数组与字符串" class="headerlink" title="2. 数组与字符串"></a>2. 数组与字符串</h2><p>对数组使用sizeof运算，其大小为<strong>数组中元素的个数*元素所占内存大小</strong>，而对于char数组型的字符串，例如<br><code>char str[] = &quot;Hello&quot;</code>，其大小为字符个数+1，因为结尾需要保存<strong>\0</strong>。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。</p><h2 id="3-自定义数据类型"><a href="#3-自定义数据类型" class="headerlink" title="3. 自定义数据类型"></a>3. 自定义数据类型</h2><h3 id="3-1-class及struct"><a href="#3-1-class及struct" class="headerlink" title="3.1. class及struct"></a>3.1. class及struct</h3><h4 id="3-1-1-空类"><a href="#3-1-1-空类" class="headerlink" title="3.1.1. 空类"></a>3.1.1. 空类</h4><p>对于一个空类，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大小为1B，因为C++中<strong>每一个类都有一个独一无二的地址</strong>，因此即使是空类也会为其分配1B的内存空间。</p><h4 id="3-1-2-类对象所占内存大小"><a href="#3-1-2-类对象所占内存大小" class="headerlink" title="3.1.2. 类对象所占内存大小"></a>3.1.2. 类对象所占内存大小</h4><p><strong>类所占的内存大小由其成员变量决定，成员函数不计算在内</strong>，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(A) = 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(B) = 4, 成员函数不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(C) = 1, 结构体不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stc1</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> sa;</span><br><span class="line">        <span class="keyword">char</span> sb;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(D) = 1, 联合体不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">union</span> un1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ua;</span><br><span class="line">        <span class="keyword">short</span> ub;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(E) = 1, class不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">cl1</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ca;</span><br><span class="line">        <span class="keyword">short</span> cb;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-类对象的字节对齐"><a href="#3-1-3-类对象的字节对齐" class="headerlink" title="3.1.3. 类对象的字节对齐"></a>3.1.3. 类对象的字节对齐</h4><p>由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能<strong>从某些特定地址开始存取</strong>，如果不对其，会给存取效率带来损失。</p><p>字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则：</p><ol><li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节；</li><li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。</li></ol><p>如果类中包含虚函数，则<strong>无论其有多少个虚函数，这些虚函数所占内存均为4B</strong>，因为内存中需要保存一个虚表指针成员</p><p>举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ii;</span><br><span class="line">    <span class="keyword">short</span> j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ii;</span><br><span class="line">    <span class="keyword">int</span> iii;</span><br><span class="line">    <span class="keyword">short</span> j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">J</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A, <span class="keyword">virtual</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ii;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(A) = 4</span></span><br><span class="line"><span class="comment">// sizeof(B) = 1</span></span><br><span class="line"><span class="comment">// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8</span></span><br><span class="line"><span class="comment">// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8</span></span><br><span class="line"><span class="comment">// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12</span></span><br><span class="line"><span class="comment">// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16</span></span><br><span class="line"><span class="comment">// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12</span></span><br><span class="line"><span class="comment">// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)</span></span><br><span class="line"><span class="comment">// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)</span></span><br><span class="line"><span class="comment">// sizeof(J) = 8</span></span><br><span class="line"><span class="comment">// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16</span></span><br><span class="line"><span class="comment">// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中)</span></span><br></pre></td></tr></table></figure><h3 id="3-2-union"><a href="#3-2-union" class="headerlink" title="3.2. union"></a>3.2. union</h3><p>联合体的大小取决于该体中<strong>所有的成员中占用空间最大的一个成员的大小</strong>，并且同样的需要对齐：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> u1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> u2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> u3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(u1) = 8;</span></span><br><span class="line"><span class="comment">// sizeof(u2) = 13 + 3(以int的整数倍补齐);</span></span><br><span class="line"><span class="comment">// sizeof(u3) = 13;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下GDB的使用</title>
      <link href="/2019/07/27/computer_science/Linux/gdb_in_ubuntu/"/>
      <url>/2019/07/27/computer_science/Linux/gdb_in_ubuntu/</url>
      
        <content type="html"><![CDATA[<p>最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧</p><hr><a id="more"></a><h2 id="1-使用GDB调试可执行文件"><a href="#1-使用GDB调试可执行文件" class="headerlink" title="1. 使用GDB调试可执行文件"></a>1. 使用GDB调试可执行文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb a.out               <span class="comment"># 不带参数</span></span><br><span class="line">或</span><br><span class="line">gdb --args a.out 参数   <span class="comment"># 带参数</span></span><br></pre></td></tr></table></figure><h2 id="2-GDB常用命令"><a href="#2-GDB常用命令" class="headerlink" title="2. GDB常用命令"></a>2. GDB常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">r [args]                <span class="comment"># 带参数从头开始执行程序</span></span><br><span class="line">b arg                   <span class="comment"># 在arg处设置断点，arg可以为行数、地址</span></span><br><span class="line">b xxx <span class="keyword">if</span> (condition)    <span class="comment"># 条件断点</span></span><br><span class="line">b test.c:30 <span class="keyword">if</span> n==100   <span class="comment"># 当变量n等于100的时候在test.c的30行处加断点</span></span><br><span class="line">n (next)                <span class="comment"># 单步执行，如遇函数则直接返回函数的执行结果</span></span><br><span class="line">s (step)                <span class="comment"># 单步执行，如遇函数则进入函数体执行</span></span><br><span class="line">stop                    <span class="comment"># 停止执行</span></span><br><span class="line">q (quit)                <span class="comment"># 退出GDB</span></span><br><span class="line">until                   <span class="comment"># 当不想反复执行循环时，可以用until跳出循环</span></span><br><span class="line">finish                  <span class="comment"># 跳出当前函数</span></span><br><span class="line">c (<span class="built_in">continue</span>)            <span class="comment"># 继续执行，直到下一个断点或程序结束</span></span><br><span class="line">p arg                   <span class="comment"># 打印出arg的值，arg可以为变量或地址</span></span><br><span class="line">whatis variable         <span class="comment"># 打印出变量的类型</span></span><br><span class="line">ptype variable          <span class="comment"># 打印出变量的类型，只不过比whatis更详细</span></span><br><span class="line">i variables variable    <span class="comment"># 打印出定义variable的文件</span></span><br><span class="line">i <span class="built_in">source</span>                <span class="comment"># 查看当前程序</span></span><br><span class="line">i b                     <span class="comment"># 查看arg，arg可以为断点、变量值、</span></span><br><span class="line">i args                  <span class="comment"># 打印出当前函数的参数值</span></span><br><span class="line">i locals                <span class="comment"># 打印出当前函数中所有局部变量值</span></span><br><span class="line">i r (r_name)            <span class="comment"># 查看所有寄存器(寄存器r_name)的值</span></span><br><span class="line">i threads               <span class="comment"># 查看线程</span></span><br><span class="line">d b                     <span class="comment"># 删除断点，b为断点编号</span></span><br><span class="line">bt                      <span class="comment"># 查看函数的back trace</span></span><br><span class="line">l (list) arg            <span class="comment"># 显示arg附近的前后共10行代码，arg可以为行数或函数名</span></span><br><span class="line">watch arg               <span class="comment"># 设置监控，在arg改变时停止(需要先加断点)</span></span><br></pre></td></tr></table></figure><h2 id="3-设置断点"><a href="#3-设置断点" class="headerlink" title="3. 设置断点"></a>3. 设置断点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当欲设断点在当前文件中时，可以b+行数或b+函数名</span></span><br><span class="line">b 45/main</span><br><span class="line"><span class="comment"># 当欲设断点在其他文件中时，b 文件名:行数</span></span><br><span class="line">b head.cpp:45</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中const、define和static</title>
      <link href="/2019/07/03/computer_science/C-C++/const_define_static_in_C++/"/>
      <url>/2019/07/03/computer_science/C-C++/const_define_static_in_C++/</url>
      
        <content type="html"><![CDATA[<p>关键字const、define和static相关知识点整理</p><hr><a id="more"></a><h2 id="1-const和define区别"><a href="#1-const和define区别" class="headerlink" title="1. const和define区别"></a>1. const和define区别</h2><ol><li>宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查;</li><li>const常量存在于程序的数据段，并在<strong>堆栈</strong>分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查;</li></ol><h2 id="2-C-中关键字const的作用"><a href="#2-C-中关键字const的作用" class="headerlink" title="2. C++中关键字const的作用"></a>2. C++中关键字const的作用</h2><ol><li>定义常量;</li><li>修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A <span class="keyword">const</span> &amp;a)</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">GetChar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> *ch = GetChar();       <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ch = GetChar()  <span class="comment">//correct</span></span><br></pre></td></tr></table></figure><ol start="4"><li>const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeoCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-静态变量static"><a href="#3-静态变量static" class="headerlink" title="3. 静态变量static"></a>3. 静态变量static</h2><h3 id="1-static的作用"><a href="#1-static的作用" class="headerlink" title="1. static的作用"></a>1. static的作用</h3><ol><li>一个static变量可以维持其值在被调用的过程中不变；</li><li>在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问；</li><li>模块内的一个static修饰的<strong>函数</strong>只可以被该模块内的函数调用。</li></ol><h3 id="2-static变量和普通变量的区别"><a href="#2-static变量和普通变量的区别" class="headerlink" title="2. static变量和普通变量的区别"></a>2. static变量和普通变量的区别</h3><h4 id="1-static全局变量和普通全局变量"><a href="#1-static全局变量和普通全局变量" class="headerlink" title="1. static全局变量和普通全局变量"></a>1. static全局变量和普通全局变量</h4><ol><li>static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值；</li><li>static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用；</li><li>（相同点）两种都以<strong>静态存储方式</strong>存储；</li></ol><h4 id="2-static局部变量和普通局部变量"><a href="#2-static局部变量和普通局部变量" class="headerlink" title="2. static局部变量和普通局部变量"></a>2. static局部变量和普通局部变量</h4><ol><li>static局部变量只被初始化一次，下一次使用依据上一次的结果</li></ol><h4 id="3-static函数和普通函数"><a href="#3-static函数和普通函数" class="headerlink" title="3. static函数和普通函数"></a>3. static函数和普通函数</h4><ol><li>static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品；</li><li>static函数作用域仅在本文件中，普通函数可在其他文件被调用；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Array</title>
      <link href="/2019/06/29/computer_science/Data-Structure/array/"/>
      <url>/2019/06/29/computer_science/Data-Structure/array/</url>
      
        <content type="html"><![CDATA[<p>学习数组时的一个简单的笔记</p><hr><a id="more"></a><h2 id="数组及其初始化"><a href="#数组及其初始化" class="headerlink" title="数组及其初始化"></a>数组及其初始化</h2><p>对于一个只声明未赋值的int型数组，如果该数组为全局变量，该数组会被初始化为0，若为局部变量，则被初始化为乱值；</p><hr><h2 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h2><p><strong>稀疏矩阵</strong>：对于一个稀疏矩阵(即矩阵中的大部分元素为0)，可以使用三元组表示法对其压缩。在一个三元组中，每一个一个条目都形如(行号, 列号, 值)，稀疏矩阵中的每一个非零值由三元组表中的条目唯一表示。稀疏矩阵经过三元组压缩存储后，会失去随机存取能力；</p><p><strong>特殊矩阵</strong>：特殊矩阵形如上三角矩阵、对角矩阵、对称矩阵等，特殊矩阵的压缩存储并不会丧失随机存取的能力。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS/Ubuntu 18.10 安装PyTorch</title>
      <link href="/2019/03/30/computer_science/Linux/PyTorch_for_Linux/"/>
      <url>/2019/03/30/computer_science/Linux/PyTorch_for_Linux/</url>
      
        <content type="html"><![CDATA[<p>MacOS/Ubuntu 18.10 安装PyTorch</p><a id="more"></a><hr><h2 id="1-MacOS-Ubuntu-18-10-安装Conda管理环境"><a href="#1-MacOS-Ubuntu-18-10-安装Conda管理环境" class="headerlink" title="1. MacOS/Ubuntu 18.10 安装Conda管理环境"></a>1. MacOS/Ubuntu 18.10 安装Conda管理环境</h2><p>MacOS下前往Anaconda官网下载安装即可<br>Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.<br>如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加<em>export PATH=”/home/user_name/anaconda3/bin:$PATH”</em>并source一下即可</p><hr><h2 id="2-MacOS-Ubuntu-18中安装PyTorch"><a href="#2-MacOS-Ubuntu-18中安装PyTorch" class="headerlink" title="2. MacOS/Ubuntu 18中安装PyTorch"></a>2. MacOS/Ubuntu 18中安装PyTorch</h2><ol><li>(可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n environment_name python=X.X (2.7/3.6)   # 创建虚拟环境</span><br><span class="line">conda info --env    # 显示所有的conda虚拟环境</span><br><span class="line">conda activate environment_name # 激活虚拟环境</span><br></pre></td></tr></table></figure><ol start="2"><li>修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> for Anaconda</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> for PyTroch</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><ol start="3"><li>安装PyTorch</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision</span><br><span class="line">conda deactivate    # 使用结束后退出虚拟环境</span><br></pre></td></tr></table></figure><hr><h2 id="3-虚拟环境中安装jupyter"><a href="#3-虚拟环境中安装jupyter" class="headerlink" title="3. 虚拟环境中安装jupyter"></a>3. 虚拟环境中安装jupyter</h2><p>如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install jupyter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> PyTorch </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Queue</title>
      <link href="/2019/03/04/computer_science/Data-Structure/Queue/"/>
      <url>/2019/03/04/computer_science/Data-Structure/Queue/</url>
      
        <content type="html"><![CDATA[<p>A note to queue</p><hr><a id="more"></a><h2 id="1-循环队列"><a href="#1-循环队列" class="headerlink" title="1. 循环队列"></a>1. 循环队列</h2><ol><li>计算大小为n的循环队列中元素的个数</li></ol><center>$(rear - front + n) % n$</center> <center>$(rear - front + n + 1) % n$</center><ol start="2"><li>循环队列判空</li></ol><center>$front = rear$</center><ol start="3"><li>循环队列判满</li></ol><center>$(rear + 1) % n = front $</center><ol start="4"><li>出队后头指针front的值</li></ol><center>$ front = (front + 1) % m $</center>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.10安装LLVM</title>
      <link href="/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/"/>
      <url>/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/</url>
      
        <content type="html"><![CDATA[<p>因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本</p><hr><a id="more"></a><h2 id="1-安装cmake"><a href="#1-安装cmake" class="headerlink" title="1.安装cmake"></a>1.安装cmake</h2><p>安装LLVM需要使用cmake，可以使用如下命令安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><h2 id="2-修改swap分区-可选，不推荐"><a href="#2-修改swap分区-可选，不推荐" class="headerlink" title="2.修改swap分区(可选，不推荐)"></a>2.修改swap分区(可选，不推荐)</h2><p>从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下：</p><ol><li>查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon --show</span><br><span class="line">or</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><ol start="2"><li>检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><ol start="3"><li>在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a     # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，</span><br><span class="line">sudo fallocate -l 20G /swapfile     # 创建swapfile</span><br><span class="line">ls -lh /swapfile    # 验证是否成功创建swapfile，</span><br></pre></td></tr></table></figure><p>　　如果显示<em>-rw——1 root root 20G 日期 /swapfile</em> 则表示创建成功</p><ol start="4"><li>启用交换文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 600 /swapfile    # 锁定swapfile权限</span><br><span class="line">sudo mkswap /swapfile       # 将文件标记为交换空间</span><br></pre></td></tr></table></figure><p>　　若显示:<em>Setting up swapspace……</em> 则表示成功标记swapfile，标记之后启用该文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon /swapfile   # 启用</span><br><span class="line">free -h                 # 验证</span><br></pre></td></tr></table></figure><ol start="5"><li>永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/fstab /etc/fstab.bak   # 备份</span><br><span class="line">echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab  # 将swap文件信息添加到/etc/fstab文件</span><br></pre></td></tr></table></figure><hr><h2 id="3-安装LLVM-8-0-Debug版本"><a href="#3-安装LLVM-8-0-Debug版本" class="headerlink" title="3.安装LLVM-8.0 Debug版本"></a>3.安装LLVM-8.0 Debug版本</h2><ol><li>首先去<a href="http://releases.llvm.org/download.html#8.0.0" target="_blank" rel="noopener">LLVM官网</a>下载必要的软件包;</li><li>获取源码:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在适当位置放置LLVM源码，此处放在home下</span><br><span class="line">cd ~</span><br><span class="line">mkdir tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压LLVM源码</span><br><span class="line">cd tmp</span><br><span class="line">tar -Jxvg llvm-7.0.0.src.tar.xz</span><br><span class="line">mv llvm-7.0.0.src llvm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压clang源码(此时在tmp目录下)</span><br><span class="line">cd llvm/tools</span><br><span class="line">tar -Jxvg cfe-7.0.0.src.tar.xz</span><br><span class="line">mv cfe-7.0.0.src clang</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)</span><br><span class="line">cd clang/tools</span><br><span class="line">tar -Jxvg clang-tools-extra-7.0.0.src.tar.xz</span><br><span class="line">mv clang-tools-extra-7.0.0.src extra</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)</span><br><span class="line">cd ~/tmp/llvm/projects</span><br><span class="line">tar -Jxvg compiler-rt-7.0.0.src.tar.xz</span><br><span class="line">mv compiler-rt-7.0.0.src compiler-rt</span><br></pre></td></tr></table></figure><ol start="3"><li>开始安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在tmp目录下新建build文件夹</span><br><span class="line">cd build</span><br><span class="line">cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug ../llvm</span><br><span class="line">make -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将路径添加到环境变量中</span><br><span class="line">cd ~</span><br><span class="line">vim .bashrc</span><br><span class="line">export PATH=/usr/lib/llvm-7/bin</span><br><span class="line">export LD_LIBRARY_PATH=/usr/lib/llvm-7/lib</span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><ol start="4"><li>重启终端并测试</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -v</span><br><span class="line">clang++ -v</span><br><span class="line">clang test.c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.10安装与配置</title>
      <link href="/2017/06/04/computer_science/Linux/install_ubuntu/"/>
      <url>/2017/06/04/computer_science/Linux/install_ubuntu/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu 18.10安装与配置</p><a id="more"></a><hr><h2 id="1-安装Ubuntu-18-10"><a href="#1-安装Ubuntu-18-10" class="headerlink" title="1. 安装Ubuntu 18.10"></a>1. 安装Ubuntu 18.10</h2><p>安装过程不多说，安装镜像可以去<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">中科大镜像</a>下载。</p><hr><h2 id="2-安装搜狗输入法"><a href="#2-安装搜狗输入法" class="headerlink" title="2. 安装搜狗输入法"></a>2. 安装搜狗输入法</h2><ol><li>前往<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">搜狗输入法官网</a>下载deb安装文件，双击安装；</li><li>前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt；</li><li>当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法；</li><li>重启系统。</li></ol><hr><h2 id="3-修改软件源"><a href="#3-修改软件源" class="headerlink" title="3. 修改软件源"></a>3. 修改软件源</h2><p>应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn</p><hr><h2 id="4-安装Chrome"><a href="#4-安装Chrome" class="headerlink" title="4. 安装Chrome"></a>4. 安装Chrome</h2><p>前往<a href="https://www.google.cn/intl/zh-CN_ALL/chrome/" target="_blank" rel="noopener">Chrome官网</a>下载.deb安装包，双击安装即可。</p><hr><h2 id="5-开启夜览模式"><a href="#5-开启夜览模式" class="headerlink" title="5. 开启夜览模式"></a>5. 开启夜览模式</h2><p>夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整：</p><ol><li>打开Terminal安装dconf-editor</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dconf-editor</span><br></pre></td></tr></table></figure><ol start="2"><li>在终端打开dconf-editor</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><ol start="3"><li>dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature</li><li>关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适</li></ol><hr><h2 id="6-系统美化"><a href="#6-系统美化" class="headerlink" title="6. 系统美化"></a>6. 系统美化</h2><p>安装Tweaks工具用以配置桌面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure><p>在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有：</p><ul><li>Weather In The Clock，点击屏幕上方的时间可以展示天气;</li><li>Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏；</li></ul><hr><h2 id="7-配置终端"><a href="#7-配置终端" class="headerlink" title="7. 配置终端"></a>7. 配置终端</h2><ol><li>安装zsh与git</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh </span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><ol start="2"><li>安装oh-my-zsh</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><ol start="3"><li>将Shell切换到zsh，登出并重新登入</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><ol start="4"><li>在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME="ys"</span><br></pre></td></tr></table></figure><ol start="5"><li>安装一些强大的zsh插件<br>首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.oh-my-zsh/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure><ol start="6"><li>同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction To Data Structure</title>
      <link href="/2016/09/23/computer_science/Data-Structure/introduction/"/>
      <url>/2016/09/23/computer_science/Data-Structure/introduction/</url>
      
        <content type="html"><![CDATA[<p>对常见数据结构的一个简单地总结</p><hr><a id="more"></a><h2 id="1-数据结构定义"><a href="#1-数据结构定义" class="headerlink" title="1. 数据结构定义"></a>1. 数据结构定义</h2><p>数据结构是指<strong>相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成</strong>，记为：</p><center>$Data Structure = (D, R)$</center>其中$D$是数据元素的集合，$R$是$D$中元素之间的关系的集合。  <p>通俗的理解，<strong>数据结构=逻辑结构(线性、非线性) + 存储结构(顺序、链式、索引、散列)</strong></p><ul><li>逻辑结构：数据元素间抽象化的相互关系</li><li>存储结构：数据在计算机中的存储形式，也是物理结构</li></ul><hr><h2 id="2-逻辑结构"><a href="#2-逻辑结构" class="headerlink" title="2. 逻辑结构"></a>2. 逻辑结构</h2><p>数据的逻辑结构是指数据之间的逻辑关系，比如一对一、一对多、多对一、多对多等。通常，逻辑关系可以分为两种：线性关系和非线性关系。线性关系指：<strong>除第一个外，每个元素有且只有一个前驱；除最后一个元素外，每个元素有且只有一个后继</strong>。</p><p>常见的逻辑结构有以下几种：</p><ul><li><strong>集合</strong>：数据元素间没有任何关系</li><li><strong>线性结构</strong>：数据元素间存在线性关系</li><li><strong>树</strong>：数据元素间有层次关系</li><li><strong>图</strong>：数据元素间you网状关系</li></ul><p><strong>常见的线性结构</strong>：线性表、栈、队列、双队列、数组、串等<br><strong>常见的非线性结构</strong>：多维数组、树、图、广义表等</p><hr><h2 id="3-存储结构"><a href="#3-存储结构" class="headerlink" title="3. 存储结构"></a>3. 存储结构</h2><p>数据的存储结构是指数据在计算机中的存储形式，也是数据的物理结构。</p><p>常见的存储结构有以下几种：</p><ol><li><strong>顺序存储</strong>：逻辑上相邻的节点存储在物理位置上相邻的存储单元中，节点之间的逻辑关系由存储单元的邻接关系体现<ul><li>优点：可实现对节点的随机存取</li><li>缺点：不便于插入、删除，因为要大量移动数据</li></ul></li><li><strong>链式存储</strong>：逻辑上相邻的节点在物理存储上不相邻，而是通过指针等体现逻辑关系<ul><li>优点：便于插入、删除，存储密度比顺序存储小</li><li>缺点：不便于查找</li></ul></li><li><strong>索引存储</strong>：通过建立索引表来标识节点的地址</li><li><strong>散列存储</strong>：根据节点的关键字直接计算出节点的存储地址</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP中的拥塞控制简介</title>
      <link href="/2015/05/27/computer_science/Computer-Network/congestion_control/"/>
      <url>/2015/05/27/computer_science/Computer-Network/congestion_control/</url>
      
        <content type="html"><![CDATA[<p>TCP中的拥塞控制的目的是控制网络拥塞的出现，网络拥塞的原因多种多样，比如某结点的缓存太小、某段链路带宽太低等等。为了防止网络拥塞，V.Jacobson在1988年的论文中提出了用于TCP的拥塞控制，由慢开始和拥塞避免组成，后来在TCP Reno版本中又加入了快重传和快恢复。这4种技术能够很好的避免网络拥塞。</p><hr><a id="more"></a><h2 id="1-慢开始"><a href="#1-慢开始" class="headerlink" title="1. 慢开始"></a>1. 慢开始</h2><p>如果将网络通路比作高速公路，那么我们可以想象一下，如果这条路的出口只有一个车道，而入口却有很多车道，那么这条路必然会造成拥塞。慢开始就是针对这一情况而提出的。其基本思想是逐渐增大发送的数据大小(即拥塞窗口)直到指定的阈值(即慢开始阈值)。</p><p>在慢开始中，发送端除了要维护正常情况下根据接收端发来的窗口大小字段值而调整的<strong>发送窗口</strong>外，还要维护一个<strong>拥塞窗口(Congestion Window, CWND)</strong>，CWND的目的是为了避免发生拥塞，最终<strong>允许发送的字节数是CWND和发送窗口两者中的最小值</strong>。</p><p>下面介绍慢开始的具体步骤(假设CWND总是小于发送窗口)：</p><ol><li>在TCP传输连接建立时，发送端将CWND初始化为该连接上当前使用的最大数据段大小(Maximum Segment Size, MSS)，即CWND=MSS，然后发送端发送一个MSS大小的数据段M1。</li><li>如果在定时器过期前发送端收到了该数据段的确认(即对M1的确认)，则发送端将CWND大小翻倍，即CWND=2MSS，并发送2MSS大小的数据，假定发送的数据段位M2、M3。</li><li>同样的，如果在定时器过期前发送端接收到确定(收到M3的确认即可，即只用确认最后一个)，再次将CWND翻倍，并以此类推。</li><li>当出现数据丢失时，需要将<strong>慢开始阈值(Slow Start Threshold, SSTHRESH)</strong>设置为当前CWND的一半，并将CWND重设为1MSS。并重新开始慢开始，此时若CWND再次达到SSTHRESH便停止使用慢开始，转用拥塞避免。</li></ol><p>值得注意的是，一般SSTHRESH初始值为64KB。</p><p><img src="https://raw.githubusercontent.com/fengggggggg/figure_for_blog/master/13afefqewf23232f.png" alt></p><h2 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2. 拥塞避免"></a>2. 拥塞避免</h2><p>拥塞避免的基本思想是，当CWND再次达到SSTHRESH时，让拥塞窗口的大小每经过一个RTT(数据传输往返时间)时仅增加1MSS。如果这时还是发生了数据丢失，同样的还是把SSTHRESH设为当前CWND的一半，把CWND设为1MSS，并重新开始慢开始。</p><h2 id="3-快重传-快恢复"><a href="#3-快重传-快恢复" class="headerlink" title="3. 快重传/快恢复"></a>3. 快重传/快恢复</h2><p>快重传的基本思想是，当接收端收到一个不是按序到达的数据段时，TCP实体迅速发送一个重复ACK数据段，而不用等到有数据需要发送时才顺带发出重复ACK。在连续收到3个重复ACK数据段后，即认为对应确认号字段的数据丢失，TCP不等重传定时器超时就会重传丢失的数据段。</p><p>快恢复是在快重传发挥作用时，确切的说是收到第三个重复ACK时，把当前CWND设为当前SSTHRESH的一半，以减轻网络负载，然后执行拥塞避免算法。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见路由算法</title>
      <link href="/2015/04/14/computer_science/Computer-Network/routing_algorithm/"/>
      <url>/2015/04/14/computer_science/Computer-Network/routing_algorithm/</url>
      
        <content type="html"><![CDATA[<p>路由算法是指从源节点和目的节点之间选择一条最佳的路径用于传输数据。为了完成这个任务，在路由器中通常会收集和保存各种与传输路径相关的数据，如拓扑结构、端口度量、端口速率等，然后根据相应的路由算法生成路由表，在数据发送时提供路由选择。</p><p>一般而言，路由算法分为自适应路由算法和非自适应路由算法。</p><hr><a id="more"></a><h2 id="1-非自适应路由算法"><a href="#1-非自适应路由算法" class="headerlink" title="1. 非自适应路由算法"></a>1. 非自适应路由算法</h2><p>非自适应路由算法是指不能根据网络流量和拓扑结构的变化动态更新路由表的算法，这类算法使用静态路由表。</p><h3 id="1-1-静态路由"><a href="#1-1-静态路由" class="headerlink" title="1.1 静态路由"></a>1.1 静态路由</h3><p>静态路由是指由管理员手动在路由表中一条条添加路由选项，这种方法费时费力，都不能称之为算法。不过RapidIO中采用了这种方法，RapidIO是嵌入式通信网络之一，其路由表建立的方式之一就是将路由表烧进芯片里。</p><h3 id="1-2-扩散法"><a href="#1-2-扩散法" class="headerlink" title="1.2 扩散法"></a>1.2 扩散法</h3><p>扩散法是指当一个路由收到报文分组后，向它所有的端口复制扩散该报文。因为有多条路径，所以即使网络局部瘫痪也不影响通信，但是大量重复加重了网络负担，因此这种算法适合规模较小、通信负载轻、可靠性要求极高的通信场合，如军用通信。</p><h3 id="1-3-随机走动法"><a href="#1-3-随机走动法" class="headerlink" title="1.3 随机走动法"></a>1.3 随机走动法</h3><p>该方法指挡路有收到报文分组后，随机选择一个端口将其发送出去。这种方法通信效率低、实用价值低。</p><h3 id="1-4-最短路径法"><a href="#1-4-最短路径法" class="headerlink" title="1.4 最短路径法"></a>1.4 最短路径法</h3><p>该算法是指利用Dijkstra算法构建一个节点之间的最短路径，即跳数最少的路径，作为路由表。每次收到报文后查询路由表进行转发。</p><h3 id="1-5-基于流量的路由算法"><a href="#1-5-基于流量的路由算法" class="headerlink" title="1.5 基于流量的路由算法"></a>1.5 基于流量的路由算法</h3><p>最短路径算法只考虑网络拓扑结构，而基于流量的算法还会考虑网络流量及负载。</p><h2 id="2-自适应路由算法"><a href="#2-自适应路由算法" class="headerlink" title="2. 自适应路由算法"></a>2. 自适应路由算法</h2><p>自适应路由算法是指能根据网络流量和拓扑情况而动更新路由表的算法。该类算法一般分为两类，一类是路由中只保留相邻器的路由信息的分散式路由算法，另一类是保留网络(或部分网络)中所有路由器的全部信息的总体式路由算法。</p><h3 id="2-1-距离矢量路由算法"><a href="#2-1-距离矢量路由算法" class="headerlink" title="2.1 距离矢量路由算法"></a>2.1 距离矢量路由算法</h3><p>距离矢量路由算法(Distance Vector, DV)是分散式路由算法的一种，而DV是指源节点和目的节点之间所经过的路由器的数目减一(需要减去源节点直连路由器)，该距离也称为跳数。采用DV的经典路由协议有<strong>RIP</strong>、<strong>内部网关协议IGRP</strong>、<strong>增强型内部网关协议EIGRP</strong>和<strong>边界网关协议BGP</strong>。</p><h3 id="2-2-链路状态路由算法"><a href="#2-2-链路状态路由算法" class="headerlink" title="2.2 链路状态路由算法"></a>2.2 链路状态路由算法</h3><p>该算法是总体式路由算法的一种，又被称为最短路径优先算法，它和基于流量的路由算法有点类似，只是前者会动态更新路由表，而后者不会。使用该算法的路由协议有<strong>开放最短路径优先(OSPF)、中间系统-中间系统(IS-IS)、EIGPR(同时支持距离矢量算法和链路状态算法)</strong>等。</p><h3 id="2-3-分级路由算法"><a href="#2-3-分级路由算法" class="headerlink" title="2.3 分级路由算法"></a>2.3 分级路由算法</h3><p>前面两种自适应路由算法中，每个路由器都要保存其他路由器的一些信息，随着网络规模的增加，路由表的规模也会增大，从而使路由器不能有效的进行流量控制，分级路由算法可以解决这个问题。</p><p>在分级路由中，路由器被分成很多组，称之为区域。每个路由器都只有自己所在区域路由器的信息。使用该算法的有<strong>OSPF、IS-IS、BGP</strong>。</p><p>总的来说，在部分区域内，一般使用的是距离矢量路由算法和链路状态路由算法，而在全局网络中一般使用分级路由算法</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的拓扑结构</title>
      <link href="/2015/03/22/computer_science/Computer-Network/topology_of_network/"/>
      <url>/2015/03/22/computer_science/Computer-Network/topology_of_network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络拓扑结构是指网络中各个端点之间的逻辑结构，本文对其进行简单介绍</p><hr><a id="more"></a><h2 id="1-网络拓扑中的基本概念"><a href="#1-网络拓扑中的基本概念" class="headerlink" title="1. 网络拓扑中的基本概念"></a>1. 网络拓扑中的基本概念</h2><ol><li>节点：即一个网络端口，如PC；</li><li>结点：通常连接了多个节点，如路由器和交换机；</li><li>链路：两个节点之间的线路；</li><li>通路：两个节点之间的通信线路，可能包含多条链路。</li></ol><h2 id="2-星型拓扑结构"><a href="#2-星型拓扑结构" class="headerlink" title="2. 星型拓扑结构"></a>2. 星型拓扑结构</h2><p>目前应用最广的一种拓扑结构，各节点以交换机或集线器等设备连接在一起，其优点包括<strong>扩展方便</strong>、<strong>网速较快</strong>、<strong>易于维护</strong>，但缺点也很明显：<strong>核心交换机负载过重</strong>、<strong>通信过于依赖核心交换机</strong>等。</p><h2 id="3-环形拓扑结构"><a href="#3-环形拓扑结构" class="headerlink" title="3. 环形拓扑结构"></a>3. 环形拓扑结构</h2><p>这种网络因为传输速率低、扩展性差，已经被淘汰不用了，使用这种结构的有令牌环网。</p><h2 id="4-总线型拓扑结构"><a href="#4-总线型拓扑结构" class="headerlink" title="4. 总线型拓扑结构"></a>4. 总线型拓扑结构</h2><p>该结构中，所有设备都连接到一条总线上，和环形拓扑不同的是不形成闭环。总线型拓扑结构会在总线两端加装“终接器”的设备，主要用于与总线进行阻抗匹配，最大限度吸收传送端部的能量，避免信号反射回总线产生不必要的干扰。其优点有：<strong>结构简单</strong>、<strong>易于扩展</strong>、<strong>易于维护</strong>，缺点有：<strong>传输速率低</strong>、<strong>故障诊断苦难</strong>、<strong>难以实现大规模扩展</strong>；</p><h2 id="4-树形拓扑结构"><a href="#4-树形拓扑结构" class="headerlink" title="4. 树形拓扑结构"></a>4. 树形拓扑结构</h2><p>树根为核心交换机，叶节点为终端设备</p><h2 id="5-网状拓扑结构"><a href="#5-网状拓扑结构" class="headerlink" title="5. 网状拓扑结构"></a>5. 网状拓扑结构</h2><p>网络可靠性高、布线复杂</p><h2 id="6-混合型拓扑结构"><a href="#6-混合型拓扑结构" class="headerlink" title="6. 混合型拓扑结构"></a>6. 混合型拓扑结构</h2><p>应用广泛、维护困难</p><h2 id="7-WLAN的拓扑结构"><a href="#7-WLAN的拓扑结构" class="headerlink" title="7. WLAN的拓扑结构"></a>7. WLAN的拓扑结构</h2><ol><li>Ad-Hoc：点对点连接方式，只能单点通信，性能较差；</li><li>Infrastructure：和星型拓扑类似。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络物理层简介</title>
      <link href="/2015/03/22/computer_science/Computer-Network/physical_layer_in_network/"/>
      <url>/2015/03/22/computer_science/Computer-Network/physical_layer_in_network/</url>
      
        <content type="html"><![CDATA[<p>物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议</p><hr><a id="more"></a><h2 id="1-物理层的主要作用"><a href="#1-物理层的主要作用" class="headerlink" title="1. 物理层的主要作用"></a>1. 物理层的主要作用</h2><p>物理层有如下几个作用</p><ul><li>构建数据通路：即两个通信端之间的可以连续传输数据的物理通路</li><li>透明传输：作为物理通路的材质可能有很多，例如双绞线、光纤等，物理层需要确保数据对这些材质透明，即不管什么材质都不影响数据传输</li><li>传输数据：既然是通路其基本功能就是传输数据。物理层的<strong>基本传输单元是bit</strong></li><li>数据编码：不同传输介质所支持的数据编码可能不同，如归零码、曼彻斯特码、差分曼彻斯特码等。物理层需要确保不同编码的数据能够正常在通路上传输</li><li>数据传输管理：对比特流的数据传输流量控制、差错控制、物理线路的激活与释放等</li></ul><h2 id="2-物理层特性"><a href="#2-物理层特性" class="headerlink" title="2. 物理层特性"></a>2. 物理层特性</h2><p>物理层需要规范其接口的特性，有了统一的标准，不同的厂商能够以相同的标准来实现彼此产品的互联</p><ol><li>机械特性：定义了传输介质接线器、物理接口的形状和尺寸、引线数目和排列顺序以及连接器与接口之间的固定和锁定装置</li><li>电气特性：规定了在通路上传输比特流时线路上信号电压的高低、阻抗匹配情况，以及传输速率和传输距离限制等参数属性，主要分为三类：<ul><li>非平衡型</li><li>差分接收器的非平衡型</li><li>平衡型</li></ul></li><li>功能特性：指传输介质中各条线上所出现的某一电平的含义，以及物理接口各条信号线的用途，包括：接口信号线的功能规定，接口信号线的功能分类。</li><li>规程特性：利用接口传输比特流的全过程以及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时，DTE/DEC双方在各自电路上的动作顺序。</li></ol><h2 id="3-物理层传输介质"><a href="#3-物理层传输介质" class="headerlink" title="3. 物理层传输介质"></a>3. 物理层传输介质</h2><ol><li>导向性传输介质<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul></li><li>非导向性传输介质<ul><li>短波无线传输</li><li>地面微波接力通信</li><li>卫星通信</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁问题</title>
      <link href="/2015/03/16/computer_science/Operating-System/deadlock/"/>
      <url>/2015/03/16/computer_science/Operating-System/deadlock/</url>
      
        <content type="html"><![CDATA[<p>关于死锁的一些归纳和总结</p><hr><a id="more"></a><h2 id="1-死锁产生的原因和必要条件"><a href="#1-死锁产生的原因和必要条件" class="headerlink" title="1. 死锁产生的原因和必要条件"></a>1. 死锁产生的原因和必要条件</h2><p>进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。</p><ol><li>可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。</li><li>不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。</li></ol><p>因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点：</p><ol><li>系统资源不足。这是<strong>根本原因</strong>，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时；</li><li>进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。</li></ol><p>对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4：</p><ol><li>互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用；</li><li>请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源；</li><li>不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占；</li><li>循环等待。若干个进程形成循环等待链。</li></ol><h2 id="2-死锁的预防"><a href="#2-死锁的预防" class="headerlink" title="2. 死锁的预防"></a>2. 死锁的预防</h2><p>通过破坏死锁的必要条件来控制死锁的策略称为<strong>死锁预防</strong>，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。</p><ol><li>破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的<strong>优点是安全简单易实现</strong>，<strong>缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源</strong>。</li><li>破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。<strong>缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”</strong>。</li><li>破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。<strong>缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高</strong>。</li></ol><h2 id="3-死锁的避免"><a href="#3-死锁的避免" class="headerlink" title="3. 死锁的避免"></a>3. 死锁的避免</h2><p>与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的<strong>前提是每个进程清除自己需要多少资源</strong>，因此死锁避免还是有局限性的。</p><ol><li>系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全；</li><li>银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。</li></ol><h2 id="4-银行家算法"><a href="#4-银行家算法" class="headerlink" title="4. 银行家算法"></a>4. 银行家算法</h2><p>银行家算法有5种数据结构：</p><ol><li>系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲；</li><li>最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k；</li><li>分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数；</li><li>需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源；</li><li>请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。</li></ol><p>当某个进程i对j类资源提出k个请求是，需要<strong>按照下列步骤检查</strong>：</p><ol><li>若$Request[j]&lt;=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错；</li><li>若$Request[j]&lt;=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i；</li><li>系统进行试探性分配，并修改相应的表：<ul><li>Available[j] -= Request[j];</li><li>Allocation[i][j] += Request[j];</li><li>Need[i][j] -= Request[j];</li></ul></li><li>调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。</li></ol><p><strong>判断当前状态是否安全</strong></p><p>添加两个数组：</p><ul><li>Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa；</li><li>Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。</li></ul><p>检查当前状态的完整过程如下：</p><ol><li>初始化Work和Finish。Work[j]=Available[j], Finish[i]=false;</li><li>在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4:<ul><li>Finish[h] = false;</li><li>Need[h][j] &lt;= Work[j]</li></ul></li><li>由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2</li><li>若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。</li></ol><h2 id="5-死锁检测"><a href="#5-死锁检测" class="headerlink" title="5. 死锁检测"></a>5. 死锁检测</h2><h2 id="6-死锁解除"><a href="#6-死锁解除" class="headerlink" title="6. 死锁解除"></a>6. 死锁解除</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deadlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的分类</title>
      <link href="/2015/03/15/computer_science/Computer-Network/classify_in_network/"/>
      <url>/2015/03/15/computer_science/Computer-Network/classify_in_network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络分类</p><hr><a id="more"></a><h2 id="1-按覆盖范围分"><a href="#1-按覆盖范围分" class="headerlink" title="1. 按覆盖范围分"></a>1. 按覆盖范围分</h2><ol><li>局域网LAN：LAN是将一个较小的区域内的各种通信设备连接在一起组成的网络，最常见、最常应用的网络。LAN具有以下特点：<ul><li>私有服务：LAN用于私用，例如校园网和企业网</li><li>分布范围小</li><li>结构简单、布线容易</li><li>网速较快，误码率低</li></ul></li><li>城域网MAN：通常用于为一个城市范围提供服务</li><li>广域网WAN：分布范围最大，可以遍布一个国家甚至全球，特点有：<ul><li>覆盖范围广</li><li>构建成本高</li><li>网络结构和类型复杂：可以连接多种不同的网络类型</li><li>传输速率低，误码率高</li></ul></li></ol><h2 id="2-按网络管理模式分"><a href="#2-按网络管理模式分" class="headerlink" title="2. 按网络管理模式分"></a>2. 按网络管理模式分</h2><ol><li>对等网：即网络中的各成员地位相等。这种网络配置简单，适合家庭、校园和小型办公室用户，但其缺点也很明显，例如<strong>管理困难</strong>、<strong>安全性差</strong>、<strong>成本高</strong>、<strong>性能差</strong>等；</li><li>C/S网：客户/服务器网，其特点是<strong>易于管理</strong>、<strong>安全性高</strong>、<strong>性能好</strong>。</li></ol><h2 id="3-按传输方式分"><a href="#3-按传输方式分" class="headerlink" title="3. 按传输方式分"></a>3. 按传输方式分</h2><ol><li>点对点传输网络：该网络中数据是以点对点的方式传输的，因此这类网络采用基于点对点的通信协议，如点对点协议PPP、基于以太网的点对点协议PPPOE等。</li><li>广播式传输网络：该网络中任一节点都可以通过公用信道传输数据到其他节点上，其他节点通过匹配数据地址来判断是否接收。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程与协程之间的区别与联系</title>
      <link href="/2015/03/12/computer_science/Operating-System/process_and_thread_coroutines/"/>
      <url>/2015/03/12/computer_science/Operating-System/process_and_thread_coroutines/</url>
      
        <content type="html"><![CDATA[<p>进程、线程与协程之间的区别与联系</p><hr><a id="more"></a><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h2><p>进程是程序的动态执行。保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），<strong>进程是资源分配的最小单位</strong>。一块CPU在某一时刻只能运行一个进程，多进程是通过进程调度抢占CPU来实现的。</p><p><strong>进程间的通信方式</strong></p><p>无名管道(Pipe)、有名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存(Shared Memory)、套接字(Socket)。</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><p>线程也被称为轻量级进程(Lightweight Process，LWP)，是操作系统调度(CPU调度)执行的最小单位。</p><h3 id="2-1-线程与进程的区别与联系"><a href="#2-1-线程与进程的区别与联系" class="headerlink" title="2.1 线程与进程的区别与联系"></a>2.1 线程与进程的区别与联系</h3><p><strong>联系</strong></p><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li><li>处理机分给线程，即真正在处理机上运行的是线程；</li><li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li></ol><p><strong>区别</strong></p><ol><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属进程的资源。进程维护的是程序所包含的资源(静态资源)，如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等；线程所维护的运行相关的资源(动态资源)，如：运行栈、调度相关的控制信息、待处理的信号集等；</li><li>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致创建进程的系统开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li></ol><h2 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h2><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总有一个入口，一次返回，并且调用顺序是明确的。而协程的调用和子程序不同，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p><strong>协程的优点</strong></p><ol><li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li><li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间的通信方式</title>
      <link href="/2015/03/09/computer_science/Operating-System/communication_of_process/"/>
      <url>/2015/03/09/computer_science/Operating-System/communication_of_process/</url>
      
        <content type="html"><![CDATA[<p>同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。</p><hr><a id="more"></a><h2 id="1-进程通信的概念"><a href="#1-进程通信的概念" class="headerlink" title="1. 进程通信的概念"></a>1. 进程通信的概念</h2><p>进程的特征之一是其具有独立性，一个进程不能访问另一个进程的程序或者数据，以保证进程之间不会相互干扰，但这样也造成了进程间无法直接交换数据。</p><p>一般而言，进程通过两种方案来实现进程间的通信</p><ol><li>发送、接受双方通过磁盘等外设交换数据。这种通信方式需要I/O操作的支持。</li><li>利用内核运行在内核态的特点，通过对内核空间读写来交换数据。这种通信方式是在内存中完成的。</li></ol><p>根据进程通信交换信息量的大小，可以将进程通信分为两种：</p><ol><li>低级通信。进程之间一次只传输少量数据，速度快，效率低，通信过程对用户不透明。这类通信主要用于互斥与同步的工具，P、V原语是低级通信原语</li><li>高级通信。一次可以传输大量信息，效率高，对用户透明，编程简单。高级通信又分为三种：<ul><li>共享内存通信方式：利用共享内存通信；</li><li>消息传递通信方式：利用OS提供的消息系统通信；</li><li>共享文件通信方式：又被称为管道通信。</li></ul></li></ol><p>高级通信方式既适用于集中式操作系统，又适用于分布式操作系统。</p><h2 id="2-共享内存通信方式"><a href="#2-共享内存通信方式" class="headerlink" title="2. 共享内存通信方式"></a>2. 共享内存通信方式</h2><p>共享内存是指在内存中划出一块区域作为数据共享区，称为共享内存分区，<strong>通信双方将自己的虚拟地址空间映射到共享内存分区上</strong>。通信时通过对该分区读写实现通信。该方式是进程间最快捷、最有效的通信方式，Unix、Windows和OSX都采用了这种通信方式。</p><h2 id="3-消息缓冲-消息队列-通信方式"><a href="#3-消息缓冲-消息队列-通信方式" class="headerlink" title="3. 消息缓冲(消息队列)通信方式"></a>3. 消息缓冲(消息队列)通信方式</h2><p>消息缓冲属于<strong>直接通信</strong>方式，该方法中，发送进程直接发送原语到接收进程的消息队列，而接受进程使用接受原语从消息队列中取出信息，进程间以<strong>消息</strong>为单位进行信息交换。该方法与生产者-消费者问题类似。该方式与共享内存有点相似，该方法<strong>使用内存中的公用消息缓冲区来传递消息</strong>。</p><h2 id="4-信箱通信方式"><a href="#4-信箱通信方式" class="headerlink" title="4. 信箱通信方式"></a>4. 信箱通信方式</h2><p>该方式是<strong>间接通信</strong>方式，通信双方通过一种叫<strong>信箱</strong>的共享数据结构来进行交互。该方法和消息队列没什么区别，也是在内存中设置一种特殊的数据结构。</p><h2 id="5-管道通信方式"><a href="#5-管道通信方式" class="headerlink" title="5. 管道通信方式"></a>5. 管道通信方式</h2><p>所谓的<strong>管道就是一种共享通信文件</strong>，也称为pipe文件，专门用于进程间通信。管道有三个特点：</p><ol><li>管道专门用于特性</li><li>管道只能<strong>单向传送数据</strong></li><li>管道对用户透明</li></ol><p>管道分为两种：</p><ol><li>无名管道。无名管道是利用系统调用pipe建立起来的无路径名的无名文件，并且是一个临时文件，该文件物理上由文件系统的高速缓冲区构成，且很少启动外部设备。当进程不再需要无名管道时，系统关闭并回收与它相关联的索引节点。此外，通过文件系统看不到无名管道的存在。</li><li>有名管道。有名管道是一个有目录和索引的长期存在的真实文件，不能与文件系统中的任何文件重名，且在文件系统中能看到该有名管道。</li></ol><h2 id="6-信号量"><a href="#6-信号量" class="headerlink" title="6. 信号量"></a>6. 信号量</h2><h2 id="7-套接字"><a href="#7-套接字" class="headerlink" title="7. 套接字"></a>7. 套接字</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中的数制与编码</title>
      <link href="/2015/03/08/computer_science/Computer-Basic/number_system_and_coding_in_network/"/>
      <url>/2015/03/08/computer_science/Computer-Basic/number_system_and_coding_in_network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络中的进制与编码</p><hr><a id="more"></a><h2 id="1-常见进制"><a href="#1-常见进制" class="headerlink" title="1. 常见进制"></a>1. 常见进制</h2><p>计算机是二进制的世界，及其只能识别01串，但是为了人类理解方便，还是制定了多种进制，例如:</p><ul><li><strong>十进制</strong>：十进制数的标志为D，例如(123)D</li><li><strong>二进制</strong>：二进制的标识为B，例如(101)B</li><li><strong>八进制</strong>：标识为字母O，在C/C++中八进制数前需要加数字0，如0123位八进制数</li><li><strong>十六进制</strong>：标识为H，C/C++中十六进制数以0x开头</li><li><strong>十二进制</strong>：时钟用到的进制</li><li><strong>六十进制</strong>：分钟与秒钟用到的进制</li></ul><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><ul><li><strong>非十进制转换成十进制</strong>：按位的幂的累加和，例如$(11010)<em>2 = 1<em>2^4 + 1</em>2^3 + 0<em>2^2 + 1</em>2^1 + 0*2^0 = (26)</em>{10}$</li><li><strong>十进制转换成非十进制</strong>：整数使用除基取余法，小数使用乘基正序取整法(即每次乘基后，取大于1的部分整数)</li><li><strong>非十进制与非十进制之间的转换</strong>：可以利用二进制作为中介</li></ul><h2 id="3-计算机中二进制数的表示"><a href="#3-计算机中二进制数的表示" class="headerlink" title="3. 计算机中二进制数的表示"></a>3. 计算机中二进制数的表示</h2><p>计算机中二进制采用的表示形式为补码。<br>计算机中的字长是指计算机一次可以处理的二进制数的长度。</p><ul><li>原码：最高位用于表示数的正负。这种表示的缺陷是<strong>对异号加减操作不便</strong>，与此同时<strong>0有+0和-0两种不同的表示</strong>，存在二义性。故计算机不采用这种表示形式</li><li>补码：正数补码与原码相同，负数的补码为原码除符号位外按位取反，再将末位加1得到。补码的优点是运算时可以将符号位一起运算，且0只有一种表示形式</li><li>反码：正数反码与源码相同，负数为除符号位外按位取反。反码是原码和补码的中间过渡形式。</li><li>移码：补码的符号位取反即是移码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的基本概念</title>
      <link href="/2015/03/07/computer_science/Operating-System/process/"/>
      <url>/2015/03/07/computer_science/Operating-System/process/</url>
      
        <content type="html"><![CDATA[<p>为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。</p><hr><a id="more"></a><h2 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1. 进程的概念"></a>1. 进程的概念</h2><h3 id="1-1-程序的顺序执行"><a href="#1-1-程序的顺序执行" class="headerlink" title="1.1 程序的顺序执行"></a>1.1 程序的顺序执行</h3><p>在计算机中常使用程序这个概念，<strong>程序是一个在时间上严格按先后次序操作实现算法功能的指令序列</strong>，程序本身是静态的，是指令编译出的结果。在单道程序设计环境中，程序总是顺序执行的，若有多个程序，则各个程序试一次呗调入内存的。程序的顺行执行有以下三个特点：</p><ol><li>顺序性。CPU严格按照程序规定的顺序(即指令顺序)执行程序的操作，每个操作都必须在前一个操作结束后才能执行；</li><li>封闭性。程序一旦开始执行，其结果仅由初始条件和程序本身操作决定，不受外界因素影响；</li><li>可再现性。当初始条件相同，程序的运行结果也相同。</li></ol><p>单道程序的顺序性、封闭性和可再现性给程序的编制、调试带来了便利，但是资源利用率底。</p><h3 id="1-2-程序的并发执行"><a href="#1-2-程序的并发执行" class="headerlink" title="1.2 程序的并发执行"></a>1.2 程序的并发执行</h3><h3 id="1-3-进程"><a href="#1-3-进程" class="headerlink" title="1.3 进程"></a>1.3 进程</h3><h4 id="1-3-1-进程的定义"><a href="#1-3-1-进程的定义" class="headerlink" title="1.3.1. 进程的定义"></a>1.3.1. 进程的定义</h4><p>单道程序环境下，程序与CPU执行的活动是一致的。多道环境下，并发破坏了程序的封闭性和可再现性，程序与CPU执行的活动不再一一对应。<strong>程序是完成某一特定功能的指令序列，是一个静态过程</strong>，而CPU执行的活动是一个动态的过程。因此20世纪60年代Dijkstra引入了进程的概念。他给出的进程定义是：<strong>行为的规则称为程序，程序在CPU上执行时的活动称为进程</strong>。</p><h4 id="1-3-2-进程的结构"><a href="#1-3-2-进程的结构" class="headerlink" title="1.3.2. 进程的结构"></a>1.3.2. 进程的结构</h4><p>通常程序是不能并发执行的，<strong>为了使程序及它所要使用的资源能独立运行，OS为程序配置了一个特殊的数据结构进程控制块PCB(Process Control Block)</strong>，PCB用来存储程序向前执行过程中所要记录的有关运行信息，即该进程动态之行的相关资料。因此：</p><center>进程实体 = 程序段 + 相关数据段 + PCB</center><h4 id="1-3-3-进程的特征"><a href="#1-3-3-进程的特征" class="headerlink" title="1.3.3. 进程的特征"></a>1.3.3. 进程的特征</h4><p>进程作为OS的一个实体有以下5个特征。</p><ol><li>动态性。进程是程序的一次执行，因此进程是动态的，具有生命期。</li><li>并发性。多个进程实体在一段时间内能够并发执行，从而提高系统资源利用率。</li><li>独立性。每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位。</li><li>异步性。各进程按各自独立的、不可预知的速度向前推进。对单CPU系统而言，任何时刻只能有一个进程占用CPU。</li><li>结构性。每个进程的结构都由程序段、数据段和PCB组成。</li></ol><h4 id="1-3-4-进程和程序的区别"><a href="#1-3-4-进程和程序的区别" class="headerlink" title="1.3.4. 进程和程序的区别"></a>1.3.4. 进程和程序的区别</h4><ol><li>程序是指令的有序集合，是静态的；Process是程序在CPU上的一次执行，是动态的；</li><li>程序作为软件可以长期保存；Process有自己的生命周期；</li><li>程序不会占有和调度资源；Process会为其分配和调度资源；</li><li>进程与程序之间无一一对应关系，一个程序可以多次执行产生多个进程，不同进程也可以包含同一个程序；</li><li>程序是记录在存储介质上的指令有序集合；进程则由程序段、数据段、PCB组成。</li></ol><h2 id="2-进程的状态及转换"><a href="#2-进程的状态及转换" class="headerlink" title="2. 进程的状态及转换"></a>2. 进程的状态及转换</h2><h3 id="2-1-5状态进程模型"><a href="#2-1-5状态进程模型" class="headerlink" title="2.1. 5状态进程模型"></a>2.1. 5状态进程模型</h3><p>进程有5个状态：创建、就绪、运行、阻塞、终止，下面对其一一说明。</p><ol><li>进程的创建。通常有4件事会导致新进程的产生：<ul><li>在一个批处理环境中，为了响应一个任务的要求而产生进程；</li><li>在一个交互式环境中，当一个新用户企图登录时会产生进程；</li><li>操作系统代替用户程序产生进程；</li><li>由用户程序产生进程。通常进程都是由操作系统产生的，但是一个进程也可以产生另一个进程，分别称为父进程和子进程。</li></ul></li><li>进程的终止。当一个进程执行到自然结束点，或因不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程进入终止态。处于终止态的进程不能被再次调度执行，与其相关的数据信息由OS临时保存，随后OS逐步释放为其分配的资源，最后释放PCB。</li><li>进程的就绪。进程获得了除CPU之外的所需资源，一旦得到CPU就可运行。就绪状态的进程会组成就绪队列。</li><li>进程的运行。进程获得了CPU和其他资源，正在CPU上运行时的状态。</li><li>进程的阻塞。进程运行中发生了某种等待事件(如I/O操作)而暂时不能运行的状态，此状态的进程不能竞争CPU，而需要等事件完成后转到就绪态才能竞争。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction To Computer</title>
      <link href="/2014/02/23/computer_science/Computer-Basic/introduction/"/>
      <url>/2014/02/23/computer_science/Computer-Basic/introduction/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/30823911/" target="_blank" rel="noopener">《计算机组装与维修技术》</a>阅读笔记</p><a id="more"></a><hr><h2 id="1-计算机及其组成"><a href="#1-计算机及其组成" class="headerlink" title="1.计算机及其组成"></a>1.计算机及其组成</h2><h3 id="什么是计算机"><a href="#什么是计算机" class="headerlink" title="什么是计算机"></a>什么是计算机</h3><p>计算机全称电子计算机，俗称电脑、PC等，是一种用于计算的机器，其种类繁多，包括个人计算机、高性能计算机、服务器等。</p><h3 id="计算机的组成"><a href="#计算机的组成" class="headerlink" title="计算机的组成"></a>计算机的组成</h3><p>一个完整的可正常工作的计算机包括硬件和软件两个部分：</p><h4 id="1-计算机硬件"><a href="#1-计算机硬件" class="headerlink" title="1. 计算机硬件"></a>1. 计算机硬件</h4><p>硬件是指组成计算机的实体部件，从外观上来看硬件包括：主机、显示器、键盘、鼠标、音响、打印机、扫描仪等，其中主机使整个计算机最重要的组件，一般的，主机都包括:</p><ul><li>CPU：Central Processing Uint，计算机核心的核心，目前CPU的生产厂商有Intel和AMD两家公司，市场占比大约82开</li><li>主板：承担着操控和协调CPU、声卡、显卡等部件的任务</li><li>显卡</li><li>风扇</li><li>电源</li><li>网卡</li><li>声卡</li></ul><h4 id="2-计算机软件"><a href="#2-计算机软件" class="headerlink" title="2. 计算机软件"></a>2. 计算机软件</h4><p>软件是指在硬件上运行的各种程序，例如聊天软件、游戏软件，其中操作系统也是软件的一种，例如Unbuntu、Windows等</p><hr><h2 id="2-CPU"><a href="#2-CPU" class="headerlink" title="2. CPU"></a>2. CPU</h2><p>CPU作为计算机的核心，其性能指标包括以下几种：</p><ol><li><strong>主频</strong>：即CPU的时钟频率，单位为MHz或GHz，标示CPU的运算速度，CPU的主频=外频x倍频</li><li><strong>外频</strong>：CPU的总线频率，是由主板为CPU提供的基准时钟频率，单位为MHz，外频决定了主板的运行速度。通常我们在台机中所说的超频，就是指超CPU的外频，大部分CPU外频和主板频率是同步运行的，如果改变外频可能会导致系统不稳定</li><li><strong>倍频</strong>：CPU主频和外频之间的倍率，一般情况下CPU的倍频是锁定的，有的CPU可以调节倍频</li><li><strong>前端总线频率</strong>：也称FSB带宽，是CPU与内存间的数据交换的速率，一般数据带宽=(总线频率x数据位宽)/8</li><li><strong>缓存</strong>：由于CPU和内存处理数据速度不一致，因而引入了缓存，一般而言CPU中有2～3级缓存，L1 Cache是一级缓存，由SRAM组成</li></ol><hr><h2 id="3-主板"><a href="#3-主板" class="headerlink" title="3. 主板"></a>3. 主板</h2><p>主板是一块印刷电路板PCB，一般采用4或6层板，4层板包括主板信号层、接地层、电源层、次信号层，6层板多了辅助电源层和中信号层，6层的抗电磁干扰能力更强。<br>一般主板有如下几个组件：</p><ol><li><strong>芯片组</strong>：芯片组主要由BIOS芯片、南北桥芯片、磁盘阵列RAID、控制芯片等组成<ul><li><strong>BIOS芯片</strong>：BIOS芯片是一块方块型的存储器，里面存有与该主板搭配的基本输入输出系统程序，改程序能够让主板识别各种硬件，以及设置引导系统、调整CPU外频等，BIOS芯片是可写入的。</li><li><strong>南北桥</strong>：横跨AGP插槽左右两侧的两块芯片就是南北桥芯片。南桥芯片多位于PCI插槽的上方；而CPU插槽旁边，被散热片盖住的则是北桥芯片，一般而言主板的命名都是以北桥的核心名称命名的。北桥芯片主要负责处理CPU、内存、显卡三者之间的交互；南桥负责硬盘等存储设备和PCI之间的数据流通。南北桥合称芯片组。现代的一些高端主机会将南北桥芯片封装到一起。</li><li><strong>RAID</strong>：控制芯片</li></ul></li><li>总线：总线是主板的重要组成部分，各个部件通过插槽连接到总线上，通常包括：CPU插槽、内存插槽、AGP插槽(用于插AGP显卡，目前逐渐被PCI Express插槽取缔)、PCI插槽(插声卡、网卡等)、CNR插槽(插CNR接口的软Modem或网卡)</li><li>对外接口：硬盘接口(一般都是SATA接口)、软驱接口、COM接口(连接串行鼠标和外置Modem等)、PS/2接口(仅用于连接键鼠，目前逐渐被USB接口取代)、USB接口、LPT接口(连接打印机或扫描仪)、MIDI接口(声卡和游戏杆，目前逐渐淘汰)。</li></ol><hr><h2 id="4-内存"><a href="#4-内存" class="headerlink" title="4. 内存"></a>4. 内存</h2><p>内存是有内存芯片、电路板、金手指(即内存条边缘的一排金黄色导电触片)等组成，当计算机运行时，CPU就会把运行所需的数据从硬盘中调到内存中，运算完成后再传出，目前市面上流行的内存类型为DDR3和DDR4，DDR即双倍速率同步动态随机存储器Double Data Rate Synchronous Dynamic Random Access Memory的简称，DDR在每个时钟的上升沿和下降沿各传输一次数据</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>内存主频</strong>：内存的运行速度</li><li>内存容量</li><li>CAS延迟：内存读写数据所需的时延</li></ul><hr><h2 id="5-显卡"><a href="#5-显卡" class="headerlink" title="5. 显卡"></a>5. 显卡</h2><p>显卡即显示接口卡、显示适配器、显示器配置卡，承担输出图形显示的重要任务。由于显卡的特性，它特别适合处理矩阵运算，因此显卡在现代机器学习中扮演了重要的角色。在机器学习中通常会有大量的矩阵操作，所以可以将这部分操作送给显卡中的GPU去操作。显卡一般分为两种</p><ul><li><strong>集成显卡</strong>：即芯片组中集成了显卡，这样的芯片组也称为整合型芯片，集显一般没有显存，而是使用内存作为其显存，因此其性能和独显相比较差</li><li><strong>独立显卡</strong>：显卡成独立的板卡，通常有自己的显存</li></ul><p>显卡的基本结构如下：</p><ul><li><strong>GPU</strong>:图形处理芯片</li><li><strong>显存</strong></li><li><strong>显卡BIOS</strong>:驱动程序之间的控制程序,存有显卡的型号、规格、生产厂家及出场时间等</li><li>输出接口</li><li>显卡PCB板</li></ul><h3 id="性能指标-1"><a href="#性能指标-1" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>显卡频率</strong>：显卡的工作频率，通常越高越好</li><li><strong>显存位宽</strong>：一个时钟周期内所能传送数据的位数，市场上主流的有128位、256位、320位等</li><li>显存在显卡上工作时的频率</li><li>显存容量：主流的是256MB和512MB</li><li>3D API：显卡与应用程序之间的接口</li></ul><hr><h2 id="6-声卡"><a href="#6-声卡" class="headerlink" title="6. 声卡"></a>6. 声卡</h2><p>声卡是实现模拟信号/数字信号相互转换的一种硬件，一般分为板卡式(目前已被淘汰)、集成式(主流)和外置式三种，声卡的基本构成有：</p><ul><li><strong>声音控制芯片</strong>：可通过数模转换器将模拟信号转换成数字信号，或反过来</li><li><strong>DSP</strong>：执行和声音处理有关的命令、执行压缩解压缩程序、增加特殊声效和传真Modem等，高档声卡一般配有DSP</li><li><strong>CODEC</strong>：编解码器</li><li>输入输出接口</li><li>跳线：用于设置声卡的硬件设备，包括CD-ROM的I/O地址、声卡的I/O地址设置。</li></ul><h3 id="性能指标-2"><a href="#性能指标-2" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>采样频率</strong>：每秒从连续信号中采样出离散信号的个数，单位Hz。通俗地讲是指计算机美妙采集多少个声音样本</li><li><strong>采样位数</strong>：即采样值或取样值，用来衡量声音波动变化的参数，含义是声卡在采集和播放声音文件时所使用数字声音信号的二进制位数</li><li><strong>信噪比SNR</strong>：放大器的输出信号的电压与同时输出的噪声电压的比例，单位分贝，一般信噪比越高，说明信号李的噪声越小，声音质量越高</li><li>频率响应：系统或计量传感器的阻抗随频率的变化</li></ul><hr><h2 id="7-硬盘"><a href="#7-硬盘" class="headerlink" title="7. 硬盘"></a>7. 硬盘</h2><p>硬盘是计算机中的存储器件，一般的机械硬盘由一个或多个铝制或玻璃制的碟片组成，碟片外覆盖有铁磁性材料。传统的机械硬盘其内部构造包括：</p><ul><li>磁头：负责对磁盘进行读写，与磁盘表面的磁性物质发生作用，一般有MR磁头和GMR磁头，硬盘里的磁头数=磁盘盘体数x2</li><li>盘体：存储数据的主体，有一或多个盘片叠在一起组成，盘体有以下几个概念：<ul><li><strong>磁道</strong>：一个盘片的一个面上的一个同心圆成为一个磁道，一般内侧磁道和外侧磁道存储量不同</li><li><strong>扇区</strong>：每个磁道都被分为若干个弧段，这些弧段就是扇区，每个扇区可以存放512字节的信息，磁盘读写数据以扇区为单位</li><li><strong>柱面</strong>：每个盘面上相同位置的磁道组成一个柱面，<strong>硬盘容量=柱面数x磁头数x扇区数x512B</strong></li></ul></li><li>主轴电机：用于驱动盘体转动的设备，主流的为7200转/分钟</li><li>寻道电机、驱动臂：寻道电机带动磁头在盘体上寻道，驱动臂把磁头和寻道电机连接在一起</li></ul><h3 id="性能指标-3"><a href="#性能指标-3" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>容量</li><li><strong>转速</strong>：单位为转/分钟或RPM，转的越快，其传输率越高，发热量越大</li><li><strong>平均访问时间</strong>：磁头从起始位置找到需要读写的数据位置的时间，体现了硬盘的读写速度。一般包括了平均寻道时间和平均等待时间，平均寻道时间是指磁头移动到指定磁道所需的时间，平均等待时间磁头已经在目标磁道，等待所需访问的扇区转至磁头下方所需时间</li><li><strong>传输速率</strong>：包括内部传输速率和外部传输速率，内部传输速率指未用硬盘缓冲区时的性能，外部传输速率是系统总线与硬盘缓冲区之间的传输速率</li><li><strong>缓存</strong>：硬盘也有缓存，是硬盘控制器上的一块内存芯片</li></ul><p>固态硬盘SSD是一种新型的硬盘，由固态电子存储芯片阵列组成，其存储介质一般有闪存(FLASH)和DRAM两种，和传统硬盘比，SSD有读写速度快、低功耗、无噪声、体积小等优点，也有造价高、使用寿命短的缺点。关于SSD的使用寿命，也就是SSD擦写次数限制，闪存完全擦写一次叫做一次P/E，因此闪存的寿命以P/E为单位，一般34nm的闪存寿命为5000P/E，25nm的为3000P/E。不过由于SSD固件算法升级，SSD能提供更少的不必要写入量。 举个例子，一款128G的SSD，要写入128G的文件才算做一次P/E，即使每天写入50G的内容，2.5天才能完成一次P/E，一年也才用去150次左右的P/E，一块3000P/E的SSD够用200年了。</p><hr><h2 id="8-BIOS和CMOS"><a href="#8-BIOS和CMOS" class="headerlink" title="8. BIOS和CMOS"></a>8. BIOS和CMOS</h2><p>BIOS是基本输入输出系统。启动计算机时，CPU首先根据集成在主板、显卡等设备上的BIOS芯片来核对每个基础设备是否正常，然后从硬盘中拷贝操作系统到内存中。BIOS有3个基本功能：</p><ul><li>自检及初始化：开机后BIOS最先被启动，然后BIOS会检查计算机硬件设备，若设备正常才会启动操作系统</li><li>程序服务：BIOS直接与计算机的I/O设备交互，实现软件程序对硬件的直接操作</li><li>设定中断</li></ul><p>CMOS是指互补金属氧化物半导体，是计算机主板上的一块可读写的RAM芯片，用来保存当前系统的硬件配置和用户对某些参数的设定。CMOS由主板的可充电电池供电，即使系统断电CMOS中的信息也不会丢失。 通常计算机中的开机密码存储在CMOS中，当忘记密码时，可以抠下主板上的电池，将CMOS放电，放电后CMOS内容会被清空，因而密码也会被清除。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
