{"meta":{"title":"柴","subtitle":null,"description":null,"author":null,"url":"http://w4ow.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-06-13T10:15:30.163Z","updated":"2021-06-13T10:15:30.163Z","comments":true,"path":"404.html","permalink":"http://w4ow.github.io/404.html","excerpt":"","text":"这里是知识的荒漠"},{"title":"ALL CATEGORIES","date":"2020-09-02T02:17:43.837Z","updated":"2019-06-28T15:35:37.000Z","comments":true,"path":"categories/index.html","permalink":"http://w4ow.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-02T02:17:43.840Z","updated":"2019-06-28T15:23:09.000Z","comments":true,"path":"mylist/index.html","permalink":"http://w4ow.github.io/mylist/index.html","excerpt":"","text":""},{"title":"ALL TAGS","date":"2020-09-02T02:17:43.843Z","updated":"2019-06-28T15:35:48.000Z","comments":true,"path":"tags/index.html","permalink":"http://w4ow.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机数学课程","slug":"CS/Lecture/Computer_Math","date":"2022-02-27T08:43:17.113Z","updated":"2022-02-27T09:02:21.552Z","comments":true,"path":"2022/02/27/CS/Lecture/Computer_Math/","link":"","permalink":"http://w4ow.github.io/2022/02/27/CS/Lecture/Computer_Math/","excerpt":"考核分数构成： 作业35%，六次 出勤5%，提问/签到3~4次 其中30%，暂定04-14下午 期末30%，开卷，2~2.5H","text":"考核分数构成： 作业35%，六次 出勤5%，提问/签到3~4次 其中30%，暂定04-14下午 期末30%，开卷，2~2.5H Lec 1 汉诺塔问题：通过求解问题的上下界来确定问题的解 平面分割问题 约瑟夫环问题","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"图表示与表征学习","slug":"Deep_Learning/Graph_neural_network/Representation_learning","date":"2022-02-27T08:41:22.989Z","updated":"2022-02-27T08:41:22.989Z","comments":true,"path":"2022/02/27/Deep_Learning/Graph_neural_network/Representation_learning/","link":"","permalink":"http://w4ow.github.io/2022/02/27/Deep_Learning/Graph_neural_network/Representation_learning/","excerpt":"图表征学习的目的是将图结点低维表示的同时，尽可能有效的保留图的结构。图表征学习起源于表征学习，我们将对其进行回顾，并全面介绍图表征学习的传统方法与现代方法。","text":"图表征学习的目的是将图结点低维表示的同时，尽可能有效的保留图的结构。图表征学习起源于表征学习，我们将对其进行回顾，并全面介绍图表征学习的传统方法与现代方法。 1. 表征学习及其应用机器学习模型的有效性在很大程度上依赖于数据的良好的特征表示，而表征学习的目的就是学习数据的特征，使得模型在使用这些数据时更容易提取有用的信息。在传统上，特征提取工作通常作为预处理的一部分由人类基于先验知识来完成，这也称为特征工程。基于人工的方法其缺点十分明显：1) 需要领域专家的密集劳动；2) 特征提取很难做到充分且无偏见(极大程度上受专家个人经验的影响)。这些传统方法(PCA、GMRF、LPP等)通常更倾向于对数据进行转换，使数据更容易被模型所学习，因此它们并没有真正的对数据特征进行学习。目前主流的深度学习任务都与表征学习有关： 图像处理：图像搜索、面部识别、目标检测等，主要学习的特征是图片像素和图片语义之间的关系。近年来基于监督学习的深度学习模型(CNN、DBN、VGG、ResNet等)在CV领域大获成功。而在无监督学习方面，表征学习可以通过学习视觉特征帮助人们为数据打标签。此外，表征学习在迁移学习和强化学习等任务中也有所涉及。 语音识别：现代的语音系统(Siri、Cortana)已经融入到人们的生活当中，研究人员使用表征学习来学习说话者的特征，例如音色、音调等，从而进行如语音识别、情感分析等任务 自然语言处理：单词分割、主语识别、关系提取等在NLP中都是十分重要但很有难度的任务，在传统方法中，这些工作都是需要经验丰富的专家来完成。 网络分析：图嵌入等 2. 图表征学习图作为一种自然的数据结构，其应用价值不言而喻。处理图数据所要面对的第一个问题就是如何更有效的表示图。传统的图表示方法主要有三个缺点： 计算复杂性高：大多数算法都要迭代图的边集来实现算法目的，这一成本较高 并行性低：","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Deep Learning","slug":"Computer-Science/Deep-Learning","permalink":"http://w4ow.github.io/categories/Computer-Science/Deep-Learning/"}],"tags":[{"name":"GNN","slug":"GNN","permalink":"http://w4ow.github.io/tags/GNN/"}]},{"title":"HEXO的使用","slug":"CS/Tools/Hexo_manual","date":"2022-02-27T08:41:22.985Z","updated":"2022-02-27T08:41:22.986Z","comments":true,"path":"2022/02/27/CS/Tools/Hexo_manual/","link":"","permalink":"http://w4ow.github.io/2022/02/27/CS/Tools/Hexo_manual/","excerpt":"HEXO是一个基于Markdown的静态网页博客生成框架，本文简单介绍其使用方法以及多设备迁移部署。","text":"HEXO是一个基于Markdown的静态网页博客生成框架，本文简单介绍其使用方法以及多设备迁移部署。 1. 基础设置1.1 HEXO目录文件简介. ├── _config.yml # 全局配置文件├── package.json├── source│ ├── …│ └── _posts # 博客文件(md)放于此处└── themes # 主题 ├── … └── your_theme ├── … ├── _config.yml # 主题配置文件 └── source ├── … └── less ├── _layout.less # 主题布局配置文件 └── … 1.2 HEXO博客发布流程以及常用命令在写好一篇博客(md)后: 首先通过hexo g(enerate)命令由md文件生成静态网页； 随后应预览一下，使用hexo s(erver)命令可以启动本地服务器,随后在浏览器中访问网址http://localhost:4000/即可实时预览博客； 最后，通过hexo d(eploy)命令可以将完成的博客部署到远程服务器(github)。 2. 设备迁移2.1 迁移到新设备如果仅是迁移到新设备，其操作还是相对比较简单的 2.1.1 拷贝原数据通过U盘等将原设备上的以下博客文件(夹)拷贝至新设备。 . ├── _config.yml├── package.json├── scaffolds├── source└── themes 2.1.2 配置新设备 确保新设备上正确安装nodejs以及npm 12sudo apt install nodejs #(不推荐，推荐官网下载编译版本)sudo apt install npm 全局安装hexo 1sudo npm install -g hexo (--force) # 正常安装报错时可尝试使用--force命令 进入博客根目录配置hexo 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 检查：通过本地服务器http://localhost:4000 检查能否正确生成博客 12hexo ghexo s 2.2 多设备同步使用多台设备同步更新blog，其原理与使用git推拉repo相同。假设原博客保存在设备A，通过以下一个步骤将其同步到新设备B。 打开设备A上的博客根目录下的_config.yml，添加如下内容： 1234deploy: type: git repository: git@github.com:youname/youname.github.io.git branch: master 首先将完整的博客部署到GitHub上，随后在根目录下创建博客的git，该步骤需要注意一点：有的theme包含.git隐藏目录，需要将其删除。 12345678910# 部署博客hexo clean &amp;&amp; hexo g &amp;&amp; hexo d# 初始化repogit init# 创建新的分支git checkout -b your_branchgit add .git commit -m \"your_message\"git push origin your_branch 即master分支用于部署博客，your_branch分支用于提交源文件。 在新设备B上将源文件克隆到本地 1234git clone -b your_branch https://github.com/usrname/usrname.github.io.git your_blogcd your blog# 安装依赖npm install 如安装依赖报错可参考2.1节迁移新设备 测试。首先在设备B上编辑博客，并尝试部署提交。注意，此后多设备更新博客一定要在分支上操作。 1234hexo clean &amp; hexo g &amp; hexo dgit add .git commit -m 'your message'git push origin your_branch 尝试在设备A上同步更新(即拉取更新) 1git pull origin your_branch","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://w4ow.github.io/tags/HEXO/"}]},{"title":"Softmax回归：原理与实践","slug":"Deep_Learning/softmax_regression","date":"2021-12-13T10:10:53.891Z","updated":"2021-12-13T10:10:53.891Z","comments":true,"path":"2021/12/13/Deep_Learning/softmax_regression/","link":"","permalink":"http://w4ow.github.io/2021/12/13/Deep_Learning/softmax_regression/","excerpt":"不同于线性回归输出连续值，有的任务需要输出离散值，例如对图像的分类。对于离散值预测问题，我们可以使用softmax回归模型进行建模。softmax回归实际上是逻辑回归的一般形式，逻辑回归用于二分类，而softmax回归用于多分类。","text":"不同于线性回归输出连续值，有的任务需要输出离散值，例如对图像的分类。对于离散值预测问题，我们可以使用softmax回归模型进行建模。softmax回归实际上是逻辑回归的一般形式，逻辑回归用于二分类，而softmax回归用于多分类。 1. 理论模型考虑一个花朵的分类问题，每个花朵样本$\\bm{x}=[x_1,…,x_d]$有$d$个特征，例如花萼长度、宽度等等。花朵可以被分为$k$个类别。在现实生活中，我们通常使用离散值来表示类别，例如3种花我们可以将其分配标签1、2、3，但考虑到模型的输入，即样本的特征通常都是连续值，如果输出是离散的，那么这种从连续值到离散值的转化通常都会影响到分类结果的质量，因此我们引入了softmax回归。softmax的任务就是计算输入个例$\\bm{x}$属于每一类的概率，其输出是一个大小为$1\\times k$的向量$o\\in\\mathbb{R}^{1\\times k}$，其中每个分量的值都介于0到1之间，且各分量之和为1。我们可以认为该个例属于概率最高的那一类，例如当某样本经模型模型预测的输出为$[0.25,0.5,0.1,0.15]$，我们可以判断该样本属于第二类。 因为softmax对于一个样本$\\bm{x}$要计算其属于每一个类别的概率，因为样本包含$d$个特征、输出有$k$中类别，因此softmax回归模型包含$d\\times k$个权重以及$k$个偏差，对于每个类别，其输出结果计算为： $$\\begin{aligned}&amp; o_1 = x_1w_{11} + x_2w{21} + … + x_dw_{d1} + b_1 \\\\&amp; o_2 = x_1w_{12} + x_2w{22} + … + x_dw_{d2} + b_2 \\\\&amp; \\cdots \\\\&amp; o_k = x_1w_{1k} + x_2w{2k} + … + x_dw_{dk} + b_k\\end{aligned}$$ 一个简单的办法是直接用$o_i$中最大值对应的类作为输出结果，但这样做主要有两方面的问题： 输出值$o_i$的范围不确定，直观上很难判断这些值的意义。 真实标签是离散值，这些离散值与不确定范围的输出值之间的误差难以衡量。 因此我们对这些输出$o_i$进行softmax运算，使得其输出变为分布在0和1之间且和为1的概率分布： $$y_1, y_2, …, y_k = \\mathrm{softmax}(o_1, o_2, …, o_k)$$其中$$y_i = \\frac{e^{o_i}}{\\sum_{j=1}^k e^{o_j}}$$ 从该式可以看出$\\mathrm{sum}(\\hat y_i=1)$且$0 \\le \\hat y_i \\le 1$，因此输出是一个合法的概率分布。 综上，我们可以总结基于softmax回归的多分类模型的计算表达式： 1.1 单样本分类的矢量计算表达式给定一个样本$\\bm{x}=[x_1, x_2, …, x_d]$，样本被分为$k$类中的某一类 模型参数为$$\\bm{W}=\\begin{bmatrix}w_{11} &amp; w_{21} &amp; &amp; w_{d1}\\\\w_{12} &amp; w_{22} &amp; &amp; w_{d2}\\\\&amp; &amp; \\ddots &amp; \\\\w_{1k} &amp; w_{2k} &amp; &amp; w_{dk}\\end{bmatrix},\\bm{b}=\\begin{bmatrix}b_1 &amp; b_2 &amp; \\cdots &amp; b_d\\end{bmatrix}$$ 模型输出层的输出为 $$\\bm{o} = \\begin{bmatrix}o_1, o_2, \\cdots, o_k\\end{bmatrix}$$ 随后我们队输出层的输出做softmax运算，得到分类的概率分布 $$\\bm{y} = \\begin{bmatrix}y_1, y_2, \\cdots, y_k\\end{bmatrix}$$ 整个单样本过程计算为：$$\\begin{aligned}\\bm{o} &amp;= \\bm{xW}+\\bm{b} \\\\\\bm{y} &amp;= \\mathrm{softmax}(\\bm{o})\\end{aligned}$$ 1.2 小批量多样本分类的矢量计算表达式给定一个小批量输入$\\bm{X} = [\\bm{x}_1, \\bm{x}_2, \\cdots, \\bm{x}_n]^\\top \\in \\mathbb{R}^{n\\times d}$，其批量大小为$n$，每个样本的特征数为$d$，输出类别数为$k$，$\\bm{W}\\in\\mathbb{R}^{d\\times k}, \\bm{b}\\in\\mathbb{R}^{1\\times k}$，整个计算过程为 $$\\begin{aligned}\\bm{O} &amp;= \\bm{XW}+\\bm{b} \\\\\\bm{Y} &amp;= \\mathrm{softmax}(\\bm{O})\\end{aligned}$$ 特别要注意的是这里参数矩阵的尺寸为$d\\times k$ 2. 模型求解2.1 损失函数定义不同于线性回归经常使用均方误差作为损失函数，在分类预测中，想要预测的结果正确，我们并不需要预测概率完全等于标签概率，即我们只需要确保输入样本的某个分类的预测概率大于其他分类的预测概率即可。例如对于两种预测结果$\\bm{\\hat y}=[0.1, 0.7, 0.2]$和$\\bm{\\hat y}=[0.3, 0.4, 0.3]$对于分类结果来说都是一样的，而这对均方误差来说差别就很大。为了缓解这种现象，我们一般使用交叉熵损失。对于单样本$\\bm{x}$，假设其只有一个标签，那么我们可以为其构造真实标签$\\bm{y}\\in\\mathbb{R}^k$，并使$\\bm{y}$中对应该样本分类的分量为1，其余分量为0。那么，对于单样本其损失函数为$$l = -\\sum_{i=1}^kI(y_i)\\log y_i$$其中$I(y_i)$为指示性函数，我们假设该样本的分类为$y_i$，即$\\hat y_j=1$。那么当且仅当$y_i$的下标$i=j$时，$I(y_i)=1$,且此时上式等价于$l = -\\log y_j$；当$i\\not=j$时，$I(y_i)=0$。也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确。 同样的，对于多样本，假设样本数为$n$，那么总体的损失函数定义为$$L = \\frac{1}{n}\\sum_{i=1}^nl^{(i)} = -\\frac{1}{n}\\sum_{i=1}^n \\sum_{j=1}^k I(y_j^{(i)})\\log y_j^{(i)}$$同样地，如果每个样本只有一个标签且分类为$k$，那么$L$可以简化为$L = -\\frac{1}{n}\\sum_{i=1}^n\\log y_k^{(i)}$。从另一个角度来看，最小化$L$等价于最大化$\\exp(-nL)=\\prod_{i=1}^n\\hat y_k^{(i)}$，即最小化交叉熵等价于最大化数据集所有标签类别的联合概率分布。 2.2 损失函数的反向传播考虑到softmax函数为$$y_i = \\frac{e^{o_i}}{\\sum_{j=1}^k e^{o_j}}$$ 应用链式法则，可以得到：$$ \\frac{\\partial l}{\\partial o_i} = \\frac{\\partial l}{\\partial y_j}\\cdot\\frac{\\partial y_j}{\\partial o_i}$$注意上式中各符号的下标，$y$的下标是$j$而不是$i$的原因是在softmax中，其分母$\\sum_{j=1}^k\\exp(o_j)$包含了所有的输出。因此，我们对$w_i$求导时，对于下标$j\\not=i$时也要进行计算。 对于$\\frac{\\partial l}{\\partial y_j}$，我们有$$\\frac{\\partial l}{\\partial y_j}=-\\sum_{j=1}^k \\frac{I(y_j)}{y_j}$$ 对于$\\frac{\\partial y_j}{\\partial o_i}$，分两种情况讨论： 当$i=j$时：$$\\begin{aligned}\\frac{\\partial y_i}{\\partial o_i} &amp;= \\frac{\\partial(\\frac{e^{o_i}}{\\sum_{j=1}^k e^{o_j}})}{\\partial o_i} \\\\&amp;= \\frac{\\sum_{j=1}^k e^{o_j} e^{o_i} - (e^{o_i})^2}{\\sum_{j=1}^k(e^{o_j})^2} \\\\&amp;= \\left( \\frac{e^{o_i}}{\\sum_{j=1}^k e^{o_j}} \\right) \\left( 1 - \\frac{e^{o_i}}{\\sum_{j=1}^k e^{o_j}} \\right) \\\\&amp;= y_i (1 - y_i)\\end{aligned}$$ 当$i\\not= j$时：$$\\frac{\\partial y_j}{\\partial o_i} = \\frac{\\partial(\\frac{e^{o_j}}{\\sum_{t=1}^k e^{o_t}})}{\\partial o_i} = \\frac{-e^{o_i}e^{o_j}}{(\\sum_{t=1}^k e^{o_t})^2} = -y_iy_j$$ 将1.2.相乘，有：$$\\begin{aligned}\\frac{\\partial l}{\\partial o_i} &amp;=(-\\sum_{j=1}^k \\frac{I(y_j)}{y_j})(y_i (1-y_i) - y_iy_j) \\\\&amp;= -\\sum_{j=1, i=j}^k\\frac{I(y_j)}{y_j} y_i(1-y_i) + \\sum_{j=1, i\\not=j}^k \\frac{I(y_j)}{y_j}y_iy_j \\\\&amp;= -\\frac{I(y_i)}{y_i}y_i(1-y_i) + \\sum_{j=1, i\\not=j}^k \\frac{I(y_j)}{y_j}y_iy_j \\\\&amp;= -I(y_i)(1-y_i) + \\sum_{j=1,j\\not=i}^kI(y_j)y_i \\\\&amp;= -I(y_i) + I(y_i)y_i + \\sum_{j=1,j\\not=i}^kI(y_j)y_i \\\\&amp;= -I(y_i) + y_i\\sum_{j=1}^k I(y_j)\\end{aligned}$$ 当样本只有一个分类时，上式中$I(y_j)$只有一个值为1，因此上式又等价为$y_i-I(y_i)$ 当我们对各参数$w_i$求偏导时，有$$\\frac{\\partial L}{\\partial w_i} = \\frac{\\partial L}{\\partial o_i}\\cdot\\frac{\\partial o_i}{\\partial w_i} = \\frac{1}{n}\\sum_{i=1}^n(y_i-I(y_i))\\cdot \\bm{x}_i$$ 3. PyTorch实战图像分类数据集FashionMNIST是一个10分类图片数据集，每一张图片的大小为28*28像素。由于数据集是用0~9折十个数字给图片分类，不利于人类阅读，因此我们为其分配文字标签。 1234567891011121314151617181920212223242526272829303132333435363738394041import torchimport torchvisionimport torchvision.transforms as transformsimport matplotlib.pyplot as pltmnist_train = torchvision.datasets.FashionMNIST(root='./Datasets/FashionMNIST', train=True, download=True, transform=transforms.ToTensor())mnist_test = torchvision.datasets.FashionMNIST(root='./Datasets/FashionMNIST', train=False, download=True, transform=transforms.ToTensor())def get_labels(labels): text_labels = ['t-shirt', 'trouser', 'pullover', 'dress', 'coat', 'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot'] if isinstance(labels, list): return [text_labels[i] for i in labels] else: return text_labels[labels]def get_images(images, labels): if isinstance(images, list): _, figs = plt.subplots(1, len(images), figsize=(12, 12)) for f, img, lbl in zip(figs, images, labels): f.imshow(img.view((28, 28)).numpy()) f.set_title(lbl) f.axes.get_xaxis().set_visible(False) f.axes.get_yaxis().set_visible(False) else: plt.imshow(images) plt.title(labels) # plt.axes.get_xaxis().set_visible(False) # plt.axes.get_yaxis().set_visible(False) plt.axis('off') plt.show()feature, label = mnist_train[0]print(f'Image size: &#123;feature.shape&#125; \\nImage class: &#123;get_labels(label)&#125;')get_images(feature[0], get_labels(label))# more samplesx, y = [], []for i in range(10): x.append(mnist_train[i][0]) y.append(mnist_train[i][1])get_images(x, get_labels(y)) 12Image size: torch.Size([1, 28, 28]) Image class: ankle boot 1234567891011121314151617181920212223242526272829303132333435363738394041424344'''封装数据'''batch_size = 256train_iter = torch.utils.data.DataLoader(mnist_train, batch_size=batch_size, shuffle=True)test_iter = torch.utils.data.DataLoader(mnist_test, batch_size=batch_size, shuffle=False)'''定义训练函数'''def train(model, train_iter, test_iter, loss, num_epochs, batch_size, params=None, lr=None, optimizer=None): for epoch in range(num_epochs): train_l_sum, train_acc_sum, n = 0, 0, 0 for x, y_hat in train_iter: y = model(x) l = loss(y, y_hat).sum() if optimizer is not None: optimizer.zero_grad() elif params is not None and params[0].grad is not None: for param in params: param.grad.data.zero_() l.backward() if optimizer is None: sgd(params, lr, batch_size) else: optimizer.step() train_l_sum += l.item() train_acc_sum += (y.argmax(dim=1) == y_hat).sum().item() n += y.shape[0] test_acc = evaluate_accuracy(test_iter, model) print(f'epoch &#123;epoch + 1&#125;, \\ttrain loss: &#123;train_l_sum / n:.4f&#125;, \\t train accuracy: &#123;train_acc_sum / n:.4f&#125;, \\t test accuracuy: &#123;test_acc:.4f&#125;')'''计算准确率'''def accuracy(y_hat, y): return (y_hat.argmax(dim=1) == y).float().mean().item()def evaluate_accuracy(data_iter, net): acc_sum, n = 0.0, 0 for x, y_hat in data_iter: acc_sum += (net(x).argmax(dim=1) == y_hat).float().sum().item() n += y_hat.shape[0] return acc_sum / n 3.1 从零实现12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as np'''定义模型参数'''num_inputs = 28 * 28num_outputs = 10w = torch.tensor(np.random.normal(0, 0.01, (num_inputs, num_outputs)), dtype=torch.float)b = torch.zeros(num_outputs, dtype=torch.float)w.requires_grad_(requires_grad=True)b.requires_grad_(requires_grad=True)'''实现softmax'''def softmax(x): x_exp = x.exp() partition = x_exp.sum(dim=1, keepdim=True) return x_exp / partition'''定义模型'''def net(x): return softmax(torch.mm(x.view((-1, num_inputs)), w) + b)'''定义交叉熵损失函数'''def cross_entropy(y_hat, y): return - torch.log(y_hat.gather(1, y.view(-1, 1)))'''定义优化函数'''def sgd(params, lr, batch_size): for param in params: param.data -= lr * param.grad / batch_size'''训练'''num_epochs = 5lr = 0.1device = torch.device('cuda')train(net, train_iter, test_iter, cross_entropy, num_epochs, batch_size, [w, b], lr) 12345epoch 1, train loss: 0.7856, train accuracy: 0.7476, test accuracuy: 0.7952epoch 2, train loss: 0.5710, train accuracy: 0.8127, test accuracuy: 0.8086epoch 3, train loss: 0.5266, train accuracy: 0.8246, test accuracuy: 0.8214epoch 4, train loss: 0.5014, train accuracy: 0.8318, test accuracuy: 0.8247epoch 5, train loss: 0.4850, train accuracy: 0.8367, test accuracuy: 0.8290 123456789'''预测'''x, y = iter(test_iter).next()true_labels = get_labels(list(y.numpy()))pred_labels = get_labels(list(net(x).argmax(dim=1).numpy()))titles = [true + '\\n' + pred for true, pred in zip(true_labels, pred_labels)]get_images(list(torch.squeeze(x[10:19], dim=1)), titles[10:19]) 3.2 简洁实现123456789101112131415161718192021import torch.nn as nndevice = torch.device('cuda')class Linear(torch.nn.Module): def __init__(self, input_dim, output_dim): super().__init__() self.linear = nn.Linear(input_dim, output_dim) def forward(self, x): return self.linear(x.view(x.shape[0], -1))input_dim = 28*28output_dim = 10model = Linear(input_dim, output_dim)loss = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=.1)num_epochs = 5train(model, train_iter, test_iter, loss, num_epochs, batch_size, None, None, optimizer) 12345epoch 1, train loss: 0.0031, train accuracy: 0.7475, test accuracuy: 0.7869epoch 2, train loss: 0.0022, train accuracy: 0.8133, test accuracuy: 0.7666epoch 3, train loss: 0.0021, train accuracy: 0.8261, test accuracuy: 0.8168epoch 4, train loss: 0.0020, train accuracy: 0.8328, test accuracuy: 0.8224epoch 5, train loss: 0.0019, train accuracy: 0.8368, test accuracuy: 0.8237","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Deep Learning","slug":"Computer-Science/Deep-Learning","permalink":"http://w4ow.github.io/categories/Computer-Science/Deep-Learning/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://w4ow.github.io/tags/ML/"}]},{"title":"线性回归：原理与实践","slug":"Deep_Learning/linear_regression","date":"2021-12-13T10:10:53.889Z","updated":"2021-12-13T10:10:53.889Z","comments":true,"path":"2021/12/13/Deep_Learning/linear_regression/","link":"","permalink":"http://w4ow.github.io/2021/12/13/Deep_Learning/linear_regression/","excerpt":"线性回归的输出是一个连续值，因此适用于回归问题，例如房价预测、气温预测、股票预测等等，但是作为一个单层神经网络，其预测能力十分有限。本文简要的介绍其原理以及PyTorch实现。","text":"线性回归的输出是一个连续值，因此适用于回归问题，例如房价预测、气温预测、股票预测等等，但是作为一个单层神经网络，其预测能力十分有限。本文简要的介绍其原理以及PyTorch实现。 1. 理论模型给定一个随机样本$(\\hat y_i, x_{i1}, x_{i2},…,x_{ip})$，一个线性回归模型假设模型的输入(又称回归量)为$(x_{i1}, x_{i2},…,x_{ip})$，模型的输出(又称回归子)为$\\hat y_i$。同时我们加入一个误差项$\\varepsilon_i$来捕获除了输入自变量之外的任何对输出的影响。 $$y_i = b+w_1x_{i1}+w_2x_{i2}+…+w_px_{ip}+\\varepsilon_i$$ 当模型只有一个输入自变量，即$p=1$时，模型被称为一元线性回归，反之则为多元线性回归。形式上地，我们可以定义线性回归模型为： $$\\bm{y}=\\bm{Xw}+b$$ 2. 模型求解2.1 最小二乘法我们以一元线性回归为例，简单介绍最小二乘法求解模型。给定了若干个实际样本$(\\hat y_i, x_i),i=1,2,…,n$，我们需要找出一元线性回归模型$y=b+wx$中的$w$和$b$，使得该模型能够很好地拟合这一组数据。最小二乘法的标准是，所有样本到模型方程的平方误差最小。在最小二乘法中，单个样本的平方误差为： $$l=\\frac{1}{2}(\\hat y_i-y_i)^2$$ 其中，添加系数$\\frac{1}{2}$是为了后面对其求导时能够消除系数。总样本平均误差为： $$L = \\frac{1}{2n}\\sum_{i=1}^n(\\hat y_i-y_i)^2 = \\frac{1}{2n}\\sum_{i=1}^n(\\hat y_i - (b+wx_i))^2$$ 实际上，当我们将$w$和$b$当做求解目标时，那么该方程是关于$w$和$b$的凸函数。凸函数的重要特点就是当其导数为0时取得最小值。因此我们可以对$w$和$b$分别求偏导并令其为0： $$\\begin{aligned} \\frac{\\partial L}{\\partial b} &amp;= -\\sum_{i=1}^n(\\hat y_i-b-wx_i)=\\sum_{i=1}^n(\\hat y_i-b-wx_i)=0 \\\\ \\frac{\\partial L}{\\partial w} &amp;= -\\sum_{i=1}^n(\\hat y_i-b-wx_i)x_i=\\sum_{i=1}^n(\\hat y_i-b-wx_i)x_i=0\\end{aligned}$$ 因为$x_i, \\hat y_i$都是已知的，带入上式即可求得$w,b$。该方法被称为最小二乘法，二乘即平方的意思。 同样的，多元线性模型的与上面一致，即求得一组参数$w_i$使得以下方程最小化： $$L=\\frac{1}{2n}\\sum_{i=1}^n(\\hat y_i-y_i)^2=\\frac{1}{2n}\\sum_{i=1}^n(\\hat y_i - (b+w_1x_{i1}+w_2x_{i2}+…+w_px_{ip}))^2$$ 对各参数$w_i$的求解同样使用最小二乘法，先求其偏导，再带入实际值$x_i,y_i$进行求解，不再赘述。 2.2 梯度下降在使用偏导求解$w_i$的过程中，小批量随机梯度下降法(Mini-Batch Stochastic Gradient Descent, MBSGD)目前被广泛应用，其算法原理是，首先对$w_i$取随机初始值，然后对$w_i$进行多次迭代，每次迭代都可能降低损失函数$L$的值，由于$L$是凸函数，因此该方法肯定会在$w_i$取到某些值时达到最小值(或极小值)。在每次迭代中，MBSGD会从所有的样本中随机抽取若干个样本构成一个小批量$\\mathcal{B}$，并基于这些小批量样本更新$w_i$: $$w_i \\gets w_i - \\frac{\\eta}{|\\mathcal{B}|}\\frac{\\partial L}{\\partial w_i}$$ 其中$\\eta$为每次更新$w_i$的步长，也称为学习率。 3. PyTorch实战3.1 数据集生成以及封装假设房价是关于房屋面积$x_1$和房龄$x_2$的二元回归，我们可以令其为$y=2.3x_1+3.4x_2+1.1$，即$b=1.1, \\bm{w}=[2.3, 3.4]$。现在我们依照该函数构造一个数据集 123456789101112131415161718192021222324import torchfrom matplotlib import pyplot as pltimport numpy as npimport randomimport utilsfrom torch.utils.data import Dataset, TensorDataset, DataLoader# 特征数(即自变量输入)个数为2：房屋面积以及房龄num_features = 2num_samples = 1000data = torch.randn(num_samples, num_features, dtype=torch.float)true_w = [2.3, 3.4]true_b = 1.1labels = true_w[0] * data[:, 0] + true_w[1] * data[:, 1] + true_b# 添加噪声(误差)labels += torch.tensor(np.random.normal(0, 0.01, size=labels.shape), dtype=torch.float)plt.scatter(data[:, 0].numpy(), labels.numpy(), s=1)plt.scatter(data[:, 1].numpy(), labels.numpy(), s=1)plt.ylabel('House price')plt.legend(labels=['$x_1$', '$x_2$'])plt.show() 封装数据集，封装后的数据变为Torch.Tensor数据类型，可以被Torch识别处理。 12dataset = TensorDataset(data, labels)data_iter = DataLoader(dataset, batch_size=32, shuffle=True) 3.2 初始化参数模型将$w$初始化成均值为$0$、标准差为$0.01$的正态随机数矩阵$\\mathbb{R}^{2\\times 1}$，将$b$初始化为$1$。在之后的模型训练中，因为要对这些参数求梯度，因此要将它们的requires_grad=True 12345w = torch.tensor(np.random.normal(0, 0.01, (num_features, 1)), dtype=torch.float)b = torch.zeros(1, dtype=torch.float)w.requires_grad_(requires_grad=True)b.requires_grad_(requires_grad=True)print(w.shape, b.shape) 12Output:torch.Size([2, 1]) torch.Size([1]) 3.3 定义模型首先定义我们的回归模型：$$y=\\bm{wX}+b$$其平方损失函数为： $$L = \\frac{1}{2n}\\sum_{i=1}^{n}(\\hat y_i-y_i)^2$$模型可学习参数$\\bm{w}$和$b$的更新过程为：$$\\begin{aligned}w_i &amp;\\gets w_i - \\frac{\\eta}{|\\mathcal{B}|}\\frac{\\partial L}{\\partial w_i}\\\\b &amp;\\gets b - \\frac{\\eta}{|\\mathcal{B}|}\\frac{\\partial L}{\\partial b}\\end{aligned}$$ 123456789def linear(X, w, b): return torch.mm(X, w) + bdef squared_loss(y_hat, y): return (y_hat - y.view(y_hat.size())) ** 2 / 2def sgd(params, lr, batch_size): for param in params: param.data -= lr * param.grad / batch_size 3.4 模型训练在训练中，我们多提从数据集中读取小批次样本，通过调用PyTorch中的反向函数backward计算小批量样本的随机梯度，并调用优化算法SGD来迭代可学习参数$\\bm{w}$和$b$ 12345678910111213141516171819lr = 0.03num_epochs = 5model = linearloss = squared_lossfor epoch in range(num_epochs): for x, y in data_iter: l = loss(model(x, w, b), y).sum() l.backward() utils.sgd([w, b], lr, batch_size=32) w.grad.data.zero_() b.grad.data.zero_() train_l = loss(model(data, w, b), labels) print(f'epoch &#123;epoch + 1&#125;, loss: &#123;train_l.mean().item():.4f&#125;')print()print(f'True paras: \\t w:&#123;true_w&#125; \\t\\t\\t b:&#123;true_b&#125;')print(f'Train result: \\t w:&#123;w.detach().view(1, 2).numpy()[0]&#125;, \\t b: &#123;b.detach().numpy()&#125;') 123456789Output:epoch 1, loss: 0.0000epoch 2, loss: 0.0000epoch 3, loss: 0.0000epoch 4, loss: 0.0000epoch 5, loss: 0.0000True paras: w:[2.3, 3.4] b:1.1Train result: w:[2.2997692 3.4001975], b: [1.0994117] 可以看到，模型通过5次迭代后的结果就已经十分接近真实值了。 3.5 模型的简洁实现PyTorch是一个完成度十分高的深度学习框架，其中已经包含了许多定义好的模型，因此我们可以通过调用直接构造第3.3节中的模型 12345678910111213import torch.nn as nn# 定义模型class Linear(nn.Module): def __init__(self, input_dim, output_dim=1): super().__init__() self.linear = nn.Linear(input_dim, output_dim) def forward(self, x): out = self.linear(x) return outmodel = Linear(num_features) PyTorch实例化的模型参数是随机的，个人认为是不需要再次随机化的。 同样的，PyTorch也提供了损失函数和优化算法，我们可以方便地直接调用。 12345678910111213141516loss = nn.MSELoss()optimizer = torch.optim.SGD(model.parameters(), lr=0.03)num_epochs = 5for epoch in range(num_epochs): for x, y in data_iter: out = model(x) l = loss(out, y.view(-1, 1)) optimizer.zero_grad() l.backward() optimizer.step() print(f'epoch &#123;epoch + 1&#125;, loss: &#123;l.item():.4f&#125;')print()print(f'True paras: \\t w:&#123;true_w&#125; \\t\\t\\t b:&#123;true_b&#125;')print(f'Train result: \\t w:&#123;w.detach().view(1, 2).numpy()[0]&#125;, \\t b: &#123;b.detach().numpy()&#125;') 123456789Ouput:epoch 1, loss: 0.0001epoch 2, loss: 0.0002epoch 3, loss: 0.0002epoch 4, loss: 0.0001epoch 5, loss: 0.0001True paras: w:[2.3, 3.4] b:1.1Train result: w:[2.2997692 3.4001975], b: [1.0994117]","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Deep Learning","slug":"Computer-Science/Deep-Learning","permalink":"http://w4ow.github.io/categories/Computer-Science/Deep-Learning/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://w4ow.github.io/tags/ML/"}]},{"title":"人工智能学习路线","slug":"Deep_Learning/Learning_path_of_ml","date":"2021-11-28T16:00:00.000Z","updated":"2021-12-13T10:10:53.764Z","comments":true,"path":"2021/11/29/Deep_Learning/Learning_path_of_ml/","link":"","permalink":"http://w4ow.github.io/2021/11/29/Deep_Learning/Learning_path_of_ml/","excerpt":"人工智能学习路线","text":"人工智能学习路线 动手学深度学习(PyTorch)","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Deep Learning","slug":"Computer-Science/Deep-Learning","permalink":"http://w4ow.github.io/categories/Computer-Science/Deep-Learning/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://w4ow.github.io/tags/AI/"}]},{"title":"Git常见问题及解决方法","slug":"CS/Tools/Debug_git","date":"2021-11-11T05:35:00.000Z","updated":"2022-02-27T08:41:22.985Z","comments":true,"path":"2021/11/11/CS/Tools/Debug_git/","link":"","permalink":"http://w4ow.github.io/2021/11/11/CS/Tools/Debug_git/","excerpt":"Git常见问题及解决方法","text":"Git常见问题及解决方法 1 网络问题1.1 连接GitHub端口超时问题：上传代码到GitHub时报连接超时 12ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository. 解决方案 首先测试能否连接到GitHub 12&lt;!-- -T参数表示关闭pseudo-tty的分配，-p参数指定端口 --&gt;ssh -T -p 443 git@ssh.github.com 若无反应则表示连接不上GitHub。 若连接不上，则向~/.ssh/config文件添加如下内容(无该文件则创建)： 123Host github.com HostName ssh.github.com Port 443 再次测试，出现一下字样则表示能够连接到GitHub。 1Hi your_github_name! You've successfully authenticated, but GitHub does not provide shell access. 1.2 连接GitHub端口超时问题：与上面不太一样的端口超时 1fatal: unable to access 'https://github.com/***/***.git/': Failed to connect to github.com port 443: Connection timed out 解决方法 首先尝试能不能ping通github.com，我的无法ping通 前往https://websites.ipaddress.com/www.github.com查询当前github.com的实际ip 拷贝实际IP并添加到/etc/hosts文件下，注意权限 1140.82.114.4 github.com 再次ping发现可以ping通了，此时上传没有问题","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://w4ow.github.io/tags/Git/"}]},{"title":"《中国哲学简史》笔记","slug":"Literature/chinese_philosophy","date":"2021-07-26T08:00:00.000Z","updated":"2021-12-13T10:12:29.353Z","comments":true,"path":"2021/07/26/Literature/chinese_philosophy/","link":"","permalink":"http://w4ow.github.io/2021/07/26/Literature/chinese_philosophy/","excerpt":"冯友兰先生于一九四六年在宾夕法尼亚大学任访问教授时著此书。全书共二十八章，前十六章为第一卷，后十二章为第二卷。","text":"冯友兰先生于一九四六年在宾夕法尼亚大学任访问教授时著此书。全书共二十八章，前十六章为第一卷，后十二章为第二卷。 第一章：中国哲学的精神哲学在中华文明的地位，正如宗教在西方世界的地位。作为一个中国人，首先要学习的便是哲学。在古代，儿童要学三字经，科举要学四书五经；在现代，思想道德早已是九年义务教育的必修科目。 1.1 哲学在中国文明中的地位 哲学在中华文明的地位堪比于西方的宗教，但两者皆然不同：哲学里没有上帝和天堂，人们不需要向上帝忏悔或祈祷。人们通过思考这一思想活动来“进行哲学活动”。而对思考的思考，就是反思。 哲学是对人生的系统的反思……宗教就是某种哲学加上一定的上层建筑，包括迷信、教义、礼仪和体制。 儒家、道家和佛学是哲学，并不同于儒教、道教和佛教，后者是纯粹的宗教。道家主张顺应自然，而道教则逆天而为：追求长生不死。 中国文化的精神基础不是宗教，而是伦理道德。之所以不像西方世界普遍以宗教为精神基础，是因为中国人的哲学意识十分浓厚，中国人在哲学理找到了超越现实世界的存在，也在哲学里表达和欣赏了超越伦理道德的价值。所谓超越伦理道德的价值，正如其名，是超越伦理道德的价值。例如，在西方，爱神是一个超越伦理道德的价值；而在我中华，爱天地万物是与之对应的价值。 中国的传统哲学的功能不是为了增进正面的知识(对客观事物的了解)，而是为了提高人的心灵，超越现实世界，体验高于道德的价值。 宗教所提供的价值，哲学同样也能提供，并且更直接、更纯粹，无需通过祈祷仪式，不掺杂想象和迷信。在将来的世界里哲学将取代宗教的地位，这合乎中国哲学传统。人不需要宗教化，但必须哲学化。当人哲学化了，他也得到了宗教所提供的最高价值。 1.2 中国哲学的问题和它的精神 做人的最高成就，即是成圣：个人与宇宙合而为一。有的哲学家如释迦摩尼、柏拉图等认为，成圣必须抛弃社会、舍弃生命，唯有如此，才能取得最后的解脱。这种哲学被称为“出世”。与之相对的，强调社会中的人际关系、只关注道德价值的哲学被称为“入世”哲学。从入世看，出世过于理想；从出世看，入世过于肤浅。 从表面看，中国哲学是入世哲学，只关心社会与人际，典型代表是儒家哲学。而实际上，中国哲学即是入世，也是出世，道佛哲学是出世哲学的代表。中国哲学通过“内圣外王”达到入世和出世的综合。 中国哲学推崇内圣外王，故而难以脱离政治。在中国哲学里，无论哪派，其哲学思想也是其政治思想，它们都以不同的形式与政治联系在一起。 中国哲学以内圣外王为主题，故而对其不仅要研究，更重要的是体验、践行这一哲学思想。 1.3 中国哲学家表达思想的方式 中国哲学著作往往是简短精炼且不连贯的，例如《论语》中，一个观点往往用格言短句表述，并且没有作任何旁证。这显得这些著作更像教条。 中国哲学家习惯于用格言、比喻和事例来说理，其中的哲学思想通过暗示来彰显，富于暗示而不是一泻无余，这是中国诗歌、绘画等各种艺术所追求的目标。读者通过字里行间去会意，这是中国艺术所追求的情趣，也是中国哲学家表述思想时的风格。 1.4 语言的障碍 人和翻译文字，说到底，只是一种解释。当我们翻译一句话时，我们是在按照自己的理解来阐述它的含义。译文只能表达一种含义，而原文可能还有其他含义。 第二章：中国哲学的背景","categories":[{"name":"Literature","slug":"Literature","permalink":"http://w4ow.github.io/categories/Literature/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://w4ow.github.io/tags/哲学/"}]},{"title":"形式语言与计算复杂性(六)：时间复杂度","slug":"Math/Formal_lang/Lec6","date":"2021-07-05T13:00:00.000Z","updated":"2022-02-27T08:41:23.313Z","comments":true,"path":"2021/07/05/Math/Formal_lang/Lec6/","link":"","permalink":"http://w4ow.github.io/2021/07/05/Math/Formal_lang/Lec6/","excerpt":"Lecture 6：时间复杂度","text":"Lecture 6：时间复杂度 在前面的章节中，我们学习到了，不可判定的问题会因为陷入loop而无法使用图灵机解决。在实际应用中，由于内存和执行时间的限制，某些可判定问题依然无法被图灵机解决。我们根据执行求解问题的算法所需要花费的时间，将问题划分为不同的难度，即时间复杂度。 1. 复杂度衡量1.1 大O与小o令$M$是一个能对任何输入都给出判定的确定的图灵机，$M$的时间复杂度是一个函数$f:\\mathcal{N}\\to\\mathcal{N}$，其中$n$是输入的长度，$f(n)$是$M$运行的最大步数。实际上由于$f(n)$很难精确计算，因此我们通常使用渐进分析来估算：我们仅考虑$f(n)$的最高次项，并忽略该项的系数，作为该图灵机的时间复杂度。例如给出$f(n)=6n^3+2n^2+20n+45$，则渐进估算$f(n)=O(n^3)$。下面我们形式化的定义大O标记： Big-O标记令$f$和$g$为两个函数$f,g:\\mathcal{N}\\to\\mathcal{R}^+$。我们认为$f(n)=O(g(n))$当且仅当存在正整数$c$和$n_0$使得当$n\\ge n_0$时，下式始终成立$$f(n)\\le cg(n)$$当$f(n)=O(g(n))$时，我们称$g(n)$为$f(n)$的渐进上界(asymptotic upper bound) 例如，令$f(n)=6n^3+2n^2+20n+45$，$g(n)=n^3$，我们令$c=6,n_0=10$，则有$f(n)=O(g(n))$。当然，$f(n)$的渐进上界不止$g(n^3)$，$g(n^4)$同样也是。同样的，$f(n)=3n\\log n+5n\\log\\log n + 2$的渐进上界为$O(n\\log n)$。 更进一步的，我们对渐进上界进行分类： 多项式上界：上界形如$n^c,c&gt;0$指数上界：上界形如$2^{(n^\\delta)},\\delta&gt;0$ 小o标记是大O标记的严格版本，即对任意的$c$，都有$f(n)&lt;cg(n)$。举几个例子： $\\sqrt{n}=o(n)$ $n=o(n\\log\\log n)$ $n\\log\\log n = o(n\\log n)$ $n\\log n=o(n^2)$ $n^2=o(n^3)$ 需要注意的是，$f(n)\\not=o(f(n))$ 1.2 算法分析 令$t:\\mathcal{N}\\to\\mathcal{R}^+$，我们定义时间复杂度类$TIME(t(n))$为一个语言的集合，该集合中所有的语言都是在$O(t(n))$时间复杂度内可判定的。 教材举例分析了用于判定语言$A=\\{0^k1^k|k\\ge0\\}$的图灵机的时间复杂度，并给出了其时间复杂度为$O(n^2)$，即$A\\in TIME(n^2)$。同时，教材给出了两个优化版本的图灵机用于判定$A$，使得时间复杂度能下降到$O(n\\log n)$甚至$O(n)$，这也引出了接下来的内容。 1.3 模型与时间复杂度 定理令$t(n)\\ge n$，每一个$O(t(n))$的多磁带TM都有一个等价的$O(t^2(n))$的单磁带图灵机。 在Lecture 3中介绍了如何将单磁带图灵机和多磁带图灵机之间的相互转换。给定一个$O(t(n))$的$k-$磁带图灵机$M$，我们可以将这多个磁带首尾相接拼成一个单磁带$S$，并用#作为标识符分割这些磁带。因为$k-$磁带中每条磁带使用$t(n)$时间执行，所以$S$应当使用$kt(n)$、也就是$O(t(n))$时间来执行，然后$S$在执行之前，还需要额外的$t(n)$时间来扫描整条磁带，以找到$M$在$S$中的每个磁带头的位置，因此总时间为$t(n)O(t(n))=O(t^2(n))$。 令$t(n)\\ge n$，则每一个$t(n)$时间复杂度的非确定单磁带图灵机有一个等价的$2^{O(t(n))}$时间复杂度的确定单磁带图灵机 简单证明一下。假设$N$是$t(n)$的非确定单磁带图灵机，则$N$对应的计算树的深度为$t(n)$，我们假设其计算树每个结点都有$b$个分支（即每个状态都可能转移到其他$b$个状态），则计算树有至多$b^{t(n)}$个叶子。那么我们构造确定的单磁带图灵机$N$，则$N$从开始便利到叶子共花费$t(n)$时间，而总共有$b^{t(n)}$个叶子，所以总共花费$O(t(n)b^{t(n)})=2^{O(t(n))}$时间。 2. P类问题 所谓的P类，是指能在多项式时间内能被确定的单磁带图灵机判定的语言，即$P=TIME(n^k)$ 2.1 图路径问题 定理$PATH\\in P$，$PATH=\\{\\langle G,s,t\\rangle|G\\ \\mathrm{is\\ a\\ directed\\ graph\\ that\\ has\\ a\\ directed\\ path\\ from\\ } s\\ \\mathrm{to\\ }t\\}$ 该问题是判断两点$s$和$t$之间是否存在路径，我们可以构造如下的图灵机 $M$ = 给定输入$\\langle G,s,t\\rangle$，其中$G$是一个有向图，$s$和$t$是图中的结点： 1. 标记$s$ 2. 扫描图的所有节点，如果图中存在边$(a,b)$，且$a$被标记了，则标记$b$ 3. 如果$t$被标记，$accept$，反之$reject$ 分析以上算法，第2步最多执行$m$次，$m$为路径的长度，每次花费多项式时间来寻找被标记的$a$，因此是算法时间复杂度为多项式级。 2.2 互素问题 定理$RELPRIME\\in P$，$RELPRIME=\\{\\langle x,y\\rangle|x,y\\ \\mathrm{are\\ relatively\\ prime}\\}$ 即判断$x$和$y$是否互为素数，所使用的算法为辗转相除法 $E$ = 给定输入$\\langle x,y\\rangle$，其中$x,y$为自然数： 1. Repeat until $y=0$ 2. Assign $x\\gets x\\ \\mathrm{mod}\\ y$ 3. Exchange $x$ and $y$ 4. Output $x$ 图灵机$E$就算是辗转相除法求最大公约数，然后我们用$E判定两数互为素数： $R$ = 给定输入$\\langle x,y\\rangle$，其中$x,y$为自然数： 1. Run $E on $\\langle x,y\\rangle$ 2. If the result is $1$, $accept$, else $reject$ 可以看到，$E$中第2步每次会把$x$的值减半，因此$E$中整个循环执行$\\log n$次，因此算法时间复杂度为多项式级 2.3 CFL的复杂度 定理每个CFL都是P问题 这个定理的证明，首先需要将CFL转换为CNF形式地CFG，然后使用动态规划来求解，其时间复杂度为$O(n^3)$，证明过程看书。 3. NP问题有些问题无法找出多项式时间复杂度的算法，因此想要求解它们只能用暴力法，而暴力法的时间复杂度通常是指数级的。此外，这一类问题通常是可以相互转换的，就如我们在Lecture 5中所作的那样，可以将问题相互规约。首先，我们给出一个最经典的、无法再多项式时间内求解的问题：哈密尔顿路径问题，找出图中从$s$到$t$，且刚好经过每个结点一次的路径。求解一个图中是否存在哈密尔顿路径是很困难的，但如果我们给出一条路径，判断这条路径是否是哈密尔顿路径是简单的，我们称之为多项式可验证的。类似多项式可验证的问题还有COMPOSITES：判断一个数是否为另外两个数的乘积。 定义一个语言$A$的验证器是一个算法$V$，$$A=\\{w|V\\ \\mathrm{accepts}\\ \\langle w,c\\rangle\\mathrm{\\ for\\ some\\ string\\ }c\\}$$我们使用$w$的长度来衡量验证器的时间复杂度，一个多项式时间复杂度的验证器能在多项式时间内验证$w$，一个语言是多项式可验证的是指它有多项式时间的验证器。 验证器需要额外的信息，表示为$c$，这个额外的信息称为certificate。例如，在哈密尔顿路径问题中，$c$就是一条cong$s$到$t$的哈密尔顿路径，在COMPOSITES问题中，$c$就是$x$的一个因子。 定义NP类是指那些有多项式时间验证器的语言集合。NP = Nondeterministic polynomial time 3.1 NP语言与非确定图灵机 定理一个语言是NP的，当且仅当他可以被某些非确定多项式时间图灵机判定 证明 令$A\\in$NP，令$V$是$A$的多项式时间验证器，即$V$是一个图灵机且运行时间为$n^k$，我们构造图灵机$N$$N$ = 给定长度为$n$的输入$w$: 1. 非确定的选择字符串$c$，$c$是一个certificate且长度最多为$n^k$ 2. 在$V$上验证$\\langle w,c\\rangle$ 3. 如果$V\\ accept$，则$N\\ accept$，否则$reject$ 可以看到，如果$A$是NP的，我们构造的$N$可以在多项式时间内判定它 假定$A$可以被一个多项式时间的图灵机$N$判定，我们构造一个多项式判定器$V$:$V$ = 给定输入$\\langle w,c\\rangle$，其中$w$和$c$是字符串: 1. 模拟$N$且其输入为$w$，将$c$的每一个符号视为每一步要做的非确定选择的描述。 2. 如果$N$基于$c$则计算返回了$accept$，则$V\\ accpet$，否则$reject$ 这样的一个判定器可以判定$\\langle w,c\\rangle$ 综上，定理得证。 NTIME$NTIME(t(n)) = \\{L|L\\ \\mathrm{is\\ a\\ language\\ decidec\\ by\\ an\\ }O(t(n))\\ \\mathrm{time\\ nondeterministic\\ TM}\\}$ 推论$NP = \\cup_k NTIME(n^k)$ 3.2 其他的NP问题团问题是个NP问题，所谓的团，是指任意两个节点之间都有边的子图(完全图)，$k-$团是指这样的子图有$k$个结点。对其证明与上面类似，要从正反两个方向分别构造验证器$V$和图灵机$N$。详细证明见教材。 子数组和是个NP问题，即从数组中找出一个子数组，使该子数组的和为指定值。 总的来说，P类问题是能在多项式时间内解决的问题，而NP问题是能在多项式时间内验证的问题，即$P\\subset NP$，但对于$P=NP$ 4. NPC问题 作业 Answer each part $TRUE$ or $FALSE$. $2n=O(n)$ $n^2=O(n)$ $n^2=O(n\\log^2n)$ $n\\log n=O(n^2)$ $3^n=2^{O(n)}$ $2^{2^n}=O(2^{2^n})$ Answer $TRUE$ $FALSE$ $FALSE$，无论$c$的值为多少，两者总会有三个交点，且在最右交点之后，$n^2&gt;cn\\log^2n$ $TRUE$ $TRUE$，$3^n=2^{n\\log_{2}3}=2^{O(n)}$ $TRUE$ Answer each part $TRUE$ or $FALSE$. $n=o(2n)$ $2n=o(n^2)$ $2^n=o(3^n)$ $1=o(n)$ $n=o(\\log n)$ $1=o(1/n)$ Answer $FALSE$，当$c&lt;0.5$时，$n&gt;co(2n)$ $TRUE$ $TRUE$ $TRUE$ $FALSE$ $FALSE$ Is the following formula satisfiable?$$(x\\lor y)\\land(x\\lor\\overline{y})\\land(\\overline{x}\\lor y)\\land(\\overline{x}\\lor\\overline{y})$$ AnswerNo A triangle in an undirected graph is a 3-clique. Show that $TRIANGLE\\in P$, where $TRIANGLE=\\{\\langle G\\rangle | G\\ \\mathrm{contains\\ a\\ triangle}\\}$. Answer我们可以构造图灵机$M$，且$M$可在多项式时间内判定$TRIANGLE$.$M$ = “给定输入$\\langle G\\rangle$，$G=(V,E)$是一个无向图: 扫描节点集$V$，枚举所有的节点三元组$(u,v,w)$，其中$u,v,w\\in V$ 扫描边集$E$，检查无向边$(u,v),(v,w),(u,w)$是否存在 如果有任意一个节点三元组$(u,v,w)$满足步骤2，则$accept$，否则$reject$” 分析步骤1需要$|V|^3$时间，步骤2需要$|E|$时间，总计需要$O(|V|^3|E|)$时间，该时间属于多项式时间，所以$TRIANGLE\\in P$","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"形式语言与计算复杂性(五)：可规约性","slug":"Math/Formal_lang/Lec5","date":"2021-07-05T12:00:00.000Z","updated":"2022-02-27T08:41:23.310Z","comments":true,"path":"2021/07/05/Math/Formal_lang/Lec5/","link":"","permalink":"http://w4ow.github.io/2021/07/05/Math/Formal_lang/Lec5/","excerpt":"Lecture 5: 可规约性","text":"Lecture 5: 可规约性 上一节课我们介绍了使用对角化方法结合反证法的手段，证明了$A_{TM}$的不可判定性。在本次课程中，我们学习另外一种证明可判定性的方法，我们称之为Reducibility可规约性。所谓的规约，是指将一个问题$A$转换成另一个问题$B$，而我们能够解决$B$，所以能够解决$A$。可以看到，规约的最重要的一环，是证明两个问题是等价的。给定一个证明可判定性的问题$A$，根据可规约性，我们可以将$A$转换为一个更简单的问题$B$： 如果$B$可规约为$A$，且$A$是可判定的，那么$B$是可判定的。 如果$B$可规约为$A$，且$B$是不可判定的，那么$A$是不可判定的。 即：简单的问题不能判定，那么难的问题更不能判定；反之，难的问题都能判定，简单的问题肯定也能判定。在上一课中我们已经证明了$A_{TM}$是不可判定的，现在我们找一些比$A_{TM}$更难的问题，并证明它们可规约为$A_{TM}$且不可判定。 1. 语言理论中的不可判定性 定理：$HALT_{TM}=\\{\\langle M,w\\rangle|M\\mathrm{\\ is\\ a\\ TM\\ and}\\ M\\ \\mathrm{halts\\ on\\ input}\\ w\\}$是不可判定的。 我们可以结合规约法和反证法来证明。一个潜在的假设是$HALT_{TM}$比$A_{TM}$难，假设$HALT_{TM}$是可判定的且我们有一个图灵机$R$可以判定它，现在我们用$R$来构造一个新的图灵机$S$来判定$A_{TM}$:$S$ = “给定输入$\\langle M,w\\rangle$，其中$M$是图灵机，$w$是字符串 1. 运行输入为$\\langle M,w\\rangle$的$R$ 2. 如果$R$返回reject，则$S$返回$reject$ ($R$是判定器，不会陷入loop，所以当$M$不在$w$上终止时，说明$M$可能陷入了loop，此时$R$会$reject$。) 3. 如果$R$ accept, 基于输入$w$模拟$M$，直到$M$终止。($R$能返回$accept$，说明$M$在$w$上能正常终止，即要么$M$能识别$w$且返回$accept$，要么$M$不能识别且返回$reject$) 4. 如果$M$ accept，则$S$返回$accept$，否则$reject$” 显然，如果$R$能判定$HALT_{TM}$，那么$S$就能判定$A_{TM}$，因为$S$不会陷入loop。而$A_{TM}$是不可判定的，所以$HALT_{TM}$是不可判定的。 定理：$E_{TM}=\\{\\langle M\\rangle|M\\mathrm{\\ is\\ a\\ TM\\ and}\\ L(M)=\\emptyset\\}$不可判定 与上面的相似，我们利用规约反证。假设$E_{TM}$是可判定的，且图灵机$R$可以判定$E_{TM}$。们利用$R$来构造一个新的图灵机$S$来判定$A_{TM}$。那么，当我们把$A_{TM}$的输入$\\langle M,w\\rangle$送给$S$，因为我们用$R$来构造$S$，因此$S$会把$\\langle M\\rangle$送给$R$，直接运行，$R$会有两种结果： $R$返回了$accept$，这时说明$L(M)$为空，所以图灵机$M$不会接受字符串$w$。 $R$返回了$reject$，这时说明$L(M)$不空，但此时我们只知道$L(M)\\not=\\emptyset$，即$M$接受了某些字符串，但$M$是否接受了$\\langle M,w\\rangle$中的$w$则不得而知了。 因此我们需要对输入进行一些修改，我们修改$\\langle M\\rangle$使得$M$只能接受字符串$w$，且$M$在$w$上能正常工作。现在修改后的$M$只能接受$w$，进而$R$只能接受$w$。形式化的，我们将修改后的$M$称为$M_1$: $M_1$ = “给定输入$x$: 1. 如果$x\\not=w$，则$M_1$返回$reject$ 2. 如果$x=w$，在$x$上运行$M$，如果$M\\ accept$，则$M_1\\ accept$” 可以看到，当且仅当$M\\ accept\\ w$(即$S\\ accepts\\ \\langle M,w\\rangle$)时，$L(M_1)\\not=\\emptyset$(即$R\\ rejects\\ \\langle M_1\\rangle$)。然后我们可以构造$S$: $S$ = “给定输入$\\langle M,w\\rangle$，其中$M$是图灵机，$w$是字符串： 1. 构造上述的$M_1$ 2. 在$R$上运行$\\langle M_1\\rangle$ 3. 如果$R\\ accept$，则$S\\ reject$，反之$accept$ 显然，如果$R$能判定$E_{TM}$，则$S$能判定$A_{TM}$ $REGULAR_{TM}=\\{\\langle M\\rangle|M\\mathrm{\\ is\\ a\\ TM\\ and}\\ L(M)\\ \\mathrm{is\\ a\\ regular\\ language}\\}$不可判定 与上面类似，我们直接给出识别$A_{TM}$的图灵机$S$： $S$ = “给定输入$\\langle M,w\\rangle$，其中$M$是图灵机，$w$是字符串： 1. 构造图灵机$M_2$： $M_2$ = 给定输入$x$: 1. 如果$x$形式为$0^n1^n$，则$M_2\\ accept$ 2. 否则，在$M$上运行$w$，如果$M\\ accept\\ w$，则$M_2\\ accept$，反之$reject$ 2. 在$R$上运行$\\langle M_2\\rangle$ 3. 如果$R\\ accept$，则$S\\ reject$，反之$accept$ $EQ_{TM}=\\{\\langle M_1,M_2\\rangle|M_1,M_2\\mathrm{\\ is\\ TMs\\ and}\\ L(M_1)=L(M_2)\\}$不可判定 这次我们换一换思路，假设$EQ_{TM}$可判定，我们来证明$E_{TM}$可判定 $S$ = “给定输入$\\langle M\\rangle$，其中$M$是图灵机： 1. 构造$M_1$，使得$M_1$拒绝所有的输入 2. 在$R$上运行$\\langle M_1\\rangle$ 3. 如果$R\\ accept$，则$S\\ accept$，反之$reject$ 2. 一个“简单的”不可判定问题在上面我们给出了4中语言不可判定的定理及其证明过程，这一节介绍另一个著名的问题，波斯特对应问题(Post correspondence Problem, PCP)。 一个多米诺形如$\\left[\\frac{a}{ab}\\right]$，它包含了上下两串字符串。而多米诺集合则是这样的多米诺的集合，形如$$\\left\\{ \\left[\\frac{a}{ab}\\right],\\left[\\frac{b}{ca}\\right],\\left[\\frac{ca}{a}\\right],\\left[\\frac{a}{ab}\\right]，\\left[\\frac{abc}{c}\\right] \\right\\}$$ 加入在一个多米诺集合中，如果我们能从中可重复的挑出若干个多米诺组成一个list，且这个list的上面的字符串等于下面的字符串，我们称这个list为一个匹配(Match)。例如在上面的多米诺集合中，我们各拿一个组成list，上面的字符串为$abcaaabc$，下面的也是$abcaaabc$，这个list就是一个匹配。PCP问题就是判断一个多米诺集合是否存在匹配。这个问题无法被任何算法解决。 我们令$P$为一个多米诺集：$$P=\\left\\{ \\left[\\frac{t_1}{b_1}\\right],\\left[\\frac{t_2}{b_2}\\right],\\cdots，\\left[\\frac{t_k}{b_k}\\right] \\right\\}$$ 令$i_1,i_2,…,i_l$是一些下标，这些下标可以使得$t_{i_1}t_{i_2}\\cdots t_{i_l}=b_{i_1}b_{i_1}\\cdots b_{i_1}$，那么$$PCP=\\{\\langle P\\rangle|P \\mathrm{\\ is\\ an\\ instance\\ of\\ the\\ PCP\\ with\\ a\\ match}\\}$$ 想要证明PCP是不可判定的，我们就需要把它和$A_{TM}$联系起来。首先，我们对PCP稍微修改一下，我们让一个匹配从第一个多米诺$\\left[\\frac{t_1}{b_1}\\right]$开始，即令$i_1=1$，这样的PCP称为MPCP。 3. 映射规约 作业 Show that $EQ_{CFG}$ is undecidable. Answer假设$EQ_{CFG}$可由图灵机$R$判定，由定理5.13可知$ALL_{CFG}$是不可判定的，我们用$R$构造图灵机$S$来判定$ALL_{CFG}$ $S$ = 给定输入$\\langle G\\rangle$，$G$是一个CFG: 构造新的CFG $G’$，使得$L(G’)=L(G)=\\Sigma^\\ast$ 用$R$来判定$\\langle G, G’\\rangle$ 如果$R\\ accept$，则$S\\ accept$，否则$S\\ reject$ 显然，如果$R$能判定$EQ_{CFG}$，那么$S$就能判定$ALL_{CFG}$，这与$ALL_{CFG}$不可判定矛盾 Find a match in the following instance of the Post Correspondence Problem.$$\\left\\{ \\left[\\frac{ab}{abab}\\right],\\left[\\frac{b}{a}\\right],\\left[\\frac{aba}{b}\\right],\\left[\\frac{aa}{a}\\right] \\right\\}$$ Answer$$\\left[\\frac{aa}{a}\\right],\\left[\\frac{aa}{a}\\right],\\left[\\frac{b}{a}\\right],\\left[\\frac{ab}{abab}\\right]$$ Show that if $A$ is Turing-recognizable and $A\\le_m \\overline{A}$, then $A$ is decidable. Answer由$A\\le_m\\overline{A}\\Leftrightarrow\\overline{A}\\le_m A$，因为$A$是图灵可识别的，根据定理5.28，$\\overline{A}$是图灵可识别的。因为$A$和$\\overline{A}$都是可是别的，根据定理4.22，$A$是可判定的。","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"形式语言与计算复杂性(四)：可判定性","slug":"Math/Formal_lang/Lec4","date":"2021-07-04T08:00:00.000Z","updated":"2022-02-27T08:41:23.294Z","comments":true,"path":"2021/07/04/Math/Formal_lang/Lec4/","link":"","permalink":"http://w4ow.github.io/2021/07/04/Math/Formal_lang/Lec4/","excerpt":"Lecture 4: 可判定性","text":"Lecture 4: 可判定性 1. 可判定性我们研究问题的可判定性，其目的是在拿到一个问题时，先看看它是否能被图灵机解决，对于无法解决的问题，我们也就没有必要花费精力去研究了。如何研究问题的可判定性呢？首先从语言的可判定性入手，如果一个语言是不可判定的，那么以该语言描述的问题肯定是不可判定的。首先，最基本的，正则语言RL和上下文无关语言CFL都是可判定的，然后我们再介绍几种可判定语言。 1.1 正则语言的可判定性 语言$A_{DFA}=\\lbrace\\langle B,w\\rangle|B\\mathrm{\\ is\\ a\\ DFA\\ that\\ accepts\\ input\\ string}\\ w\\rbrace$是可判定的。证明：首先弄清楚我们要证明的是什么，$B$是一个DFA，本质上就是一个五元组，$w$是任意的字符串。然后我们给定一个图灵机$M$，其输入是一个二元组$\\langle B,w\\rangle$，$M$要判定这个$w$能否被这个$B$所识别，如果能识别，则$M$返回$accpet$，否则$reject$。搞清楚了这个，我们就可以构造一个$M$来判定$A_{DFA}$ $M$ = “给定输入$\\langle B,w\\rangle$，其中$B$是DFA，$w$是字符串： 首先$M$检查$B$和$w$是否是合法的，不是合法的则直接返回$reject$ 使用$M$来模拟$B$，且输入是$w$ 开始时$B$的状态是$q_0$，且当前输入位置为$w$的最左边 根据$B$的状态转移函数$\\delta$更新$M$的状态和输入位置 如果模拟完成后，$M$处于$B$的接受状态，则$M$返回$accept$；当$M$不处于$B$的接受状态，则$reject$” 语言$A_{NFA}=\\lbrace\\langle B,w\\rangle|B\\mathrm{\\ is\\ a\\ NFA\\ that\\ accepts\\ input\\ string}\\ w\\rbrace$是可判定的。证明：因为任意NFA都有一个等价的DFA，而我们在上面已经证明了图灵机$M$可以判定$A_{DFA}$，因此我们利用$M$进行证明： $N$= “给定输入$\\langle B,w\\rangle$，其中$B$是NFA，$w$是字符串： 首先将NFA $B$转换为等价的DFA $C$ 使用上面的图灵机$M$来模拟$C$，输入信号为$w$ 如果模拟结束时，$N$处在接受状态，则$accpet$，否则$reject$” 语言$A_{REX}=\\lbrace\\langle R,w\\rangle|B\\mathrm{\\ is\\ a\\ regular\\ expression\\ that\\ generate\\ string}\\ w\\rbrace$是可判定的。证明：同样的，任意正则表达式都可转换为NFA： $P$= “给定输入$\\langle R,w\\rangle$，其中$R$是正则表达式，$w$是字符串： 首先将$R$转换为等价的NFA $A$ 使用上面的图灵机$N$来模拟$A$，输入信号为$w$ 如果模拟结束时，$P$处在接受状态，则$accpet$，否则$reject$” 语言$E_{DFA}=\\lbrace\\langle A\\rangle|A\\mathrm{\\ is\\ a\\ DFA\\ and}\\ L(A)=\\emptyset\\rbrace$是可判定的(即一个不能识别任何字符串的DFA $A$)证明 $T$ = “给定输入$\\langle A\\rangle$，其中$A$是一个DFA： 首先标记$A$的开始状态 利用图灵机$T$反复标记那些由已标记状态能够到达的状态 如果没有任何一个$A$的接受状态被标记，则$T$返回$accept$，否则$reject$” 语言$EQ_{DFA}=\\lbrace\\langle A,B\\rangle|A\\ \\mathrm{and}\\ B\\mathrm{\\ are\\ DFAs\\ and}\\ L(A)=L(B)\\rbrace$是可判定的证明直接证明有一定的难度，因此我们需要对其进行转换，因为上面已经证明了$E_{DFA}$是可以判定的，因此我们可以尝试将问题转换为$E_{DFA}$，即构造某种语言且该语言的自动机不能识别任何字符串。 $F$ = “给定输入$\\langle A,B\\rangle$，其中$A$和$B$是DFA 我们构造一个新的DFA $C$，使得$L(C)=(L(A)\\cap\\overline{L(B)})\\cup(\\overline{L(A)}\\cap L(B))$，因为FA具有封闭性，因此$C$依然是一个DFA 利用图灵机$T$模拟$C$ 如果$T$返回$accept$，则$F$返回$accept$，否则$reject$. 1.2 上下文无关语言的可判定性 语言$A_{CFG}=\\lbrace\\langle G,w\\rangle|G\\mathrm{\\ is\\ a\\ CFG\\ that\\ generates\\ string}\\ w\\rbrace$是可判定的。证明我们可以用图灵机模拟CFG，从开始变量一直推导，看看能否产生$w$，但是因为推导过程中可能产生循环，因此推导过程可能是无限的。我们必须转换思路，一种可行的办法是将CFG转换为CNF，而从一个CNF推导出一个字符串$w$只要$2n-1$步，因此不会陷入循环。说明一下，因为CNF只有两种形式的规则，假设目标字符串$w$的长度为$n$，从开始变量$S$开始，推导出一个长度为$n$且全为变量的字符串需要$n-1$步，然后将这$n$个变量变成终结符需要$n$步，因此共计$2n-1$步。 $S$ = “给定输入$\\langle G,w\\rangle$，其中$G$是CFG，$w$是字符串 将$G$转换为CNF形式 列出所有在$2n-1$步内能够推导出的字符串，其中$n=|w|$。如果$n=0$，那么列出所有一步能推导出的字符串。 如果这些字符串中存在$w$，则$S$返回$accept$，否则$reject$. 由$A_{CFG}$的可判定性我们也可以得到定理： 定理：所有的上下文无关语言都是可判定的因为所有的上下文无关语言都有等价的CFG，我们可以构造上下文无关语言的CFG，并利用图灵机$S$来进行判定。 语言$E_{CFG}=\\lbrace\\langle G\\rangle|G\\mathrm{\\ is\\ a\\ CFG\\ and}\\ L(G)=\\emptyset\\rbrace$是可判定的(即一个不能生成任何字符串的CFG $G$)证明我们可以利用上面的图灵机$S$，枚举所有可能的字符串，并查看图灵机能否生成该字符串，如果所有的字符串都不能生成，则$accept$。但是枚举所有的字符串是不可行的，因此我们需要换个思路。 $R$ = “给定输入$\\langle G\\rangle$，其中$G$是一个CFG： 首先标记$G$的所有终结符 利用图灵机$R$利用右边规则反复标记变量：对于$G$中的规则$A\\to U_1U_2\\cdots U_k$，如果$U_1,…,U_k$都被标记了，那么标记变量$A$ 如果开始变量没有被标记，则$R$返回$accept$，否则$reject$” 语言$EQ_{CFG}=\\lbrace\\langle G,H\\rangle|G\\ \\mathrm{and}\\ H\\mathrm{\\ are\\ CFGs\\ and}\\ L(G)=L(H)\\rbrace$是不可判定的DFA之所以能判定，是因为FA具有封闭性，因此可以构造等价的DFA $C$，但是上下文无关语言不具有封闭性。 最后我们给出RL、DFL和可判定语言之间的关系。 2. 不可判定性在上图中我们了解到，有许多语言是图灵机可识别但不可判定的，例如语言$A_{TM}=\\lbrace\\langle M,w\\rangle|M\\mathrm{\\ is\\ a\\ TM\\ and}\\ M\\ \\mathrm{accepts}\\ w\\rbrace$是图灵可识别但不可判定的：我们可以利用一台图灵机$N$来模拟图灵机$M$，如果$M$返回$accept$则$N$返回$accept$，但是，由于$M$中可能存在循环，所以是不可判定的。在这一节中，我们将学习一些数学理论，用于判断一个语言是否是可判定的。 2.1 映射与可数性首先我们了解三种映射：单射、满射与双射。假设我们有两个集合$A$和$B$，以及一个函数$f$可以将$A$中的元素$x$映射到$B$中的元素$y$，我们称$f$为： 单射injective, one-to-one：$f:A\\to B$是单射的当且仅当对所有的$a,b\\in A$，有$f(a)=f(b)\\Rightarrow a=b$ 满射surjective, onto：$f:A\\to B$是满射的当且仅当对所有的$b\\in B$，存在$a\\in A$满足$f(a)=b$ 双射bijective, correspondence：$f:A\\to B$是双射的当且仅当对所有的$b\\in B$，存在唯一的$a\\in A$满足$f(a)=b$ 如果存在满射函数$f$使得$f:A\\to B$，则我们称$A$和$B$的尺寸是相同的，例如，令$y=f(x)=2x$，自然数集$\\mathcal{N}=\\lbrace1,2,3,…\\rbrace$和正偶数集合$\\Lambda=\\lbrace2,4,6,…\\rbrace$的尺寸是相同的。 可数的：如果一个集合的元素是有限的或者其尺寸和自然数集$\\mathcal{N}$相等，则称其为可数的。 例如，集合$Q=\\lbrace\\frac{m}{n}|m,n\\in\\mathcal{N}\\rbrace$是可数的，我们可以按下图方式把所有的$\\frac{m}{n}$都列出来： 即第一行是所有分子为$1$的数，第二行是所有分子为$2$的数，以此类推。可以看到，每一行每一列都有无穷个数，但是我们可以按照图中箭头方向将数进行排列，使其对应到$\\mathcal{N}$，即$f(1)=\\frac{1}{1}$，$f(2)=\\frac{2}{1}$，$f(3)=\\frac{1}{2}$，以此类推。注意，因为$\\frac{1}{1}$和$\\frac{2}{2}$相等，所以我们排除$\\frac{2}{2}$，其他相等的数同样需要排除。按照此方法，我们可以构造一个映射函数$f$将$Q$和$\\mathcal{N}$一一对应，所以$Q$是可数的。 可以看到，尽管$Q$和$\\mathcal{N}$都有无穷个元素，我们照样将其称为可数的，但对有些无穷集，因其尺寸不等于$\\mathcal{N}$，我们称其为不可数的，最典型的就是实数集$\\mathcal{R}$。我们可以利用反证法来证明$\\mathcal{R}$是不可数的。假设$\\mathcal{R}$是可数的，那么必定存在一个映射$f$使得$\\mathcal{R}$和$\\mathcal{N}$的元素一一对应。假设$f$是确定的，那么对应的$f(\\mathcal{N})$也是确定的，假设元素$1$对应的元素是$f(1)=3.14159$，同样$2$对应$f(2)=55.5555$，以此类推，如下表所示，第一列是$\\mathcal{N}$，第二列是$\\mathcal{R}$。现在我们构造一个$x\\in\\mathcal{R}$，并证明$x$不对应任何自然数$n\\in\\mathcal{N}$。 我们想要构造一个$x$使得$x\\not=f(n)$，我们假设$x$是一个$0$和$1$之间的小数。首先，为了保证$x\\not=f(1)$，我们让$x$的十分位不等于$f(1)$的十分位，$f(1)$的十分位是$1$，所以我们可以随便取个不为$1$的数，假设取$4$。同样的，为了$x\\not=f(2)$，我们取$x$的千分位为$6$，以此类推。因为$x$的第$n$位小数与$f(n)$的第$n$位小数不同，所以$x\\not=f(n)$，即不存在任意一个$n$，能够使得$f(n)=x$，也就是$x$对应不到任意一个$n$，所以$\\mathcal{R}$和$\\mathcal{N}$不是双射，所以$\\mathcal{R}$不可数。 2.2 非图灵可识别语言接下来，我们证明一个重要的推论： 推论：有些语言不是图灵可识别的。 证明： 假设所有的语言都是图灵可识别的，那么所有的图灵机的集合和所有的语言的集合应当有相同的尺寸，接下来，我们证明两者的尺寸并不相同，更具体的说，图灵机集是可数的，语言集是不可数的。 因为没一个图灵机$M$都可以编码为一个字符串$\\langle M\\rangle$，而所有的字符串集合是可数的(可以与$\\mathcal{N}$一一对应)，因此图灵机集是可数的。 令语言集为$\\mathcal{L}$，我们接下来证明$\\mathcal{L}$不可数 无限二进制序列是一个由$0$和$1$组成的、长度无限的二进制序列，令$\\mathcal{B}$为无限二进制序列集合。$\\mathcal{B}$是不可数的，其证明过程与$\\mathcal{R}$相同(即取第$i$位与$f(i)$的第$i$位不同)。 首先，我们证明$\\mathcal{L}$和$\\mathcal{B}$之间存在双射$f$。 我们假设$\\mathcal{L}$的字母表为$\\Sigma$，我们令字母表幂集为$\\Sigma^\\ast=\\lbrace s_1,s_2,…\\rbrace$，显然$\\Sigma^\\ast$是一个无限集。 每个语言$A\\in\\mathcal{L}$在$\\mathcal{B}$中都有唯一的被称为特征序列的序列$\\mathcal{X}_A$，当$s_i\\in A$时，我们令$\\mathcal{X}_A$的第$i$位为$1$,否则为$0$。例如，假设字母表为$\\Sigma=\\lbrace0,1\\rbrace$，且给定$A$如下，则$A$的特征序列$\\mathcal{X}_A$如图所示，显然，$\\mathcal{X}_A$是一个无限二进制序列。 因此，存在一个$f:\\mathcal{L}\\to\\mathcal{B}$，其中$f(A)$等于$A$的特征序列，使得$\\mathcal{L}$和$\\mathcal{B}$是双射的。 因为$\\mathcal{L}$和$\\mathcal{B}$是一一对应的，而$\\mathcal{B}$是不可数的，因此$\\mathcal{L}$是不可数的 因为图灵机集可数，而语言集不可数，所以有些语言不是图灵可识别的。 2.3 一个重要的不可判定语言 定理：语言$A_{TM}=\\lbrace\\langle M,w\\rangle|M\\mathrm{\\ is\\ a\\ TM\\ and}\\ M\\ \\mathrm{accepts}\\ w\\rbrace$是不可判定的。 2.3.1 反证法证明证明我们假设$A_{TM}$是可判定的，并且存在一个图灵机$H$可以判定$A_{TM}$。给定输入字符串$\\langle M,w\\rangle$，$M$是一个图灵机而$w$是一个字符串，当$M$返回$accept$时$H$也返回$accept$，否则$reject$，如下式：$$H(\\langle M,w\\rangle) = \\begin{cases} accept &amp; \\mathrm{if}\\ M\\ \\mathrm{accepts}\\ w \\\\ reject &amp; \\mathrm{if}\\ M\\ \\mathrm{does\\ not\\ accepts}\\ w\\end{cases}$$ 我们构建一个新的图灵机$D$，且$D$调用$H$作为自己的子程序，我们让$D$判断一件特殊的事情：我们令$w=\\langle M\\rangle$，并输入到$M$。随后我们在$D$上运行$H$来判定$M$能否判定$\\langle M\\rangle$，且$D$返回$M$的相反结果，即当$M$返回$accept$时$D$返回$reject$，$M$返回$reject$时$D$返回$accept$。下面是$D$的正式描述： $D$ = “给定输入$\\langle M\\rangle$，其中$M$是一个图灵机： １. 运行输入为$\\langle M,\\langle M\\rangle\\rangle$的图灵机$H$ ２. 当$H$返回$accept$时，$D$返回$reject$，当$H$返回$reject$时，$D$返回$accept$” 即 $$D(\\langle M\\rangle) = \\begin{cases} accept &amp; \\mathrm{if}\\ M\\ \\mathrm{does\\ not\\ accepts}\\ \\langle M\\rangle \\\\ reject &amp; \\mathrm{if}\\ M\\ \\mathrm{accepts}\\ \\langle M\\rangle\\end{cases}$$ 那么，如果我们将$D$的描述$\\langle D\\rangle$送到$D$中运行，会发生什么呢？$$D(\\langle D\\rangle) = \\begin{cases} accept &amp; \\mathrm{if}\\ D\\ \\mathrm{does\\ not\\ accepts}\\ \\langle D\\rangle \\\\ reject &amp; \\mathrm{if}\\ D\\ \\mathrm{accepts}\\ \\langle D\\rangle\\end{cases}$$ 不管$D$是什么样的，出现这种情况都是很荒谬的，因此上述定理得以证明。 2.3.2 对角化我们可以利用对角化的思想更形象的阐述上面的证明过程。首先，$M$，$H$和$D$还是和上一小节一样定义，然后我们可以画一个表，该表的列是世界上所有的图灵机，行则是这图灵机所对应的描述。如果图灵机$M_i$能识别字符串$\\langle M_j\\rangle$，则将表的$(i,j)$置为$accept$，如果$M_i$不能识别(即$M_i$返回$reject$或陷入循环)，则将表的$(i,j)$置为$reject$。因为该表列出了所有的图灵机，而$D$也是图灵机，所以$D$肯定是这些列出的图灵机中的一个，然后，根据上面我们对$D$的构造，它返回相反的结果，即当$M_i$对$\\langle M_i\\rangle$返回$accept$时，$D$对$\\langle M_i\\rangle$返回$reject$，则我们可以得到如下的表：问题来的，我们无法标出?处。 2.4 图灵不可识别语言除了图灵不可判定语言之外，还有一些语言甚至是图灵不可识别的。我们首先定义co-Turing-recognizable为一个图灵可识别语言的补集，注意，一个语言是一个字符串集合，其co-Turing-recognizable，是这个集合的补集，而不是图灵不可识别语言，而且 定理:一个语言是可判定的当且仅当它是图灵可识别的且它的补集也是图灵可识别的(co-Turing-recognizable)。 首先我们来证明，如果一个语言$A$是可判定的，那么它和它的补集都是图灵可识别的。首先，$A$都是可判定的了，那么肯定是图灵可识别的。其次，对$A$的补集$\\overline{A}$，我们可以构造衣蛾可以判定$A$的图灵机，用它来判定$\\overline{A}$，且返回相反的结果，所以可判定语言的补集也是可判定的，当然也是可识别的 接下来证明，如果一个语言和它的补集都是图灵可识别的，那么该语言是可判定的。我们构造两个图灵机，$M_1$可以识别$A$，$M_2$可以识别$\\overline{A}$，那么我们可以构造一个新的图灵机$M$: $M$ = “给定输入$w$ 1. 在$M_1$和$M_2$上并行运行输入$w$ 2. 如果$M_1$返回accept，则$M$返回$accept$；如果$M_2$返回reject，则$M$返回$reject$” 显然，这样的机器能够$accept$语言$A$，并且$reject$语言$\\overline{A}$，即$A$是可判定的 根据上面的定理，我们可以得到推论：$\\overline{A_{TM}}$不是图灵可识别的。因为$A_{TM}$是图灵可识别的，若$\\overline{A_{TM}}$也是图灵可识别的，那$A_{TM}$就是图灵可判定的了，这显然是矛盾的。 作业 Answer all parts for the following DFA $M$ and give reasons for your answers. Answer 1. 是，因为$M$能识别$0100$ 2. 否，$M$不能识别$011$ 3. 否，$A_{DFA}$的输入应形如$\\langle M,w\\rangle$，所以输入格式不正确 4. 否，$A_{REX}$输入的第一元应当为正则表达式而不是图灵机，输入格式不正确 5. 否，$E_{DFA}$要求$L(M)=\\emptyset$，显然这里的$L(M)\\not=\\emptyset$ 6. 是，$EQ_{DFA}$要求$L(A)=L(B)$，显然这里$L(M)=L(M)$ Let $ALL_{DFA}=\\lbrace\\langle A\\rangle|A\\mathrm{\\ is\\ a\\ DFA\\ and\\ }L(A)=\\Sigma^\\ast\\rbrace$. Show that $ALL_{DFA}$ is decidable. Answer构造一个新的TM $P$$P$ = “给定输入$\\langle A\\rangle$，其中$A$是一个DFA： １. 构造一个新的DFA $B$，且$B$所识别的语言$L(B)=\\overline{L(A)}$ ２. 使用自动机$T$来判定基于输入$\\langle B\\rangle$的$E_{DFA}$ ３. 如果$T$返回accept，则$P$返回$accept$，否则$T$返回$reject$ Let $X$ be the set $\\{1, 2, 3, 4, 5\\}$ and $Y$ be the set $\\{6, 7, 8, 9, 10\\}$. We describe the functions $f:X\\to Y$ and $g:X\\to Y$ in the following tables. Answer each part and give a reason for each negative answer. Answer$$\\begin{aligned} &amp; \\mathbf{a}. 否 f(2)=f(4) &amp; \\mathbf{d}. 是 \\\\ &amp; \\mathbf{b}. 否 Y中的8、9、10没有对应的x\\in X &amp; \\mathbf{e}. 是 \\\\ &amp; \\mathbf{c}. 否 &amp; \\mathbf{f}. 是\\end{aligned}$$ Let $\\mathcal{B}$ be the set of all infinite sequences over $\\{0,1\\}$. Show that $\\mathcal{B}$ is uncountableusing a proof by diagonalization. Answer 假设$\\mathcal{B}$是可数的，那么必定存在一个映射$f$使得$\\mathcal{B}$和$\\mathcal{N}$的元素一一对应。假设元素$1\\in\\mathcal{N}$对应的元素是$f(1)=01000\\cdots$，$2$对应$f(2)=00010\\cdots$，以此类推，如下表所示，第一列是$\\mathcal{N}$，第二列是$\\mathcal{B}$。现在我们构造一个$x\\in\\mathcal{B}$，使其第一位不等于$f(1)$的第一位，即令$x$的第一位为$1$，同样的，$x$的第二位不等于$f(2)$的第二位，令$x$的第二位为$1$，以此类推。 $n$ $f(n)$ $1$ $\\underline{0}1000\\cdots$ $2$ $0\\underline{0}010\\cdots$ $3$ $10\\underline{0}00\\cdots$ $4$ $000\\underline{0}0\\cdots$ $\\vdots$ $\\vdots$ 构造出的$x=1111\\cdots$，因为$x$的第$n$位与$f(n)$的第$n$位不同，所以$x\\not=f(n)$，即不存在$n$使得$f(n)$等于$x$，故而不存在双射$f:\\mathcal{N}\\to\\mathcal{B}$，故而$\\mathcal{B}$不可数。","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"形式语言与计算复杂性(三)：Church-Turing","slug":"Math/Formal_lang/Lec3","date":"2021-06-29T06:00:00.000Z","updated":"2022-02-27T08:41:23.293Z","comments":true,"path":"2021/06/29/Math/Formal_lang/Lec3/","link":"","permalink":"http://w4ow.github.io/2021/06/29/Math/Formal_lang/Lec3/","excerpt":"Lecture 3: Church-Turing","text":"Lecture 3: Church-Turing 作业 This exercise concerns TM $M_2$ , whose description and state diagram appear in Example 3.7. In each of the parts, give the sequence of configurations that $M_2$ enters when started on the indicated input string. $0.$ $00.$ $000.$ $000000.$ Answer $M_2\\ decides\\ A=\\lbrace0^{2^n}|n\\ge0\\rbrace$，此题需要对照状态转移图作答，我们以$\\dot{\\Gamma}$表示图灵机针头所要读取的磁带上下一个字符。 $q_1\\dot{0}, \\sqcup q_2\\dot{\\sqcup}, \\sqcup\\sqcup q_{accept}$ $q_1\\dot{0}0, \\sqcup q_2\\dot{0}\\sqcup, \\sqcup xq_3\\dot{\\sqcup}, \\sqcup q_5\\dot{x}\\sqcup, q_5\\dot{\\sqcup} x\\sqcup, \\sqcup q_2\\dot{x}\\sqcup, \\sqcup xq_2\\dot{\\sqcup}, \\sqcup x\\sqcup q_{accept}$ $q_1\\dot{0}00, \\sqcup q_2\\dot{0}0, \\sqcup x q_3\\dot{0}\\sqcup, \\sqcup x0q_4\\dot{\\sqcup}, \\sqcup x0\\sqcup q_{reject}$ $$\\begin{aligned} &amp; q_1\\dot{0}00000 &amp; \\sqcup x0x0q_4\\dot{0}\\sqcup \\qquad &amp; \\sqcup xq_5\\dot{0}x0x\\sqcup &amp; \\sqcup xxq_3\\dot{x}0x\\sqcup \\\\ &amp; \\sqcup q_2\\dot{0}0000 &amp; \\sqcup x0x0xq_3\\dot{\\sqcup} \\qquad &amp; \\sqcup q_5\\dot{x}0x0x\\sqcup &amp; \\sqcup xxxq_3\\dot{0}x\\sqcup \\\\ &amp; \\sqcup x q_3 \\dot{0}000 &amp; \\sqcup x0x0q_5\\dot{x}\\sqcup \\qquad &amp; q_5\\dot{\\sqcup}x0x0x\\sqcup &amp; \\sqcup xxxxq_4\\dot{x}\\sqcup \\\\ &amp; \\sqcup x0q_4\\dot{0}00 &amp; \\sqcup x0xq_5\\dot{0}x\\sqcup \\qquad &amp; \\sqcup q_2\\dot{x}0x0x\\sqcup &amp; \\sqcup xxxxxq_4\\dot{\\sqcup} \\\\ &amp; \\sqcup x0xq_3\\dot{0}0 &amp; \\sqcup x0q_5\\dot{x}0x\\sqcup \\qquad &amp; \\sqcup xq_2\\dot{0}x0x\\sqcup &amp; \\sqcup xxxxx\\sqcup q_{reject} \\\\\\end{aligned}$$ This exercise concerns TM $M_1$ , whose description and state diagram appear in Example 3.9. In each of the parts, give the sequence of configurations that $M_1$ enters when started on the indicated input string. $11.$ $1\\#1.$ $1\\#\\#1.$ $10\\#11.$ $10\\#10.$ Answer 此题同样需要对照状态转移图作答。 $$\\begin{aligned}&amp; q_1\\dot{1}1 \\\\&amp; xq_3\\dot{1}\\sqcup \\\\&amp; x1q_3\\dot{\\sqcup} \\\\&amp; x1\\sqcup q_{reject} \\\\\\end{aligned}$$ $$\\begin{aligned} &amp; q_1\\dot{1}\\# 1 &amp; xq_1\\dot{\\# }x \\\\ &amp; xq_3\\dot{\\# }1 &amp; x\\# q_8\\dot{x} \\\\ &amp; x\\# q_5\\dot{1} &amp; x\\# xq_8\\dot{\\sqcup} \\\\ &amp; xq_6\\dot{\\# }x &amp; x\\# x\\sqcup q_{accept} \\\\ &amp; q_7\\dot{x}\\# x \\\\\\end{aligned}$$ $$\\begin{aligned} &amp; q_1\\dot{1}\\#\\# 1 \\\\ &amp; xq_3\\dot{\\# }\\# 1 \\\\ &amp; x\\# q_5\\dot{\\# }1 \\\\ &amp; x\\#\\# q_{reject}1 \\\\\\end{aligned}$$ $$\\begin{aligned} &amp; q_1\\dot{1}0\\# 11 &amp; q_7\\dot{x}0\\# x1 \\\\ &amp; xq_3\\dot{0}\\# 11 &amp; xq_1\\dot{0}\\# x1 \\\\ &amp; x0q_3\\dot{\\# }11 &amp; xxq_2\\dot{\\# }x1 \\\\ &amp; x0\\# q_5\\dot{1}1 &amp; xx\\# q_4\\dot{x}1 \\\\ &amp; x0q_6\\dot{\\# }x1 &amp; xx\\# xq_4\\dot{1} \\\\ &amp; xq_7\\dot{0}\\# x1 &amp; xx\\# x1q_{reject}\\sqcup \\\\\\end{aligned}$$ $$\\begin{aligned} &amp; q_1\\dot{1}0\\# 10 &amp; xq_7\\dot{0}\\# x0 \\qquad &amp; xx\\# xq_4\\dot{0} &amp; xx\\# q_8\\dot{x}x \\\\ &amp; xq_3\\dot{0}\\# 10 &amp; q_7\\dot{x}0\\# x0 \\qquad &amp; xx\\# q_6\\dot{x}x &amp; xx\\# xq_8\\dot{x}\\sqcup \\\\ &amp; x0q_3\\dot{\\# }10 &amp; xq_1\\dot{0}\\# x0 \\qquad &amp; xxq_6\\dot{\\# }xx &amp; xx\\# xxq_8\\dot{\\sqcup} \\\\ &amp; x0\\# q_5\\dot{1}0 &amp; xxq_2\\dot{\\# }x0 \\qquad &amp; xq_7\\dot{x}\\# xx &amp; xx\\# xx\\sqcup q_{accept} \\\\ &amp; x0q_6\\dot{\\# }x0 &amp; xx\\# q_4\\dot{x}0 \\qquad &amp; xxq_7\\dot{\\# }xx \\\\\\end{aligned}$$ Explain why the following is not a description of a legitimate Turing machine. $M_{bad}$=”On input $\\left\\langle p\\right\\rangle$, a polynomial over variables $x_1,…,x_k$: Try all possible settings of $x_1,…,x_k$ to integer values. Evaluate p on all of these settings. If any of these settings evaluates to 0, accept ; otherwise, reject .” Answer 根据Matijasevic̆定理，我们无法为多变量的多项式表达式的每个变量计算bound，因此我们需要枚举每个变量的所有可能的值，这在时间上是不可接受的，甚至会陷入loop。一种似乎可行的图灵机是$k$-磁带图灵机，每条磁带$i$枚举变量$x_i$的可能值。不过这个图灵机的根本问题在于枚举所有可能解的组合所需要的时间是无穷的。 Give implementation-level descriptions of Turing machines that decide the following languages over the alphabet $\\lbrace0,1\\rbrace$. $\\lbrace w|w\\ \\mathrm{contains\\ an\\ equal\\ number\\ of}\\ 0s\\ \\mathrm{and}\\ 1s\\rbrace$ $\\lbrace w|w\\ \\mathrm{contains\\ twice\\ as\\ many}\\ 0s\\ \\mathrm{as}\\ 1s\\rbrace$ $\\lbrace w|w\\ \\mathrm{does\\ not\\ contain\\ twice\\ as\\ many}\\ 0s\\ \\mathrm{as}\\ 1s\\rbrace$ Answer On input string $w$: Repeat the following two steps:a. Scan the tape and mark the first unmarked $1$. If has no unmarked $1$, jump to step 2, else, move the head back to headmost.b. Scan the tape and mark the first unmarked $0$. If has no unmarked $0$, $reject$, else, move the head back to headmost. Move the head back to headmost and scan the tape. If has unmarked $0$s, $reject$, else, $accept$. On input string $w$: Repeat the following two steps:a. Scan the tape and mark first two unmarked $0$s. If has no unmarked $0$, jump to step 2, else if has noly one unmarked $0$, $reject$, else, move the head back to headmost.b. Scan the tape and mark the first unmarked $1$. If has no unmarked $1$, $reject$, else, move the head back to headmost. Move the head back to headmost and scan the tape. If has unmarked $1$s, $reject$, else, $accept$. On input string $w$: Repeat the following two steps:a. Scan the tape and mark first two unmarked $0$. If has no unmarked $0$, jump to step 2, else if has noly one unmarked $0$, $accept$, else, move the head back to headmost.b. Scan the tape and mark the first unmarked $1$. If has no unmarked $1$, $accept$, else, move the head back to headmost. Move the head back to headmost and scan the tape. If has unmarked $1$s, $accept$, else, $reject$.","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"形式语言与计算复杂性(二)：上下文无关语言","slug":"Math/Formal_lang/Lec2","date":"2021-06-27T07:00:00.000Z","updated":"2022-02-27T08:41:23.224Z","comments":true,"path":"2021/06/27/Math/Formal_lang/Lec2/","link":"","permalink":"http://w4ow.github.io/2021/06/27/Math/Formal_lang/Lec2/","excerpt":"Lecture 2: 上下文无关语言","text":"Lecture 2: 上下文无关语言 1. 上下文无关文法在这一节课中，我们将介绍表达能力更强、形式也更复杂的语言——上下文无关语言。上下文无关语言(Context Free Language, CFL)是由根据上下文无关文法所生成的字符串的集合，上下文无关文法(Contex-Free Grammars, CFG)是有一系列替换规则组成的语法规则，每个替换规则由终结符和非终结符组成。非终结符，亦称为变量，是可以被替换的。例如下例是一个CFG。 $$\\begin{aligned} &amp;A \\to 0A1 \\\\ &amp;A \\to B \\\\ &amp;B \\to \\# \\end{aligned}$$ 使用上下文无关文法，我们可以生成符合文法的字符串，例如使用上面描述的文法可以生成字符串$000\\#111$，$A\\Rightarrow0A1\\Rightarrow00A11\\Rightarrow000A111\\Rightarrow000B111\\Rightarrow000\\#111$，对应的解析树如图所示。我们将根据该文法生成的所有字符串组成的集合称为该语法的语言，即$\\lbrace w\\in\\Sigma^\\ast|A\\stackrel{\\ast}{\\Rightarrow} w\\rbrace$。 1.1 CFG的定义 一个上下文无关文法CFG是一个四元组$(V,\\Sigma,R,S)$，其中 $V$是变量集合 $\\Sigma$是终结符集合 $R$是规则集 $S\\in V$是开始变量 从定义上看，CFG与FA相比十分类似，例如CFG的变量集等价于FA的符号集$\\Sigma$，CFG的规则集$R$等价于FA的转移函数$\\delta$。不过，两者不同的地方更多，例如CFG的终结符集$\\Sigma$中的元素不可再被推导。 此外，还有两个比较重要的概念： Yield，也就是直接推导，即能从$uAw$直接通过一步得到$uvw$ Derives，是间接推导，即通过若干个步骤:$u\\stackrel{\\ast}{\\Rightarrow}v=u\\Rightarrow u_1\\Rightarrow u_2 \\Rightarrow\\cdots\\Rightarrow u_k\\Rightarrow v$ 1.2 CFG的歧义性首先我们来认识一下最左推导： 给定文法$G$，一个字符串$w$的最左推导是指，每次推导步骤中最先替换最左边的变量。 CFG中所谓的歧义性，是指一个语法能通过不同的方式生成同一个字符串，即有多个不同的最左推导。对这样的语法，我们称其为有歧义的语法。下图是一个有歧义的语法的例子，两种不同的最左推导可以产生同样的字符串。 1.3 Chomsky Normal Form所谓的Chomsky Normal Form(CNF)，是一种形式上极其简单的CFG，其规则集$R$仅包含两种形式 $$\\begin{aligned} &amp;A \\to BC \\\\ &amp;A \\to a\\end{aligned}$$ 其中$A,B,C$是任意变量，且$B,C$不能是开始符，$a$是终结符。除了这两种形式之外，有时会允许出现$S\\to\\varepsilon$这个特殊的规则，其中$S$是开始符。基于CNF，我们可以跟好的研究CFG与CFL之间的等价性： 定理所有的上下文无关语言都是由CNF形式的CFG生成的 因为CFL是由CFG生成的，即CFL$\\equiv$CFG，而接下来我们将给出将任意CFG转换为CNF的方法，该方法证明了CNF$\\equiv$CFG，因此上述定理也被证明了： 添加一个新的开始符$S_0$，并添加新规则$S_0\\to S$，即新开始符yield旧开始符。该步骤保证了新开始符不会出现在规则的右边 删除所有的涉及到非开始符的$\\varepsilon$规则，即形如$A\\to\\varepsilon$的规则 如果存在规则$R\\to uAv$，则在删除上述规则的同时添加$R\\to uv$ 同样的，如果存在规则$R\\to A$，则添加规则$R\\to\\varepsilon$(若之前删除过$R\\to\\varepsilon$则不添加) 删除所有的形如$A\\to B$的规则，当存在规则$B\\to u$时，添加规则$A\\to u$(若之前删除过$A\\to u$则不添加，$u$可以为变量或终结符) 将剩下的规则转换为合适的形式 将规则$A\\to u_1u_2\\cdots u_k$($k\\ge3$，$u_i$可以是终结符或变量)替换为多个规则：$A\\to u_1A_1,A_1\\to u_2A_2,…,A_{k-2}=u_{k-1}u_k$ 对所有的终结符$v_i$，将其替换为变量$V_i$并添加规则$V_i=v_i$ 下面，我们通过一个例子将CFG转换为CNF形式： $$\\begin{aligned} &amp; S \\to ASA|aB \\\\ &amp; A \\to B|S \\\\ &amp; B \\to b|\\varepsilon\\end{aligned}$$ 添加新的开始符$$\\begin{aligned} &amp; S_0 \\to S \\\\ &amp; S \\to ASA|aB \\\\ &amp; A \\to B|S \\\\ &amp; B \\to b|\\varepsilon\\end{aligned}$$ 删除$\\varepsilon$规则$$\\begin{aligned} &amp; S_0 \\to S \\\\ &amp; S \\to ASA|aB|a \\\\ &amp; A \\to B|S|\\varepsilon \\\\ &amp; B \\to b\\end{aligned}$$ $$\\begin{aligned} &amp; S_0 \\to S \\\\ &amp; S \\to ASA|aB|a|SA|AS|S \\\\ &amp; A \\to B|S \\\\ &amp; B \\to b\\end{aligned}$$ 删除形如$A\\to B$的规则$$\\begin{aligned} &amp; S_0 \\to S \\\\ &amp; S \\to ASA|aB|a|SA|AS \\\\ &amp; A \\to B|S \\\\ &amp; B \\to b\\end{aligned}$$ $$\\begin{aligned} &amp; S_0 \\to ASA|aB|a|SA|AS \\\\ &amp; S \\to ASA|aB|a|SA|AS \\\\ &amp; A \\to B|S \\\\ &amp; B \\to b\\end{aligned}$$ $$\\begin{aligned} &amp; S_0 \\to ASA|aB|a|SA|AS \\\\ &amp; S \\to ASA|aB|a|SA|AS \\\\ &amp; A \\to b|ASA|aB|a|SA|AS \\\\ &amp; B \\to b\\end{aligned}$$ 转换为合适的形式$$\\begin{aligned} &amp; S_0 \\to AA_1|UB|a|SA|AS \\\\ &amp; S \\to AA_1|UB|a|SA|AS \\\\ &amp; A \\to b|AA_1|UB|a|SA|AS \\\\ &amp; A_1 \\to SA \\\\ &amp; U \\to a \\\\ &amp; B \\to b\\end{aligned}$$ 2. Pushdown Automata2.1 定义正如正则语言可以被FA识别，CFG也可以被一种特殊的自动机所识别，即所谓的Pushdown Automata(PDA)，就是比NFA多了一个栈的自动机： 一个PDA是一个六元组$(Q,\\Sigma, \\Gamma, \\sigma, q_0, F)$，其中 $Q$是状态的有限集 $\\Sigma$是输入字母表的有限集 $\\Gamma$是栈字母表的有限集 $Q\\times \\Sigma_\\varepsilon\\times\\Gamma_\\varepsilon\\to\\mathcal{P}(Q\\times\\Gamma_\\varepsilon)$是转移函数，可以看到转移后得到的是状态集 $q_0\\in Q$是开始状态 $F\\subseteq Q$是终止状态集 PDA与FA相比，其能力更为强大，可以识别NFA无法识别的上下文无关语言，如$\\lbrace 0^n1^n|n\\ge0\\rbrace$： 在这个PDA中(图中右上角)，结点之间的边的标签是一个形如$a,b\\to c$的伪二元组，其中$a\\in\\Sigma$是PDA的输入信号，PDA根据输入信号转移状态。$b\\to c$则是将当前栈顶元素$b$替换为$c$。需要注意的是，在本课程的PDA的所有图例中，$\\varepsilon\\to a$都表示入栈操作，$a\\to\\varepsilon$表示出栈操作，相应的，$\\varepsilon\\to\\varepsilon$表示不对栈进行任何操作。例如上图中，$q_1$转移到$q_2$时，$\\varepsilon,\\varepsilon\\to\\$$，栈由空变为包含一个$\\$$，这就是一个入栈操作。 此外，我们还给出一个能识别语言$\\lbrace a^ib^jc^k|i,j,k\\ge0\\ and\\ i=j\\ or\\ i=k\\rbrace$的PDA，此图中，上半分支识别$a^ib^ic^k$，下半分支识别$a^ib^jc^i$。 2.2 PDA与CFG的等价性 定理一个语言是上下文无关的当且仅当存在PDA能识别它引理1一个语言是上下文无关的，那么存在PDA能识别它引理2PDA能识别的语言是上下文无关语言 2.2.1 证明引理一给定任意CFG $G$，我们可以将其转换为PDA，进而证明引理1： 首先我们构造一个仅包含开始状态$q_{start}$、循环状态$q_{loop}$、终止状态$q_{accept}$这三个状态的PDA，如下图所示。 将标志符\\$和开始变量入栈，并在$q_{start}$和$q_{loop}$之间添加边$\\varepsilon,\\varepsilon\\to S\\$$ 重复以下步骤： 对所有形如$A\\to BCD$的语法，我们按从右至左的规则在PDA中添加一个从$q_{loop}$到$q_{loop}$的自循环。即$q_{loop} \\stackrel{\\varepsilon,A\\to D}{\\longrightarrow}\\bigcirc \\stackrel{\\varepsilon,\\varepsilon\\to C}{\\longrightarrow}\\bigcirc \\stackrel{\\varepsilon,\\varepsilon\\to B}{\\longrightarrow}q_{loop}$ 对所有的终结符$a$，我们同样添加一个从$q_{loop}$到$q_{loop}$的自循环，即$q_{loop} \\stackrel{\\varepsilon,a\\to\\varepsilon}{\\longrightarrow}q_{loop}$ 最后，添加$q_{loop}$到$q_{accept}$的边$\\varepsilon,\\$\\to\\varepsilon$ 上面的文字描述不清不楚，我们通过例子进行更形象的说明，我们可以将以下CFG转换为PDA：$$\\begin{aligned} &amp;S \\to aTb | b \\\\ &amp;T \\to Ta | \\varepsilon\\end{aligned}$$ 2.2.2 证明引理二该引理的证明思路，给定一个PDA $P$，我们想要构造出对应的CFG $G$，使得$G$所生成的字符串能被$P$识别。如何做呢？首先，对$P$中的任意两个状态$p$和$q$，我们先构造一个变量$A_{pq}\\in G$。我们给$A_{pq}$赋予一个特殊的性质，它能生成所有让$P$从状态$p$转移到状态$q$的字符串，并且$p$和$q$这两个状态的栈都为空。即，$P$从状态$p$转移到状态$q$的过程中，栈可能会变化，但在$p$和$q$这两个状态时栈一定为空。然后我们稍微的修改给定的$P$，使它具备以下性质： 只有一个接受状态 在进入接受状态之前，栈被清空 在每次状态转移时，它的栈只能进栈或者退栈，不能使用替换操作。我们可以使用先出栈再进栈来模拟替换操作。 那么，基于以上修改后的$P$以及$A_{pq}$，我们考虑一个字符串$x=a,…,b$，$P$对$x$的计算的第一步肯定是将$a$入栈。而计算的最后一步则分为两种情况： 第一种情况是$a$出栈(先入后出)，这时候我们可以使用规则$A_{pq}\\to aA_{rs}b$来模拟这种情况，其中$r$是$P$接收$a$后的状态，$s$是$P$接收$b$之前的状态。 第二种情况是某个中间字符$x_i$出栈，这说明$P$在中间某个过程中栈被清空了,我们可以使用规则$A_{pq}\\to A_{pr}A_{rq}$来模拟，其中$P$在状态$r$时栈为空。 接下来我们就可以进行引理2的证明了。给定PDA $P=(Q,\\Sigma, \\Gamma, \\delta, q_0, \\lbrace q_{accept}\\rbrace)$，我们首先构造CFG $G$的开始变量，令其为$A_{q_0,q_{accept}}$，然后以下面的规则构造$G$的语法： 对每个$p,q,r,s\\in Q, u\\in\\Gamma$以及$a,b\\in\\Sigma_{\\varepsilon}$，如果$\\delta(p,a,\\varepsilon)$包含$(r,u)$(意味着$P$接收输入$a$，从状态$p$转移到$r$，并将$u$入栈)并且$\\delta(s,b,u)$包含$(q,\\varepsilon)$(意味着$P$接收输入$b$，从状态$s$转移到$q$，并将$u$出栈)，那么我们添加语法$A_{pq}\\to aA_{rs}b$ 对每个$p,q,r\\in Q$，我们添加语法$A_{pq}\\to A_{pr}A_{rq}$ 最后，对每个$p\\in Q$，我们添加语法$A_{pp}\\to\\varepsilon$ 2.3 总结首先，由引理2我们可以得到两个声明： 声明1：如果$A_{pq}$生成$x$，那么$x$能将$P$从空栈的状态$p$转移到空栈的状态$q$。声明2：如果$x$能将$P$从空栈的状态$p$转移到空栈的状态$q$，那么$A_{pq}$生成$x$。 推论：所有的正则语言都是上下文无关的。 这是因为，所有的正则语言都恒等于一个NFA，而任意NFA都是一个特殊的PDA，即没有栈空间的PDA，而PDA上下文无关语言是等价的。因此，正则语言都是上下文无关的。 3. 非上下文无关语言与NFA相似，对于PDA无法识别的语言，我们称之为非上下文无关语言。同样的，我们可以用Pumping Lemma来证明一个语言是上下文无关的。 CFG的Pumping Lemma如果$A$是上下文无关语言，那么存在一个pumping length $p$，使得对于$A$中任意长度至少为$p$的字符串$s$，$s$可以被分为5部分$uvxyz$且满足以下情况： $uv^ixy^iz \\in A, i\\ge0$ $|vy| &gt; 0$ $|vxy| \\le p$ 4. 确定的上下文无关语言在前文我们了解到，FA分为NFA和DFA。同样的，PDA也有确定性与非确定性之分，而且PDA是非确定的，当然也存在确定的PDA，我们称为DPDA，相对应的语言称为确定的CFL(DCFL)。在此我们给出DPDA的定义： DPDA一个确定的DPA是一个六元组$(Q,\\Sigma,\\Gamma, \\delta,q_0,F)$，其中 $Q$是有限状态集 $\\Sigma$是有限输入字母表 $\\Gamma$是有限栈字母表 $\\delta:Q\\times\\Sigma_\\varepsilon\\times\\Gamma_\\varepsilon\\to(Q\\times\\Gamma_\\varepsilon)\\cup\\lbrace\\emptyset\\rbrace$是转移函数 $q_0\\in Q$是开始状态 $F\\subseteq Q$是终止状态集 其转移函数$\\delta$必须满足：对于每一个$q\\in Q, a\\in \\Sigma, x\\in\\Gamma$，以下四个状态的值都不为$\\emptyset$: $\\delta(q,a,x),\\delta(q,a,\\varepsilon),\\delta(q,\\varepsilon,x),\\delta(q,\\varepsilon,\\varepsilon)$ 最后，举两个例子，语言$\\lbrace0^n1^n|n\\ge0\\rbrace$是DCFL，而$\\lbrace a^ib^jc^k|i,j,k\\ge0\\ and\\ i=j\\ or\\ i=k\\rbrace$则是NCFL。 作业 Recall the CFG $G_4$ that we gave in Example 2.4. For convenience, let’s rename its variables with single letters as follows.$$\\begin{aligned} &amp;E \\to E+T|T \\\\ &amp;T \\to T\\times F|F \\\\ &amp;F \\to (E)|a\\end{aligned}$$ Give parse trees and derivations for each string. a a+a a+a+a ((a)) Answer $$\\begin{aligned} E &amp;\\Rightarrow T \\\\ &amp;\\Rightarrow F \\\\ &amp; \\Rightarrow a\\end{aligned}$$ $$\\begin{aligned} E &amp;\\Rightarrow E+T \\\\ &amp;\\Rightarrow T+T \\\\ &amp;\\Rightarrow F+T \\\\ &amp;\\Rightarrow a+T \\\\ &amp;\\Rightarrow a+F \\\\ &amp;\\Rightarrow a+a\\end{aligned}$$ $$\\begin{aligned} E &amp;\\Rightarrow E+T \\\\ &amp;\\Rightarrow E+T+T \\\\ &amp;\\Rightarrow T+T+T \\\\ &amp; \\Rightarrow F+T+T \\\\ &amp; \\Rightarrow a+T+T \\\\ &amp; \\Rightarrow a+F+T \\\\ &amp; \\Rightarrow a+a+T \\\\ &amp; \\Rightarrow a+a+F \\\\ &amp; \\Rightarrow a+a+a \\\\\\end{aligned}$$ $$\\begin{aligned} E &amp;\\Rightarrow T \\\\ &amp;\\Rightarrow F \\\\ &amp;\\Rightarrow (E) \\\\ &amp; \\Rightarrow (T) \\\\ &amp; \\Rightarrow (F) \\\\ &amp; \\Rightarrow ((E)) \\\\ &amp; \\Rightarrow ((T)) \\\\ &amp; \\Rightarrow ((F)) \\\\ &amp; \\Rightarrow ((a)) \\\\\\end{aligned}$$ Give a context-free grammar that generates the language$$A=\\lbrace a^ib^jc^k|i=j\\ or\\ j=k\\ \\mathrm{where}\\ i,j,j\\ge0\\rbrace$$Is your grammar ambiguous? Why or why not? Answer$$\\begin{aligned} S &amp;\\to UT|XY \\\\ U &amp;\\to aUb|\\varepsilon \\\\ T &amp;\\to cT|\\varepsilon \\\\ X &amp;\\to aX|\\varepsilon \\\\ Y &amp;\\to bYc|\\varepsilon\\end{aligned}$$该CFG是歧义的，例如对于字符串$abc$，有两种生成过程 Give an informal description of a pushdown automaton that recognizes the language $A$ in Exercise above. Answer$$\\begin{aligned} &amp;Q = \\lbrace q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8\\rbrace \\\\ &amp;\\Sigma = \\lbrace a,b,c\\rbrace \\\\ &amp;\\Gamma = \\lbrace a,b,\\$\\rbrace \\\\ &amp; q_0 = q_1 \\\\ &amp; F = \\lbrace q_4,q_8\\rbrace \\\\ &amp; \\delta 参考下图\\end{aligned}$$ Convert the following CFG into an equivalent CFG in Chomsky normal form, using the procedure given in Theorem 2.9$$\\begin{aligned}&amp;A \\to BAB|B\\varepsilon \\\\&amp;B \\to 00|\\varepsilon\\end{aligned}$$ Answer 添加新的开始规则$$\\begin{aligned}&amp;S \\to A \\\\&amp;A \\to BAB|B|\\varepsilon \\\\&amp;B \\to 00|\\varepsilon\\end{aligned}$$ 删除$\\varepsilon$规则$$\\begin{aligned}&amp;S \\to A \\\\&amp;A \\to BAB|B\\varepsilon|AB|BA|A|\\varepsilon \\\\&amp;B \\to 00\\end{aligned}$$ $$\\begin{aligned} &amp;S \\to A|\\varepsilon \\\\ &amp;A \\to BAB|B|AB|BA|A \\\\ &amp;B \\to 00\\end{aligned}$$ 删除形如$A\\to B$的规则$$\\begin{aligned}&amp;S \\to BAB|00|AB|BA|\\varepsilon \\\\&amp;A \\to BAB|00|AB|BA \\\\&amp;B \\to 00\\end{aligned}$$ 化为合适的形式$$\\begin{aligned}&amp;S \\to XB|YY|AB|BA|\\varepsilon \\\\&amp;A \\to XB|YY|AB|BA \\\\&amp;X \\to BA \\\\&amp;B \\to YY \\\\&amp;Y \\to 0\\end{aligned}$$ Show that $F=\\lbrace a^ib^j|i=kj\\ for\\ some\\ positive\\ integer\\ k\\rbrace$ is not context free.Answer(该证明未必正确)假设$F$是上下文无关的，那么根据pumping lemma，令$p$为$F$的pumping length。首先我们考虑$k=3$的字符串$s=a^{3p}b^p$，根据pumping lemma，$s$可以被任意划分为五个部分$s=uvxyz$，且$|vy|&gt;0$。现在我们分两种情况讨论： 考虑$v$和$y$中至少有一个是同时包含$a$和$b$两种字符，那么上$s’=uv^2xy^2z$中因为$v^2$和$y^2$会导致$s’$中出现$b$在$a$前的乱序，即$s’\\not\\in F$，因此这种情况不符合$F的定义。 考虑$v$和$y$都只包含一种字符： $v$和$y$中都只包含$a$，假设$|v|=m$，$|y|=n$，则$s’=uv^2xy^2z=a^{3p+m+n}b^p$，此时当且仅当$m+n$是$p$的整数倍时$s’\\in F$，然而事实上$p$可以是任意值，例如$m+n=5$对$p=5$成立，但对$p=4$却不成立。此外，我们选用的字符串$s=a^{3p}b^p$，我们也可以选定字符串$s=a^{3(p+2)}b^{p+2}$。 $v$和$y$中都只包含$b$，与上相似，假设$|v|=m$，$|y|=n$，则$s’=uv^2xy^2z=a^{3p}b^{p+m+n}$，当且仅当$3p$是$p+m+n$的整数倍时才成立。 $v$中只包含$a$，$y$中只包含$b$，假设$|v|=m$，$|y|=n$，则$s’=uv^2xy^2z=a^{3p+m}b^{p+n}$，当且仅当$3p+m$是$p+n$的整数倍时才成立。同理，我们也可以证明$k=5,7,…$时与上述相同，综上该语言非上下文无关。","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"形式语言与计算复杂性(一)：正则语言","slug":"Math/Formal_lang/Lec1","date":"2021-06-23T07:00:00.000Z","updated":"2022-02-27T08:41:23.005Z","comments":true,"path":"2021/06/23/Math/Formal_lang/Lec1/","link":"","permalink":"http://w4ow.github.io/2021/06/23/Math/Formal_lang/Lec1/","excerpt":"Lecture 1：正则语言","text":"Lecture 1：正则语言 1 有限自动机有限自动机(Finite Antomata, FA)是本课程中所涉及到的最简单的“计算机”，我们可以认为FA是一个内存大小仅为$1$的计算机，FA在该每个时刻接收输入信号(即$\\Sigma$中的字母)，并根据状态转移函数$\\delta$来改变当前内存的状态。 FA形式化定义： 有限状态机(FA)是一个五元组$(Q,\\Sigma,\\delta,q_0,F)$ $Q$是被称为状态的有限集合 $\\Sigma$是被称为字母表的有限集合，代表FA的输入信号 $\\delta$是状态转移函数$Q\\times\\Sigma\\to Q$ $q_0\\in Q$是初始状态 $F\\subseteq Q$是终止状态集 我们提出FA是为了求解特定类型的问题，更具体的说是关于“语言”的问题。所谓的语言，在形式上是字符串的集合$A=\\lbrace w|w\\in\\Sigma^\\ast\\rbrace$(语言是字母表幂集的子集)，而我们在这门课所要学习的就是:给定一个能识别特定语言$A$的机器$M$，判断一个字符串$w$是否能被$M$识别。FA的主要作用就是判断一个字符串是否属于某种语言。举个更贴地气的例子，我们可以把语言比作我们人类所使用的语言(如汉语)，把机器$M$比作一个人(比如会汉语和英语的小明)。我们现在对小明输入了一个字符串$w$，如果$w$是一句俄语，那么小明自然无法识别，普通话则反之。 一些简单的语言可以用FA来表示，我们将这类能被FA识别的语言称为正则语言(Regular Language, RL)。例如语言$A=\\lbrace w|w至少包含一个1且以偶数个0结尾\\rbrace$(如$100,0100,0110000$)就是一个正则语言，我们可以构造如下图的FA来识别$A$，即$L(M)=A$。 例2：$A=\\lbrace w|w至少包含一个1且以1结尾\\rbrace$ 例3：$A=\\lbrace w|w以0结尾\\rbrace$ 例4：$A=\\lbrace w|w的开始符号与结束符号相同\\rbrace$ 例5：$A=\\lbrace w|w的和是3的倍数\\rbrace$ 2 FA的构造与相关性质2.1 构造FA那么，给定一个正则语言$A$，如何设计对应的FA呢？总共有四个步骤，我们以语言$A=\\lbrace w|w包含奇数个1\\rbrace$为例说明(这个过于简单，其实挺难的)： 列出所有可能，本例中就俩可能：奇数个$1$或偶数个$1$。 将所有可能表示为状态：$q_{odd}$和$q_{even}$，并画为节点。 在结点之间标出状态转移。例如本例中，$q_{even}$接收了$1$则会转移到$q_{odd}$。 标出初始状态和结束状态。本例中，开始时$w$为空，也就是偶数个$1$，所以开始状态为$q_{even}$，而我们希望$w$最终为奇数个$1$，所以终止状态为$q_{odd}$。 在实际应用中，如果不事先给出所有状态，我们很难应用这个方法，在后面的习题中就可以看出来。 2.2 基于语言的运算假定$A,B$为任意语言语言，我们可以定义基于语言的三种运算： Union: $A\\cup B=\\lbrace x|x\\in A\\ or\\ x\\in B\\rbrace$ Concatenation: $A\\circ B=\\lbrace xy|x\\in A\\ and\\ y\\in B\\rbrace$ Star: $A^{\\ast}=\\lbrace x_1…x_k|k\\ge 0\\ and\\ x_i\\in A\\rbrace$，类似于幂集。 例如，$\\Sigma=\\lbrace a,…,z\\rbrace$, $A=\\lbrace good, bad\\rbrace$, $B=\\lbrace boy, girl\\rbrace$，则有 $A\\cup B=\\lbrace good, bad, boy, girl\\rbrace$ $A\\circ B=\\lbrace goodboy, goodgirl, badboy, badgirl\\rbrace$ $A^{\\ast}=\\lbrace \\epsilon, good, bad, goodgood, goodbad, \\cdots\\rbrace$ 正则语言有一个重要的特性，即封闭性。所谓的封闭性是指对集合中的任意对象进行某种运算，如果其结果仍在该集合中，则称该集合在该操作上是封闭的(例如在自然数集合$\\mathcal{N}$上，加法和乘法操作是封闭的)。正则语言在以上三种运算上是封闭的，即，若$A_1,A_2$是正则语言，那么$A_1\\cup A_2$、$A_1\\circ A_2$和$A^{\\ast}$也是正则语言。 我们可以通过构造法先证明正则语言在$\\cup$运算上的封闭性 构造法证明$A_1\\cup A_2$的封闭性假定$M_1=\\lbrace Q_1, \\Sigma, \\delta_1, q_1, F_1\\rbrace$识别$A_1$，$M_2=\\lbrace Q_2, \\Sigma, \\delta_2, q_2, F_2\\rbrace$识别$A_2$，下面构造$M=\\lbrace Q, \\Sigma, \\delta, q_0, F\\rbrace$来识别$A_1\\cup A_2$ $Q=\\lbrace(r_1, r_2)|r_1\\in Q_1\\ \\mathrm{and}\\ r_2\\in Q_2\\rbrace$ 三个FA的字母表相同，都为$\\Sigma$ $\\delta((r_1, r_2),a) = (\\delta_1(r_1,a), \\delta_2(r_2, a))$ $q_0=(q_1,q_2)$ $F=\\lbrace (r_1, r_2)|r_1\\in F_1\\ or\\ r_2\\in F_2\\rbrace$ 证明另外两种操作的封闭性需要引入新的概念，非确定自动机NFA。 3 非确定自动机3.1 NFA与DFA前两节我们所涉及的都是确定的自动机，在一个自动机FA中，当前状态在接受了一个信号后，如果所转移的下一个状态是确定的，则称其为确定自动机DFA，反之则为非确定自动机NFA。 形式地，一个NFA是一个五元组$(Q, \\Sigma, \\delta, q_0, F)$ $Q$是被称为状态的有限集合 $\\Sigma$是被称为字母表的有限集合 $\\delta$是状态转移函数$Q\\times\\Sigma_{\\varepsilon}\\to \\mathcal{P}(Q)$ $q_0\\in Q$是初始状态 $F\\subseteq Q$是终止状态集 NFA与DFA最大的不同在于，DFA的状态转移函数是$Q\\times\\Sigma\\to Q$，即转移后的状态是一个确定的状态；NFA的状态转移函数$Q\\times\\Sigma_{\\varepsilon}\\to \\mathcal{P}(Q)$，该函数允许接收空信号$\\varepsilon$，且转移后的状态是一个状态集合。下图就是一个NFA的例子，$q_1$在接收$1$后可以跳转到$q_1$或者$q_2$，而$q_2$则允许接收$\\varepsilon$。 NFA与DFA的语言识别能力是完全相同的，且对任意一个NFA，都可以将其转换为等价的DFA。首先我们给出一个定理以及一个推理： 定理：每一个NFA都有一个等价的DFA。等价是指两个机器能识别相同的语言。推论：一个语言是正则的当且仅当存在NFA能识别它 随后，我们给出如何构造与NFA等价的DFA的方法，这个方法可以将任意NFA转换为DFA，因此该方法也是对上述定理的证明： 构造与NFA等价的DFA： 令$N=(Q,\\Sigma,\\delta,q_0,F)$是能识别语言$A$的NFA，我们可以构造一个对应的DFA $M=(Q’,\\Sigma,\\delta’,q_0’,F’)$来识别$A$: $M$和$N$的字母表相同，都为$\\Sigma$。 令$M$的状态集$Q’=\\mathcal{P}(Q)$，即$Q$的幂集。 $M$的终止状态为$F’=\\lbrace R\\in Q’|R\\ \\mathrm{contains\\ an\\ accept\\ state\\ of}\\ N\\rbrace$，即$Q’$中所有包含$F$中的任意状态的集合。 对于转移函数$\\delta’$和开始状态$q_0’$，我们考虑两种情况： 当$M$中不包含$\\varepsilon$边时： $\\delta’(R,a)=\\lbrace q\\in Q|q\\in\\delta(r,a)\\ \\mathrm{for\\ some}\\ r\\in R\\rbrace$，其中$R$是$Q’$中的一个状态，$a$是一个输入信号。 $q_0’=\\lbrace q_0\\rbrace$ 当$M$中包含$\\varepsilon$边时，对于$M$中的任意状态$R$，定义$E(R)$是一个包含了所有从$R$通过$0$或多条$\\varepsilon$边可以到达的状态的集合： $\\delta’(R, a)=\\lbrace q\\in Q|q\\in E(\\delta(r,a))\\ \\mathrm{for\\ some}\\ r\\in R\\rbrace$ $q_0’=E(\\lbrace q_0\\rbrace)$ (可选)最后删除所有没有入边的状态及其出边，因为没有入边的状态是无法到达的。 基于以上方法可以将任意NFA转换为对应的DFA。例如，给定如下的不包含$\\varepsilon$的NFA，我们可以将其转换为对应的DFA: 列出状态幂集 对幂集中的每个状态画出其状态转移。可以看到在NFA中状态$2$通过信号$a$可以转移到$2$或$3$两个状态，因此在DFA中$2$需要转移到$\\lbrace2,3\\rbrace$状态，其余类推。 添加开始和结束 删除没有入边的结点 同样的，我们也可以给出包含$\\varepsilon$边NFA-DFA转换 3.2 正则语言封闭性证明通过该定理，我们可以证明正则语言封闭性: 构造如图的NFA $N$来识别$A_1\\cup A_2$。 证明见前文 构造如图的NFA $N$来识别$A_1\\circ A_2$。 证明： 令$N_1=\\lbrace Q_1, \\Sigma, \\delta_1, q_1, F_1\\rbrace$识别$A_1$，$N2=\\lbrace Q_2, \\Sigma, \\delta_2, q_2, F_2\\rbrace$识别$A_2$，令$N=\\lbrace Q, \\Sigma, \\delta, q_0, F\\rbrace$ $Q=Q_1\\cup Q_2$ $q_0=q_1$ $F=F_2$ 定义状态转移函数$\\delta$$$\\delta(q,a)=\\begin{cases} \\delta_1(q,a) &amp; q\\in Q_1\\ \\mathrm{and}\\ q\\not\\in F_1 \\\\ \\delta_1(q,a) &amp; q\\in F_1\\ \\mathrm{and}\\ a\\not=\\varepsilon \\\\ \\delta_1(q,a)\\cup\\lbrace q_2\\rbrace &amp; q\\in F_1\\ \\mathrm{and}\\ a=\\varepsilon \\\\ \\delta_2(q,a) &amp; q\\in Q_2 \\end{cases}$$ 构造如图的NFA $N$来识别$A^\\ast$。 证明：令$N_1=\\lbrace Q_1, \\Sigma, \\delta_1, q_1, F_1\\rbrace$识别$A_1$，构造$N=\\lbrace Q, \\Sigma, \\delta, q_0, F\\rbrace$ $Q=Q_1\\cup \\lbrace q_0\\rbrace$ $q_0$是新的开始状态 $F=F_1\\cup\\lbrace q_0\\rbrace$，新的开始状态也是结束状态 定义状态转移函数$\\delta$ $$\\delta(q,a)=\\begin{cases} \\delta_1(q,a) &amp; q\\in Q_1\\ \\mathrm{and}\\ q\\not\\in F_1 \\\\ \\delta_1(q,a) &amp; q\\in F_1\\ \\mathrm{and}\\ a\\not=\\varepsilon \\\\ \\delta_1(q,a)\\cup\\lbrace q_1\\rbrace &amp; q\\in F_1\\ \\mathrm{and}\\ a=\\varepsilon \\\\ \\lbrace q_1\\rbrace &amp; q=q_0\\ \\mathrm{and}\\ a=\\varepsilon \\\\ \\emptyset &amp; q=q_0\\ \\mathrm{and}\\ a\\not=\\varepsilon \\end{cases}$$ 4. 正则表达式正则表达式是用于描述正则语言的一套符号系统，该符号系统由$\\Sigma$和正则运算$\\cup,\\circ, ^{\\ast}$构成。例如，对于正则表达式$(0\\cup 1)^\\ast$描述了所有由$0$和$1$组成的语言。 4.1 定义 正则表达式：如果$R$满足以下条件之一，则$R$是正则表达式： $\\lbrace a\\rbrace$, $a\\in\\Sigma$。即一个字母表$\\Sigma$中的字母就是一个最简单的正则表达式 $\\lbrace\\varepsilon\\rbrace$ $\\emptyset$ $R_1\\cup R_2$，其中$R_1$和$R_2$都是正则表达式 $R_1\\circ R_2$，其中$R_1$和$R_2$都是正则表达式 $R_1^\\ast$, 其中$R_1$是正则表达式 几个重要的例子(令$\\Sigma=\\lbrace0, 1\\rbrace$)： $0^\\ast 10^\\ast=\\lbrace w|w仅包含一个1\\rbrace$ $\\Sigma^\\ast1\\Sigma^\\ast=\\lbrace w|w至少包含一个1\\rbrace$ $(\\Sigma\\Sigma\\Sigma)^\\ast=\\lbrace w|w的长度是3的倍数\\rbrace$ $(0\\cup\\varepsilon)(1\\cup\\varepsilon)=\\lbrace\\varepsilon,0,1,01\\rbrace$ $1^\\ast\\emptyset=\\emptyset$，注意$\\emptyset$代表不被任何FA接收，任意包含$\\emptyset$的字符串都等价于$\\emptyset$ $\\emptyset^\\ast=\\lbrace\\varepsilon\\rbrace$，这种情况十分特殊 4.2 正则表达式与FA的等价性正则表达式与FA都会用于描述正则语言的一种形式化的方式，且正则表达式与FA等价的，换句话说，NFA$\\equiv$DFA$\\equiv$正则表达式$\\equiv$正则语言。 定理：一个语言是正则的，当且仅当存在一个正则表达式能描述它 下面，我们通过两个引理来阐述NFA和正则表达式之间的相互转换。 4.2.1 正则表达式转换为NFA 引理1：如果一个语言能被正则表达式描述，那么该语言是正则的 证明：我们可以将任意描述语言的正则表达式$R$转换为NFA，而N由前面的NFA-RL等价定理可知NFA能识别的语言是正则的。考虑我们根据正则表达式的定义给出6条正则表达式-NFA转换规则: $R=a$, $a\\in\\Sigma$。那么$L(R)=\\lbrace a\\rbrace$，并且下图的NFA可以识别$L(R)$ $R=\\varepsilon$,那么$L(R)=\\lbrace\\varepsilon\\rbrace$，可以构造如下NFA $R=\\emptyset$，那么$L(R)=\\emptyset$ $R=R_1\\cup R_2$ $R=R_1\\circ R_2$ $R=R_1^\\ast$ 根据以上转换规则，我们可以尝试转换一个正则表达式，例如$(ab\\cup a)^\\ast$ 4.2.2 DFA转换为正则表达式 引理2：如果一个语言是正则的，那么它能被正则表达式描述 首先我们引入一个新的概念：广义NFA(Generalized NFA, GNFA)，如下图所示： GNFA有以下几个特点： GNFA的转移信号，或者说边的label，可以是正则表达式、字母或者$\\varepsilon$。 开始状态与其他所有状态都由直接的转移关系，或者说有直接的边相连，且初始状态没有入边。 只有一个结束状态，所有状态都直接与结束状态相连，结束状态没有出边。 除了开始状态和结束状态，任意一个状态都会到达其他所有状态，且任意一个状态都有自身环转移。 有了GNFA，我们可以通过DFA$\\Rightarrow$GNFA$\\Rightarrow$正则表达式来证明上述引理。给定一个DFA，我们可以通过以下几个步骤将其转换为GNFA： 添加一个新的初始状态，并通过$\\varepsilon$转移到旧的初始状态 添加一个新的结束状态，并通过$\\varepsilon$转移自旧的结束状态集 如果两个结点之间存在多条方向相同的边，通过$\\cup$将其合并为一条边 如果两个状态之间没有边，则添加label为$\\emptyset$的新边。 构造完成GNFA后，我们逐个删除GNFA中的节点，并修改相应的边的label，直至GNFA中只剩开始结点和终止结点。这两个结点之间的边的label就是最终的正则表达式。下图是一个DFA转换为正则表达式的例子： 一个更复杂的例子 4. 非正则语言FA的能力十分有限，大多数的语言都不能被FA所识别，例如$B=\\lbrace 0^n1^n|n\\ge0\\rbrace$，机器需要记住目前为止读取了多少个$0$，而FA因为没有额外内存而无法做到这一点。对这样的语言，我们称为非正则语言。给定一个语言，如何判定它是否正则呢？这时就轮到pumping lemma出场了 4.1 Pumping Lemma Pumping Lengthpumping length是指：同一个语言内的所有字符串都存在一个特殊的子串，该子串可以被重复任意次，重复后的字符串仍然属于该语言，这个子串的长度即为pumping lengthPumping Lemma如果$A$是正则语言，那么存在一个数$p$(即pumping length)，当$s$是$A$中任意一个长度至少为$p$的子串时，$s$可以被分为三部分，即$s=xyz$，并且$s$满足以下三个性质 对于任意$i\\ge0, xy^iz\\in A$ $|y|&gt;0$，$x$和$y$允许为$\\varepsilon$ $|xy|\\le p$，即$x$和$y$的总长度不超过$p$ Pumping Lemma的证明令$M=(Q,\\Sigma,\\delta,q_0,F)$ 令$p$是$M$的状态数，即$p=|Q|$ $A$中任意长度至少为$p$字符串$s$都可划分为三部分$xyz$ 对$s$，我们考虑$M$接收$s$时的状态序列：假设这个状态序列的长度为$n+1$(因为包含开始状态)，而$n\\ge p$，因此这状态序列肯定包含一个重复状态$p_r$。我们可以根据这个重复状态将$s$划分为$xyz$，其中$x$是第一个$p_r$之前的状态序列，$y$是两个$p_r$之间的状态序列，$z$是第二个$p_r$之后的状态序列。因为$y$从$p_r$出发最终又回到$p_r$，因此它重复任意次，该字符串依然属于该语言。 4.2 非正则语言的证明证明语言$B=\\lbrace 0^n1^n|n\\ge0\\rbrace$不是正则的 证明 假设$B$是正则的，那么$B$中存在pumping length $p$ 我们选择一个子串$0^p1^p$，并将该子串分为三部分$xyz$，由pumping lemma可知，对任意$i\\ge0, xy^iz\\in B$ 考虑三种情况 子串$y$由$0$组成，那么$xyz$中，$xy=0^i$，$z=0^{p-i}1^p$。现在考虑$xyyz$，多出来的$y$会导致$0$的个数多于$1$的个数，所以子串$y$不可能由$0$组成 子串$y$由$1$组成，同样的，会导致$1$的个数多于$0$的个数 子串$y$由$0$和$1$组成，那么$xyyz$中，$yy$的存在会导致$1$出现在$0$前的乱序，也是不可取的 因此，无论怎么划分，划分后的子串都不属于$B$，因此语言$B$不是正则的。 作业 The formal description of a DFA $M$ is $(\\lbrace q_1,q_2,q_3,q_4,q_5\\rbrace,\\lbrace u,d\\rbrace, \\delta, q_3, \\lbrace q_3\\rbrace)$, where $\\delta$ is given by the following table. Give the state diagram of this machine. Answer Give state diagrams of DFAs recognizing the following languages. In all parts, the alphabet is $\\lbrace 0, 1\\rbrace$ $\\lbrace w|w\\ \\mathrm{begins\\ with\\ a}\\ 1\\ \\mathrm{and\\ ends\\ with\\ a}\\ 0\\rbrace$ $\\lbrace w|w\\ \\mathrm{contains\\ at\\ least\\ three}\\ 1s\\rbrace$ $\\lbrace w|w\\ \\mathrm{contains\\ the\\ substring}\\ 0101(\\mathrm{i.e.,}\\ w=x0101y\\ \\mathrm{for\\ some}\\ x\\ \\mathrm{and}\\ y)\\rbrace$ Answer Use the construction given in Theorem 1.39 to convert the following two NFA to equivalent DFA. Answer Use the procedure described in Lemma 1.60 to convert the following finite automata to regular expresssions. Answer Use the pumping lemma to show that the following languages are not regular.$A_1=\\lbrace 0^n1^n2^n|n\\ge0\\rbrace$ Answer 假定$A_1$是正则的，那么$A_1$肯定存在pumping length，假设为$p$，考虑字符串$s=0^p1^p2^p\\in A_1$ 因为$A_1$是正则的，根据pumping lemma，$s$可以被分为$xyz$三部分，且对任意$i\\ge0$，有$xy^iz\\in A_1$ 现考虑以下几种情况： 子串$y$全由$0$组成，令$x=0^i,y=0^j,z=0^{p-i-j}1^p2^p$，那么$xyyz=0^{p+j}y^pz^p$，$0$的个数多于$1$和$2$，不属于$A_1$ 子串$y$全由$1$组成，同上 子串$y$全由$2$组成，同上 子串$y$由$0$和$1$组成，则$xyyz$中会出现$1$在$0$前的乱序 子串$y$由$1$和$2$组成，同上 子串$y$由$1$、$2$和$3$组成，同上 子串$y$由$1$和$3$组成，不符合$A_1$语法 因此无论什么情况，$s$都不符合$A_1$语法，因此$A_1$不符合pumping lemma，故其为非正则语言。","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"Ubuntu中的PDF工具的使用","slug":"CS/Tools/PDF_tools_manual","date":"2021-06-21T07:00:00.000Z","updated":"2022-02-27T08:41:22.987Z","comments":true,"path":"2021/06/21/CS/Tools/PDF_tools_manual/","link":"","permalink":"http://w4ow.github.io/2021/06/21/CS/Tools/PDF_tools_manual/","excerpt":"Ubuntu系统有两款十分强大的PDF编辑工具，本文简单记录其用途及使用方法","text":"Ubuntu系统有两款十分强大的PDF编辑工具，本文简单记录其用途及使用方法 1. pdfcroppdfcrop是随LaTeX安装的一款专用于去除PDF白边的工具，其输入输出都为PDF文件。 1pdfcrop input.pdf output.pdf 2. ImageMagickImageMagick属于Ubuntu20自带的图像编辑工具，可以轻松将图像转换成各种格式。当需要将PDF转换为png等像素图时，可以使用如下命令 12convert input.pdf output.png # 生成普通像素png图片convert -verbose -colorspace RGB -resize 1800 -interlace none -density 300 -quality 100 input.pdf output.png # 生成高清png 转换PDF时如遇到类似： 1convert-im6.q16: attempt to perform an operation not allowed by the security policy `PDF' @ error/constitute.c/IsCoderAuthorized/408. 则需要修改其配置文件/etc/ImageMagick-6/policy.xml，修改PDF配置一行(在最后几行内)，将 1&lt;policy domain=\"coder\" rights=\"none\" pattern=\"PDF\" /&gt; 改为 12&lt;policy domain=\"coder\" rights=\"read|write\" pattern=\"PDF\" /&gt;&lt;policy domain=\"coder\" rights=\"read|write\" pattern=\"LABEL\" /&gt;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"PDF","slug":"PDF","permalink":"http://w4ow.github.io/tags/PDF/"}]},{"title":"形式语言与计算复杂性(零)：绪论","slug":"Math/Formal_lang/Lec0","date":"2021-06-16T07:00:00.000Z","updated":"2022-02-27T08:41:22.990Z","comments":true,"path":"2021/06/16/Math/Formal_lang/Lec0/","link":"","permalink":"http://w4ow.github.io/2021/06/16/Math/Formal_lang/Lec0/","excerpt":"USTC2021春季学期研究生课程《形式语言与计算复杂性》 教材:Introduction to the Theory of Computation 2018 作业要求：布置一周内完成，BB上提交 考试要求： 闭卷，可带一张带有笔记的A4纸 送分：课后作业相关，80分 压轴：课件中所提到的证明，20分 Lecture 0：绪论","text":"USTC2021春季学期研究生课程《形式语言与计算复杂性》 教材:Introduction to the Theory of Computation 2018 作业要求：布置一周内完成，BB上提交 考试要求： 闭卷，可带一张带有笔记的A4纸 送分：课后作业相关，80分 压轴：课件中所提到的证明，20分 Lecture 0：绪论 1 符号与术语1.1 集合 集合(set)：一组不包含重复对象的整体，无顺序关系 $\\in$和$\\not\\in$，表示元素和集合的从属关系 $\\subseteq$和$\\not\\subseteq$，表集合与集合之间的从属关系 多重集(multiset)：允许集合中出现重复元素 无穷集：包含无穷元素的集合，如自然数集$\\mathcal{N}=\\lbrace1,2,3,…\\rbrace$，整数集$\\mathcal{Z}$ 空集$\\emptyset$：没有元素的集合，注意$\\emptyset\\not=\\lbrace\\rbrace$ $\\lbrace n|\\mathrm{rule\\ about\\ }n\\rbrace$:集合的另一种写法 $\\cup,\\cap, \\overline{A}$:交、并、补 1.2 序列与元组 序列：有序的对象组合 元组(tuple)：有限序列，$k$个对象的序列称为$k$-元组，$2$-元组亦称为有序对 幂集(power set)：集合的所有子集(包括空集) 笛卡尔积$\\times$：两个集合$A,B$中的元素组成的所有有序对的集合，其中第一个元素来自$A$，第二个元素来自$B$。例： $A = \\lbrace 1, 2\\rbrace,B = \\lbrace x, y, z\\rbrace$ $A \\times B = \\lbrace (1, x),(1, y),(1, z),(2, x),(2, y),(2, z)\\rbrace$ $A^k=\\underset{k}{\\underbrace{A\\times A\\times \\cdots\\times A}}$ 1.3 函数与关系函数与映射函数是输入输出之间的映射关系 定义域(doamin)与值域(range) 函数的输入所可能取到的值的集合称为定义域 函数的输出所可能取到的值的集合称为值域 符号: 定义域为$D$以及值域为$R$的函数$f$标记为$$f:D \\to R$$ $k$-ary函数当函数$f$的值域为$A_1\\times \\cdots\\times A_k$，其输入为$k$-元组$(a_1,…,a_k)$ 称$a_i$为$f$的参数 称$f$为$k$-ary函数 $k=1$时称为一元函数(unary function) $k=2$时称为二元函数(binary fuction) 前缀表示与中序表示： 前缀：$aRb$ 中缀：$R(a,b)$ 谓词与关系 谓词(predicate)，是声明的数学形式化术语，表示一个断言，其值域为true或false。 给定一个谓词，若其定义域为$A\\times\\cdots\\times A$，则称该谓词为一个关系(relation)，亦称之为($A$上的)$k$元关系。例如，2元关系谓词$aRb$意味着$aRb=True$ 给定定义域$A$,满足以下三个性质的2元关系$R$称为等价关系 自反性reflexive: 若$x=True$，则$xRx=True$ 对称性symmetric：若$xRy=True$， 则$yRx=True$ 传递性transitive: 若$xRy=True,yRz=True$，则$xRz=True$ 1.4 字符串与语言 字母表Alphabet：任意非空有限集合 符号Symbols：字母表中的元素 本课程中表示字母表的符号包括:$\\Sigma, \\Gamma$ 字符串：本课程中的字符串都是基于给定字母表的有限符号序列，例如$01001$是基于$\\Sigma=\\lbrace0,1\\rbrace$的字符串。 字符串$w$的长度记为$|w|$ 空字符串记为$\\varepsilon$ lexicographic order就是字典序,shortlex order等价于字典序，但短字符排在长字符之前 语言是字符串的集合 前缀：如果存在字符串$x$和$y$的拼接使得$xy=z$，则称$x$是$z$的前缀。若$x\\not=z$则称为真前缀 前缀无关：一个语言中(即字符串集合)，不存在一个元素是另一个元素的真前缀，则称该语言前缀无关。 1.5 布尔逻辑 符号：$\\lnot, \\land, \\lor, \\oplus$(左右不等则为真), $\\leftrightarrow$(左右相等则为真)，$\\to$(左假右真则为假) 分配律： $P\\land(Q\\lor R)=(P\\land Q)\\lor(P\\land R)$ $P\\lor(Q\\land R)=(P\\lor Q)\\land(P\\lor R)$ 2 定义、定理与证明 定义：对目标的描述，不可存在二义性 证明：说明一个声明为真的过程 定理：已经被证明为真的数学声明 引理：在证明定理的过程中用到的“低层次的定理” 推论：由定理推而广之得到的结论 证明的手段：构造法、反证法、归纳法… 作业 Write formal descriptions of the following sets The set containing the numbers $1$, $10$, and $100$ The set containing all integers that are greater than $5$ The set containing all natural numbers that are less than $5$ The set containing the string $aba$ The set containing the empty string The set containing nothing at all Answer: $\\lbrace 1, 10, 100\\rbrace$ $\\lbrace n|n &gt; 5,n\\in\\mathcal{N}\\rbrace$ $\\lbrace n|n &lt; 5,n\\in\\mathcal{N}\\rbrace$ $\\lbrace aba\\rbrace$ $\\lbrace \\varepsilon\\rbrace$ $\\emptyset$ Let $A$ be the set $\\lbrace x, y, z\\rbrace$ and $B$ be the set $\\lbrace x, y\\rbrace$ Is $A$ a subset of $B$? IS $B$ a subset of $A$? What is $A\\cup B$? What is $A\\cap B$? What is $A\\times B$? What is the power set of $B$? Answer No Yes $\\lbrace x, y, z\\rbrace$ $\\lbrace x, y\\rbrace$ $\\lbrace (x,x), (x,y), (y,x), (y,y), (z,x), (z, y)\\rbrace$ $\\lbrace \\emptyset, \\lbrace x\\rbrace, \\lbrace y\\rbrace, \\lbrace x, y\\rbrace \\rbrace$ For each part, give a relation that satisfies the condition. Reflexive and symmetric but not transitive Reflexive and transitive but not symmetric Symmetric and transitive but not reflexive Answer 给定定义域$A=\\lbrace a, b, c\\rbrace$,分别给出三种关系满足以上要求： $\\lbrace(a,a),(b,b),(c,c),(a,b),(b,a),(a,c),(c,a)\\rbrace$ $\\lbrace(a,a),(b,b),(c,c),(a,b),(b,c),(a,c)\\rbrace$ $\\lbrace(a,b),(b,a),(b,c),(c,b),(a,c),(c,a)\\rbrace$ Consider the undirected graph $G= (V,E)$ where $V$ , the set of nodes, is $\\lbrace 1,2,3,4\\rbrace$ and $E$, the set of edges, is $\\lbrace\\lbrace 1,2\\rbrace,\\lbrace 2,3\\rbrace,\\lbrace 1,3\\rbrace,\\lbrace 2,4\\rbrace,\\lbrace 1,4\\rbrace\\rbrace$. Draw thegraph $G$. What are the degrees of each node? Indicate a path from node $3$ tonode $4$ on your drawing of $G$. Answer","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Lecture","slug":"Lecture","permalink":"http://w4ow.github.io/tags/Lecture/"}]},{"title":"序列建模：循环神经网络","slug":"Deep_Learning/RNN","date":"2021-06-15T02:00:00.000Z","updated":"2021-12-13T10:10:53.765Z","comments":true,"path":"2021/06/15/Deep_Learning/RNN/","link":"","permalink":"http://w4ow.github.io/2021/06/15/Deep_Learning/RNN/","excerpt":"循环神经网络(recurrent neural network, RNN)是一类用于处理序列数据的神经网络。","text":"循环神经网络(recurrent neural network, RNN)是一类用于处理序列数据的神经网络。 1. 数学原理1.1. 语言模型及$n$元语法给定一个长度为$\\tau$的词序列或字符序列$x^{(1)},x^{(2)},…,x^{(\\tau)}$，其中每个字词$x^{(i)}$都是依次生成的，那么传统RNN的工作原理可以认为是： $$P(x^{(1)},…,x^{(\\tau)}) = \\prod_{t=1}^{\\tau}P(x^{(\\tau)}|x^{(1)},,…,x^{(\\tau-1)})$$ 即生成该序列的条件概率。例如，包含4个字符的文本序列的概率 $$P(x^{(1)},x^{(2)},x^{(3)},x^{(4)}) = P(x^{(1)})P(x^{(2)}|x^{(1)})P(x^{(3)}|x^{(1)},x^{(2)})P(x^{(4)}|x^{(1)},x^{(2)},x^{(3)})$$ 而$P(x^{(1)})$可以通过计算$x^{(1)}$在语料库中出现的频率得到，同理$P(x^{(2)}|x^{(1)})$可以通过计算语料库中$x^{(2)}$紧跟$x^{(1)}$之后的频率，以此类推。 当序列长度增加时，所需要计算的概率会以指数级增长，为了简化计算的复杂度，可以利用基于马尔科夫假设的$n$元语法。$n$阶马尔科夫假设(Markov chain of order $n$)是指一个字词的出现仅与其前面的$n$个词有关，例如，如果$n=1$，上面的语言模型则可以改成 $$P(x^{(1)},x^{(2)},x^{(3)},x^{(4)}) = P(x^{(1)})P(x^{(2)}|x^{(1)})P(x^{(3)}|x^{(2)})P(x^{(4)}|x^{(3)})$$ 因此这种语言模型因此也被称为$n$元语法。 1.2. 循环神经网络循环神经网络有三种主要的设计模式： 每个时间步都有输出，并且隐藏单元之间有循环连接的循环网络，如下图所示： 假设$\\bm{x}^{(t)}$为$t$时刻的输入向量，那么时间步$t$的隐藏状态则可以通过以下公式计算： $$\\begin{aligned} \\bm{h}^{(t)} &amp;= \\phi(\\bm{Wh}^{(t-1)}+\\bm{Ux}^{(t)}+\\bm{b}) \\\\ \\bm{o}^{(t)} &amp;= \\bm{Vh}^{(t)}+\\bm{c}\\end{aligned} \\tag{1}$$ 其中$\\bm{U}$和$\\bm{W}$分别对应输入-隐藏和隐藏-隐藏的连接，$\\bm{V}$则为隐藏-输出连接，而$\\bm{b,c}$则是对应的偏置向量。这个循环网络将输入序列映射到相同长度的输出序列，与$\\bm{x}$配对的$\\bm{y}$的总损失就是所有时间步的损失之和，即 $$\\begin{aligned} &amp;L(\\lbrace \\bm{x}^{(1)},…,\\bm{x}^{(\\tau)}\\rbrace, \\lbrace \\bm{y}^{(1)},…,\\bm{y}^{(\\tau)}\\rbrace) \\\\ &amp;=\\frac{1}{\\tau}\\sum_{t}l^{(t)} \\\\ &amp;=-\\frac{1}{\\tau}\\sum_{t}\\log p_{model}(y^{(t)}|\\lbrace \\bm{x}^{(1)},…,\\bm{x}^{(\\tau)}\\rbrace)\\end{aligned} \\tag{2}$$ 每个时间步都有输出，当前时刻的输出与下时刻隐藏单元之间有连接。 这一类的RNN唯一的循环是输出到隐藏的反馈，其表示没有前一种结构强大，只能表示更小的函数集合。由于只有$\\bm{o}$是唯一传播到未来的信息，这使得该种RNN更容易训练。因为基于比较时刻$t$的预测及其真实值的损失函数中的所有时间步都解耦了，每个时间步可以与其他时间步分离训练，允许并行化。 由输出反馈到模型而产生循环连接的模型可以用导师驱动过程(teacher forcing)进行训练，与前一种不同，该过程不再使用最大似然准则，而是在$t+1$时刻接受真实值$y^{(t)}$作为输入。使用导师是驱动的最初动机是为了避免在缺乏隐藏-隐藏连接的模型中使用通过时间反向传播(BPTT)算法。 隐藏单元之间有循环连接，但读取整个序列后产生单个输出的循环网络。 1.3 通过时间的反向传播BPTT简单起见，我们考虑无偏差项的循环神经网络，由前文公式(1)(2)有$$L=\\frac{1}{\\tau}\\sum_{t}l^{(t)} $$首先考虑模型的输出层$\\bm{o}^{(t)}$，其梯度容易计算：$$\\frac{\\partial L}{\\partial\\bm{o}^{(t)}}=\\frac{\\partial l(\\bm{o}^{(t)}, y^{(t)})}{\\tau\\cdot\\partial\\bm{o}^{(t)}}$$更进一步的计算则需要根据$l(\\bm{o}^{(t)}, y^{(t)})$的详细设计。 随后可以计算隐藏-输出的模型参数$\\bm{V}$， $L$通过$\\bm{o}^{(t)}$依赖$\\bm{V}$，即$\\bm{o}^{(t)} = \\bm{Vh}^{(t)}$，根据链式法则，有： $$\\frac{\\partial L}{\\partial \\bm{V}} = \\sum_{t=1}^{\\tau}(\\frac{\\partial L}{\\partial\\bm{o}^{(t)}}\\cdot \\frac{\\partial \\bm{o}^{(t)}}{\\partial\\bm{V}}) = \\sum_{t=1}^{\\tau}\\frac{\\partial L}{\\partial\\bm{o}^{(t)}}{\\bm{h}^{(t)}}^{\\top}$$ 在最终时间步$\\tau$，$\\bm{o}^{(\\tau)}$只依赖于$\\bm{h}^{(\\tau)}$，因此最终时间步的隐藏状态$\\bm{h}^{(\\tau)}$的梯度为： $$\\frac{\\partial L}{\\partial \\bm{h}^{(\\tau)}} = \\frac{\\partial L}{\\partial\\bm{o}^{(\\tau)}}\\cdot \\frac{\\partial \\bm{o}^{(\\tau)}}{\\partial\\bm{h}^{(\\tau)}} = \\bm{V}^{\\top}\\cdot\\frac{\\partial L}{\\partial\\bm{o}^{(\\tau)}}$$ 随后我们从序列的末尾开始，从时刻$t=\\tau$反向迭代到$t=1$，因为$\\bm{h}^{(t)}$同时具有$\\bm{h}^{(t+1)}$和$\\bm{o}^{(t)}$两个后续结点，因此其梯度计算为： $$\\frac{\\partial L}{\\partial \\bm{h}^{(t)}}= \\frac{\\partial L}{\\partial\\bm{h}^{(t+1)}}\\cdot \\frac{\\partial \\bm{h}^{(t+1)}}{\\partial\\bm{h}^{(t)}} + \\frac{\\partial L}{\\partial\\bm{o}^{(t)}}\\cdot \\frac{\\partial \\bm{o}^{(t)}}{\\partial\\bm{h}^{(t)}}= \\bm{W}^{\\top}\\cdot\\frac{\\partial L}{\\partial\\bm{h}^{(t+1)}} + \\bm{V}^{\\top}\\cdot\\frac{\\partial L}{\\partial\\bm{o}^{(t)}}$$ 将上面的式子展开，对任意时间步$t$有： $$\\frac{\\partial L}{\\partial \\bm{h}^{(t)}}=\\sum_{i=t}^{\\tau}{(\\bm{W}^{\\top})}^{\\tau -i}\\bm{V}^{\\top}\\frac{\\partial L}{\\partial \\bm{o}^{(\\tau + t - i)}}$$ 由该式中的指数可以看出，当$\\tau$较大或较小时，RNN十分容易出现梯度爆炸或者梯度消失的问题。剩下的参数梯度如下： $$\\begin{aligned} \\frac{\\partial L}{\\partial \\bm{W}} &amp;= \\sum_{t=1}^{\\tau}\\frac{\\partial L}{\\partial \\bm{h}^{(t)}}{\\bm{h}^{(t-1)}}^{\\top} \\\\ \\frac{\\partial L}{\\partial \\bm{U}} &amp;= \\sum_{t=1}^{\\tau}\\frac{\\partial L}{\\partial \\bm{h}^{(t)}}{\\bm{x}^{(t)}}^{\\top}\\end{aligned}$$ 2. 双向RNN到目前为止，我们所考虑的RNN是基于因果结构的，即时刻$t$的状态仅依赖于之前的序列$\\bm{x}^{(1)},…,\\bm{x}^{(t-1)}$以及当前输入$\\bm{x}^{(t)}$。然而，在众多应用中，所要输出的$\\bm{y}^{(t)}$可能依赖于整个输入序列，最典型的例子就是数学表达式求解(例如化简$x^2+y^2-2xy$)，其中的同一个变量可能出现在表达式中的不同位置。双向RNN为满足这种需求而生，该结构在手写识别、语音识别、生物信息学等领域十分成功。下图展示了典型的双向RNN结构。 对于双向RNN，其隐藏状态包含两个，$\\bm{h}$是包含过去信息的隐藏状态，而$\\bm{g}$则是包含将来信息的隐藏状态，因此其输出以以下公式计算： $$\\begin{aligned} \\bm{h}^{(t)} &amp;= \\phi(\\bm{\\overrightarrow{W}h}^{(t-1)}+\\bm{\\overrightarrow{U}x}^{(t)}+\\bm{\\overrightarrow{b}}) \\\\ \\bm{g}^{(t)} &amp;= \\phi(\\bm{\\overleftarrow{W}g}^{(t-1)}+\\bm{\\overleftarrow{U}x}^{(t)}+\\bm{\\overleftarrow{b}}) \\\\ \\bm{o}^{(t)} &amp;= \\bm{V}[\\bm{h}^{(t)}; \\bm{g}^{(t)}]+\\bm{c}\\end{aligned}$$ 3. 基于编解码的Seq2Seq架构在以上展示的RNN都包含了一个隐藏约束，即输入序列的长度$n_x$和输出序列的长度$n_y$之间存在$n_x=n_y=\\tau$，或者$\\bm{y}^{(t)}$为一个固定大小的向量。然而在现实场景中，有许多任务涉及将不定长序列映射到另一个不定长序列，如语音识别、机器翻译以及问答系统。 通常，我们将RNN的输入称为上下文，我们希望产生此上下文的表示$C$，它是一个概括输入序列$\\bm{X}=(\\bm{x}^{(1)},…,\\bm{x}^{(n_x)})$的向量或者向量序列。基于这种想法，Cho等人提出了编解码架构，该架构由两组RNN组合而成，前者称为编码器，编码器读取输入并产生上下文$C$。后者称为解码器，解码器则以固定长度的向量为条件产生输出序列(即输出序列的长度是固定的)。这种架构最大的优势是$n_x$和$n_y$可以彼此不同，这就允许了不同长度序列之间的互相映射，尽管解码器的输出序列是固定的，但我们可以对其进行截取从而取得不同长度的输出序列。同样的，我们也可以对输入序列进行填充从而得到相同长度的输入序列，从而便于编码器的计算。 此类架构的一个明显不足是，编码器输出的上下文$C$的维度太小而难以适当地概括一个长序列，例如输入序列为一篇1000字的文章，很难用一个向量或向量组来概括。 4. 递归神经网络(Recursive NNs)递归神经网络是RNN的另一个扩展，其构造为深的树状结构，而不是通常RNN的链状结构，如下图所示。 这类网络的潜在用途是学习推论，递归神经网络已成功的应用于输入是数据结构的神经网络，如自然语言处理和计算机视觉。其一个明显优势是，对于具有相同长度$\\tau$的序列，结构的深度可以从$\\tau$减小为$\\mathcal{O}(\\log\\tau)$，这可能有助于解决长期依赖。该网络的一个悬而未决的问题是如何以最佳的方式构造树，其中一个选择是使用平衡二叉树。处理自然语言句子时，用于递归网络的树结构可以被固定为句子语法分析树的结构。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Deep Learning","slug":"Computer-Science/Deep-Learning","permalink":"http://w4ow.github.io/categories/Computer-Science/Deep-Learning/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"http://w4ow.github.io/tags/RNN/"}]},{"title":"Conda的使用","slug":"CS/Tools/Conda_manual","date":"2019-11-07T02:00:00.000Z","updated":"2022-02-27T08:41:22.984Z","comments":true,"path":"2019/11/07/CS/Tools/Conda_manual/","link":"","permalink":"http://w4ow.github.io/2019/11/07/CS/Tools/Conda_manual/","excerpt":"Conda是一个开源跨平台语言无关的包管理与环境管理系统，我们常用的Anaconda、Bioconda(计算生物学)、miniconda等都是基于conda的发行版。","text":"Conda是一个开源跨平台语言无关的包管理与环境管理系统，我们常用的Anaconda、Bioconda(计算生物学)、miniconda等都是基于conda的发行版。 1. Conda相关1.1 Anaconda的安装以及配置 安装Anaconda 可以在Anaconda官网下载相应Python版本的软件，或者使用如下命令： 123wget https://repo.continuum.io/archive/Anaconda3-2018.12-Linux-x86_64.shbash Anaconda3-2018.12-Linux-x86_64.sh 创建Python虚拟环境 1conda create -n virtual_env_name python=x.x 激活/关闭虚拟环境 1234# 激活source activate virtual_env_name# 关闭source deactivate 为相应的虚拟环境安装包 1conda install -n virtual_env_name [package] 删除虚拟环境 1conda env remove -n(--name) virtual_env_name 常用conda命令 12conda env list # 列出所有已创建的虚拟环境conda upgrade conda # 升级conda本身 1.2 Conda镜像源的修改由于国外镜像访问速度较慢，推荐使用国内镜像。国内经Anaconda Inc.授权的为清华镜像。 修改为Tsinghua源 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/freeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mainconda config --set show_channel_urls yes 换回默认源 1conda config --remove-key channels 2. Jupyter Notebook的配置通过pip install notebook或者conda install notebook可以安装交互式计算环境notebook。 2.1 Notebook工作路径的修改Jupyter Notebook的默认工作路径为用户根目录，可以修改为指定目录。 生成配置文件 12# Mac &amp; Ubuntu &amp; Windows在Terminal中运行下面命令jupyter notebook --generate-config 如果在Windows中出现‘jupyter’不是内部或外部命令，也不是可运行的批处理文件，则说明没有安装notebook，可以通过下面命令安装notebook 1pip install notebook 修改配置文件 找到如下所示的两行，第二行去注释并改成工作路径即可。 1234567macOS:## The directory to use for notebooks and kernels.#c.NotebookApp.notebook_dir = ''Ubuntu &amp; Windows:## The default URL to redirect to from `/`#c.NotebookApp.default_url = '/tree' 2.2 Jupyter的Python内核管理Conda可以创建多个Python虚拟环境，有时启动Jupyter Notebook后，在新建notebook选项中却找不到我们所创建的Python环境，此时可以通过向notebook中添加Python kernel解决该问题。 1. 添加Kernel 切换环境，安装内核 首先切换到想要使用的Python环境中，若是虚拟环境则激活该虚拟环境。随后可以使用如下命令查看该环境下搜索并安装Python内核： 12conda search ipykernel # 搜索内核conda install ipykernel # 安装内核 在notebook中安装内核 使用以下命令安装notebook内核， 1python -m ipykernel install --name name_you_want (--user) 其中name_you_want是将在notebook的新建中所显示的Python环境名字，安装时若权限不够，则添加–user 重新启动Jupyter Notebook 重启Notebook，可以在新建下拉菜单中看到name_you_want选项，大功告成。 2. 查看kernel 使用该命令可以查看notebook所有已安装kernel 1jupyter kernelspec list 3. 删除kernel 使用以下命令可以删除指定kernel 1jupyter kernelspec remove kernel_name","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"http://w4ow.github.io/tags/Conda/"}]},{"title":"SSH中scp命令的使用","slug":"CS/Tools/ssh-scp","date":"2019-11-06T07:00:00.000Z","updated":"2019-11-06T07:00:00.000Z","comments":true,"path":"2019/11/06/CS/Tools/ssh-scp/","link":"","permalink":"http://w4ow.github.io/2019/11/06/CS/Tools/ssh-scp/","excerpt":"在SSH中，scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。类似的工具有rsync。scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。","text":"在SSH中，scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。类似的工具有rsync。scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 1. 命令格式1scp [参数] [原路径] [目标路径] 2. 命令参数 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 3. 使用示例12345# 从远程拷贝到本地$scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/# 从本地拷贝到远程$scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://w4ow.github.io/tags/SSH/"}]},{"title":"线性MBA表达式存在定理证明","slug":"CS/Security/Linear MBA Expressions","date":"2019-10-10T05:22:00.000Z","updated":"2019-10-10T08:41:00.000Z","comments":true,"path":"2019/10/10/CS/Security/Linear MBA Expressions/","link":"","permalink":"http://w4ow.github.io/2019/10/10/CS/Security/Linear MBA Expressions/","excerpt":"定理来源参见论文Information Hiding in Software with Mixed Boolean-Arithmetic Transforms中定理1.","text":"定理来源参见论文Information Hiding in Software with Mixed Boolean-Arithmetic Transforms中定理1. 1. MBA表达式的定义多项式MBA表达式形如：$$\\sum_{i \\in I} a_i (\\prod_{j \\in J} e_{i,j}(x_1,…,x_t))$$其中$a_i$是整数，$x_i$是在$B^n$上的变量，$e_{i,j}$是对变量$x_i$的按位表达式。例如：$$f(x,y,z,t)=8458(x \\lor y \\land z)^3((xy)\\land x \\lor t) + x + 9(x \\lor y)yz^3$$是一个多项式MBA表达式，其中，表达式中变量总共有4个，即$t = 4$,即$x_1 = x, x_2 = y, x_3 = z$, $x_4 = t$，另外，$a$总共有3个值，分别是$a_0=8458, a_1=1, a_2 = 9$。对于$a_0$，总共有4个$e_{i,j}$作为其右部累积，即$e_{0,0}=e_{0,1}=e_{0,2}=x \\lor y \\land z,e_{0,3}=(xy) \\land x \\lor t$。同样的，$a_1$仅又结合了一个$e_{0,0}=x$。至此算是比较清晰的解释了什么是MBA表达式 线性MBA表达式形如：$$\\sum_{i \\in I}a_i e_i(x_1,…x_t)$$线性MBA表达式是多项式MBA表达式的子集，例如：$$f(x,y)=x+y-(x \\oplus (\\lnot y)) - 2(x \\lor y) + 12564$$是一个线性MBA表达式，其变量仅两个$x,y$，而$a=\\lbrace 1,1,-1,-2,12564 \\rbrace$，对于每个$a_i$，仅右结合一个$e_i$，这是线性MBA和多项式MBA的区别。 2. 定理1:线性MBA表达式存在定理假设$n,s,t$为正整数， 变量$x_i \\in B^n, i=1,…,t$，即$x_i$形如$1011…010_{(n)}$； $a_j$是一个正整数，$j=0,1,…,s-1$; $e_j$是对$x_i$的按位表达式，$j=0,1,…,s-1$。由于该定理适用于线性MBA，因此对每个$a_j$仅右结合一个$e_j$，例如$e_j(x_1,x_2,x_3)=x_1 \\lor x_2 \\oplus x_3$,尤其需要注意的是，由于$e_j$是按位运算，因此有：$e_j(x_1,…,x_t)=\\left( \\begin{matrix} f_j(x_{1,0},…,x_{t,0}) \\\\ \\vdots \\\\f_j(x_{1,n-1},…,x_{t,n-1}) \\end{matrix} \\right) = \\left( \\begin{matrix} f_j(y_0) \\\\ \\vdots \\\\f_j(y_0) \\end{matrix} \\right)$ $e=\\sum_{j=0}^{s-1}a_j e_j$是一个线性MBA表达式，则$e_j$是一个映射：$e_j:B^{n \\times t} \\to B$，由于$B$这个二进制数可以转换成模$2^n$的整数(在计算机中整数由补码表示，假设所有整数的二进制位数为$n$，则计算机中所有的数都需要模$2^n$)，因此$e_j:B^{n \\times t} \\to Z/2^n$，同样的,$e:B^{n \\times t} \\to Z/2^t$； $F=\\left( \\begin{matrix} f_0(0) \\cdots f_{s-1}(0) \\\\ \\vdots \\\\f_0(2^t-1) \\cdots f_{s-1}(2^t-1) \\end{matrix} \\right)$是一个$2^t \\times s$的矩阵，表示$f_j$对每一bit位操作的所有可能的值，在Zhou的论文中说$F$是一个真值表； $V=(a_0,…,a_{s-1})^T$； $e=0$当且仅当$F \\cdot V = 0$在环$Z/2^n$上有非平凡的解。 3. 证明对于定理中的第5点，$F$为什么是$2^t \\times s$，原因是，首先$f_j$也就是$e_j$总共有$s-1$个不同的表达式，这是列数为$s$的原因，其次，$y_i$是一个$t \\times 1$的向量，$y_i$中的每个分量都是从$x_j$中第$i$个位置取出，例如$y_i=(1,0,1)$，那么对这个$t$位的$y_i$，其可能取值自然是$(0,1,…,2^t-1)$，也就有了$f_j$所有可能的取值是$(f(0),f(1),…,f(2^t-1))$，矩阵因此而来。 假设$F \\cdot V = 0$，有：$\\forall x_1,…x_t \\in B^n, y_i = (x_{1,i},…,x_{t,i}), i=0,…,n-1$,$$e(x_1,…,x_t)=\\sum_{j=0}^{s-1}a_je_j(x_1,…,x_t)$$ 对于$e_j$有:$$e_j(x_1,…,x_t) = [f_j(y_0),…,f_j(y_{n-1})] = \\sum_{i=0}^{n-1}2^i f_j(y_i) \\tag{1}$$例如，$(x_1,x_2,x_3) = (101,110,001)$，且$e_j(x_1,x_2,x_3)=x_1 \\land x_2 \\oplus x_3$,则将$x_1,x_2,x_3$代入后可得$e_j(x_1,x_2,x_3)=101=5$,因为$e_j$是按位运算，因此可以把$e_j$拆分为$n$个$f_j$，每个$f_j$都是相同的，且每个$f_j$都是对一个不同变量的同一bit位操作的，这样就可以得到$e_j(x_1,x_2,x_3) = e_j(101,110,001)=[f_j(110), f_j(010), f_j(101)]=2^0f_j(110) + 2^1f_j(010) + 2^2f_j(101) = 5$;将$(1)$带入$e$中可以得到：$$e = \\sum_{j=0}^{s-1}a_j e_j(x_1,…x_t) = \\sum_{j=0}^{s-1}a_j \\sum_{i=0}^{n-1}2^if_j(y_i)=\\sum_{i=0}^{n-1}2^i \\sum_{j=0}^{s-1}a_j f_j (y_i) \\tag{2}$$在$F \\cdot V=0$中，有$\\left(\\begin{matrix} \\vdots \\\\f_0(y_i) \\cdots f_{s-1}(y_i) \\\\ \\vdots \\end{matrix} \\right) \\cdot \\left( \\begin{matrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{s-1}\\end{matrix} \\right) = \\left( \\begin{matrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0\\end{matrix} \\right)$,即$\\sum_{j=0}^{s-1}a_j f_j(y_i)=0$,代入$(2)$中可以得到：$$(2)=\\sum_{i=0}^{n-1}2^i \\sum_{j=0}^{s-1}a_j f_j (y_i)=\\sum_{i=0}^{n-1}2^i \\times 0 = 0$$以上证明了$F \\cdot V = 0 \\Rightarrow e = 0$,下面证明$e=0 \\Rightarrow F \\cdot V = 0$: 假设$e \\equiv 0$，令$m_i = \\sum_{j=0}^{s-1}a_j f_j (x_{1,i}, … , x_{t,i})$，则有：$$e=\\sum_{i=0}^{n-1}2^i \\cdot m_i = 2^0m_0 + 2^1m_1 +…+2^{n-1}m_{n-1} \\equiv 0 \\tag{3}$$假定我们有任意输入$x_{1,k},…,x_{t,k}$，且其$m_k = \\bar{m} \\not = 0$,则将其代入$(3)$中有：$$e=2^0 \\bar{m} + 2^1 \\bar{m} +…+2^{n-1} \\bar{m} \\equiv 0 \\Rightarrow \\bar{m} = 0$$但是$\\bar{m}=0$与假设的$\\bar{m} \\not = 0$矛盾，因此可以得出结论对任意的$m_i$都有$m_i=0$，即$\\sum_{j=0}^{s-1}a_j f_j (x_{1,i}, … , x_{t,i})=0$，进而有$F \\cdot V = 0$.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Information Security","slug":"Computer-Science/Information-Security","permalink":"http://w4ow.github.io/categories/Computer-Science/Information-Security/"}],"tags":[{"name":"MBA","slug":"MBA","permalink":"http://w4ow.github.io/tags/MBA/"}]},{"title":"Latex常见数学符号整理","slug":"CS/Tools/Tex_manual","date":"2019-09-22T03:00:00.000Z","updated":"2022-02-27T08:41:22.988Z","comments":true,"path":"2019/09/22/CS/Tools/Tex_manual/","link":"","permalink":"http://w4ow.github.io/2019/09/22/CS/Tools/Tex_manual/","excerpt":"LaTeX常见数学符号整理","text":"LaTeX常见数学符号整理 1. 数学模式重音符 Show Code $\\hat{a}$ \\hat{a} $\\check{a}$ \\check{a} $\\tilde{a}$ \\tilde{a} $\\acute{a}$ \\acute{a} $\\grave{a}$ \\grave{a} $\\dot{a}$ \\dot{a} $\\ddot{a}$ \\ddot{a} $\\breve{a}$ \\breve{a} $\\bar{a}$ \\bar{a} $\\vec{a}$ \\vec{a} 2. 小写希腊字母 Show Code $\\alpha$ \\alpha $\\theta$ \\theta $o$ o $\\upsilon$ \\upsilon $\\beta$ \\beta $\\vartheta$ \\vartheta $\\pi$ \\pi $\\phi$ \\phi $\\gamma$ \\gamma $\\iota$ \\iota $\\varpi$ \\varpi $\\varphi$ \\varphi $\\delta$ \\delta $\\kappa$ \\kappa $\\rho$ \\rho $\\chi$ \\chi $\\epsilon$ \\epsilon $\\lambda$ \\lambda $\\varrho$ \\varrho $\\psi$ \\psi $\\varepsilon$ \\varepsilon $\\mu$ \\mu $\\sigma$ \\sigma $\\omega$ \\omega $\\zeta$ \\zeta $\\nu$ \\nu $\\varsigma$ \\varsigma $\\eta$ \\eta $\\xi$ \\xi $\\tau$ \\tau 3. 大写希腊字母 Show Code $\\Gamma$ \\Gamma $\\Lambda$ \\Lambda $\\Sigma$ \\Sigma $\\Psi$ \\Psi $\\Delta$ \\Delta $\\Xi$ \\Xi $\\Upsilon$ \\Upsilon $\\Omega$ \\Omega $\\Theta$ \\Theta $\\Pi$ \\Pi $\\Phi$ \\Phi 4. 二元关系符该表中的所有符号都可以通过在代码前加上\\not来得到其否定形式。 Show Code $&lt;$ &lt; $&gt;$ &gt; $=$ = $\\le$ \\le $\\ge$ \\ge $\\equiv$ \\equiv $\\ll$ \\ll $\\gg$ \\gg $\\doteq$ \\doteq $\\sim$ \\sim $\\simeq$ \\simeq $\\approx$ \\approx $\\subset$ \\subset $\\supset$ \\supset $\\cong$ \\cong $\\subseteq$ \\subseteq $\\supseteq$ \\supseteq $\\Join$ \\Join$^a$ $\\in$ \\in $\\ni$ \\ni $\\propto$ propto $\\mid$ \\mid $\\parallel$ \\parallel $:$ : $^a$使用宏包latexsym来得到这个符号 5. 二元运算符 Show Code $+$ + $-$ - $\\cdot$ \\cdot $\\pm$ \\pm $\\mp$ \\mp $\\div$ \\div $\\times$ \\times $/$ / $\\setminus$ \\setminus $\\star$ \\star $\\ast$ \\ast $\\circ$ \\circ $\\cup$ \\cup $\\cap$ \\cap $\\bullet$ \\bullet $\\lor$ \\lor $\\land$ \\land $\\oplus$ \\oplus $\\odot$ \\odot $\\boxplus$ \\boxplus 6. 大尺度运算符 Show Code $\\sum_{1}^{2}$ \\sum_{1}^{2} $\\prod_{1}^{2}$ \\prod_{1}^{2} $\\int_{1}^{2}$ \\int_{1}^{2} 7. 箭头 Show Code $\\gets$ \\gets $\\to$ \\to $\\leftrightarrow$ \\leftrightarrow $\\Leftarrow$ \\Leftarrow $\\Rightarrow$ \\Rightarrow $\\Leftrightarrow$ \\Leftrightarrow $\\mapsto$ \\mapsto 8. 定界符 Show Code $($ ( $)$ ) $\\left( \\right)$ \\left( \\right) $\\lbrace \\rbrace$ { } or \\lbrace \\rbrace 9. 其他符号 Show Code $…$ … $\\cdots$ \\cdots $\\vdots$ \\vdots $\\ddots$ \\ddots $’$ ‘ $\\prime$ \\prime $\\triangle$ \\triangle $\\infty$ \\infty $\\bot$ \\bot $\\top$ \\top $\\angle$ \\angle $\\surd$ \\surd $\\nabla$ \\nabla $\\heartsuit$ \\heartsuit $\\clubsuit$ \\clubsuit $\\spadesuit$ \\spadesuit $\\neg$ \\neg or \\lnot $\\exists$ \\exists $\\emptyset$ \\emptyset $\\partial$ \\partial $\\forall$ \\forall 10. 各种帽子 Show Code $\\hat{A}$ \\hat{A} $\\widehat{A}$ \\widehat{A} $\\tilde{A}$ \\tilde{A} $\\widetilde{A}$ \\widetilde{A} $\\overline{A}$ \\overline{A} $\\underline{A}$ \\underline{A} $\\overbrace{A}$ \\overbrace{A} $\\underbrace{A}$ \\underbrace{A} $\\overset{b}{A}$ \\overset{b}{A} $\\underset{b}{A}$ \\underset{b}{A} $\\overleftarrow{A}$ \\overleftarrow{A} $\\overrightarrow{A}$ \\overrightarrow{A} 11. 字符样式 字样 命令 宏包 $\\mathrm{ABCabc}$ \\mathrm{ABCabc} $\\mathit{ABCabc}$ \\mathit{ABCabc} $\\mathcal{ABCabc}$ \\mathcal{ABCabc} $\\mathfrak{ABCabc}$ \\mathfrak{ABCabc} eufrak $\\mathbb{ABCabc}$ \\mathbb{ABCabc} amsfonts or asmsymb","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Tex","slug":"Tex","permalink":"http://w4ow.github.io/tags/Tex/"}]},{"title":"基于Mixed Boolean-Arithmetic的混淆","slug":"CS/Security/Obfuscation with Mixed Boolean-Arithmetic","date":"2019-09-16T05:00:00.000Z","updated":"2019-10-11T08:41:00.000Z","comments":true,"path":"2019/09/16/CS/Security/Obfuscation with Mixed Boolean-Arithmetic/","link":"","permalink":"http://w4ow.github.io/2019/09/16/CS/Security/Obfuscation with Mixed Boolean-Arithmetic/","excerpt":"基础介绍","text":"基础介绍 Introduction软件保护用于保护程序免受不必要的分析，程序混淆是软件保护的一种手段。程序混淆是指对代码进行转换使程序变的难以理解。混淆以两种主要方式隐藏程序的语义：1.改变code和data(例如，改变数据的值)，2.添加无关信息(例如垃圾代码)。MBA(Mixed Boolean-Arithmetic)混淆技术结合两种方法来混淆常见的数学表达式，例如重写运算符、引入新的运算符和常量等。 1. Background1.1 程序混淆的定义及应用混淆是对程序的动态转换行为，其目的是使程序的分析变的困难，同时保证程序的可观察性。 混淆通常有四个属性： 功能：混淆后的程序必须具有与原始程序相同的功能； 效率：与原始程序相比，混淆后的程序的大小和执行时间必须是可接受的； 健壮性：混淆程序必须比原始程序更难分析； 正确性：混淆后的程序应当与源程序有相同的语义和功能。 软件混淆应用领域包括软件加密、打包、反调试或防篡改等，应用范围包括但不限于： 恶意检测：避免恶意软件的恶意检测； 保护知识产权：保护商业软件中的算法或协议； 权限管理：无论是通过许可检查来保护对软件的访问，还是通过数字版权管理(DRM)方案保护数字内容，这些技术通常都会嵌入关键信息(例如加密密钥和协议)，并且使用混淆来保护这些信息。嵌入在程序中的DRM方案(例如VOD服务或视频游戏保护)目前是现代环境中混淆的主要来源之一； 保护个人敏感数据：例如，在移动应用程序中，设备中保存了大量敏感数据(例如银行帐户详细信息)。混淆可以保护这些数据以及处理数据的协议。 1.2 理论混淆和实际混淆1.2.1 密码混淆密码混淆旨在为混淆提供一个正式的上下文，特别是围绕量化分析给定程序$P$的混淆程序$\\mathcal O(P)$的难度。 软件混淆的正式研究由Barak等人发起，他们引入了虚拟黑匣子(VBB)的概念作为混淆程序的最佳属性。VBB保证任何可以从程序$\\mathcal O(P)$的输入/输出行为中学到的，从$P$中也可以学到。 Barak提出了不可区分混淆的定义：如果两个相同大小的程序P1和P2实现相同的功能，则它们的混淆$\\mathcal O(P_1)$和$\\mathcal O(P_2)$应无法区分。 Goldwasser等人提供了最佳可能混淆的定义：从$\\mathcal O(P)$中提取的任何信息都可以通过类似大小的其他功能相同的的程序取得。 他们还证明，对于有效的混淆器，不可区分混淆和最佳混淆是等价的。 2013年，Garg等人提出了通用的不可区分混淆，该混淆基于三个组成部分：作为计算模型的分支程序，完全同态加密和多线性映射。 1.2.2 实际混淆密码混淆在实际上难以应用，因此商用混淆一般都是基于不同程序转换的组合。一些最常用的商用混淆有strong.protect和Arxan3。混淆主要在以下三个层次上工作： 源代码混淆在源代码上操作的混淆，这种混淆能够充分利用编程语言的特性。因为混淆步骤是在编译之前进行的，因此它也更容易集成到现有的编译链中。这种方法的主要缺点是对不同的语言需要设计不同的混淆。 中间代码混淆IR设计的目的之一是独立于任何源语言或目标语言，因此在IR上进行混淆更加通用，能够处理不同高级语言和汇编语言的程序，但同时这种混淆集成更加困难，因为很难将混淆器添加到现有的编译工具链中。 汇编语言混淆与IR和源码相比，汇编级混淆会导致大量信息的丢失，因此很难实现仅在汇编时工作的通用混淆器。 1.3 程序分析程序分析指对程序进行分析，从而得到有用信息。从反汇编程序中可以推断出控制流和数据流两种不同的信息，因此可以从数据流和控制流两种不同的角度分析程序。 控制流：程序的控制流规定了程序的执行过程，通常用Control Flow Graph(CFG)和Call Graph(CG)表示控制流。在CFG中，节点被称为Basic Block(BB)，每一个BB包含多条指令，并且BB中的代码都是顺序执行的。而CFG中的edge则表示BB之间的可能执行路径。在CG中，节点代表一个函数，边代表函数之间的调用。 数据流：和控制流不同，数据流没有固定的图形表示：不同的数据流分析会产生不同的表示。典型的数据流分析是到达定义，该分析中包括确定每个变量可能已定义的位置。这些信息可以从CFG中观察每个BB的输入和输出提取。 程序分析的手段也分为两类： 静态分析程序的静态分析无需执行程序，而是分析程序源码(可通过反汇编获得，但反汇编通常比较困难)。静态分析的第一步通常是重建函数的CFG或程序的CG(可以利用工具)。为了模拟程序的运行，可以使用符号执行。静态分析可以安全分析潜在恶意二进制文件，因为不需要执行。但是由于静态分析会分析程序所有可能的执行路径，所以可能会导致过度分析。 动态分析程序的动态分析是在特定输入上完成的，并推断出所采用的执行路径和数据修改的信息。由于仅分析了可能的执行路径的子集，因此可能导致分析不足。动态分析的例子包括： 调试：在执行期间，逐步或使用断点以交互方式观察程序。 跟踪：记录每条执行的指令，并离线分析(执行后)。 数据污染：标记一个或多个变量，并在程序执行时观察它们对程序的影响。 大多数动态分析技术也可以静态地用于符号执行。 1.4 经典混淆技术1.4.1 控制流混淆几种简单地控制流混淆技术：inlining和outlining、Opaque Predicate、Control Flow Flattening等 inlining &amp; outlining内联指用程序本身来代替对函数g的调用。即，若函数$f$调用函数$g$，则可以使用内联将函数$g$的代码插入到函数$f$中，使两者成为一体，从而省去调用。外联则相反，是将函数内一段代码独立成一个函数。这两种技术都能够达到修改函数的CFG和CG的目的，但不修改程序的功能，从而达到控制流混淆的技术。 Opaque Predicate不透明谓词是是控制流复杂化的混淆技术，这种方法可以再混淆工具Obfuscator-LLVM中找到。传统的不透明谓词用于在CFG中创建伪分支。例如，$$\\forall x, y \\in \\mathbb{N}, \\mathrm{if} \\ x = y^2,\\mathrm{then} \\ P = (x \\equiv 0\\ mod\\ 4) \\vee (x \\equiv 1\\ mod\\ 4) \\equiv True $$上面的例子中$P$的值始终为$true$，则$P=flase$的分支将永远不会执行，那么就可以在这些不会被执行的路径中插入垃圾代码以达到混淆的目的。应对不透明谓词的方法通常是通过使用符号执行来收集不透明谓词，并使用SMT求解器来解决混淆。 Control Flow Flattening控制流扁平化的想法是通过在数据流中编码控制流的信息来完全改变函数CFG的结构。实现此目的的一种方法是为BB编号，并创建一个使用变量管理执行的调度程序，该变量确定BB的执行顺序。在每个BB的末尾，变量都会更新，执行将返回到调度程序。 1.4.2 数据流混淆常见数据流混淆技术：变量拆分、改变变量表示、编码等。 变量拆分将一个变量拆分为多个变量，可以增加程序分析的难度。例如：$$\\mathcal{O}(x) \\to x_1 \\times a + x_2$$其中$\\mathcal{O}(x)$代表混淆转换，即将变量$x$拆分为$x_1, x_2$等。 改变变量表示通过改变变量的表示形式，可以隐藏变量的值以及应用与于变量的操作。例如，一般计算机中使用二进制表示整数，可以通过改成使用三进制表示整数从而达到隐藏数据的目的 编码编码是最常见的数据流混淆技术之一。编码旨在防止变量的值在程序执行过程中显式的出现在内存中。这项技术被借用到密码白盒领域。实际上，混淆中的编码通常是仿射函数，因为它们很容易相互转换并且在性能开销较小。传统上，变量必须在进行计算之前先解码，计算之后还需重新编码。 1.4.3 白盒白盒加密技术是加密技术和实际混淆技术之间的交叉领域，其目的是在白盒攻击环境中保护程序中的加密算法，即程序的运行环境是可控的。与理论上可以应用于任何程序并隐藏数据或算法的混淆相比，只有加密算法是白盒，并且该过程可以使用算法的特殊性来帮助隐藏所使用的密钥。白盒密码术是混淆密码算法中的重要概念，通常是混淆器中必不可少的。 1.5 混淆技术的评价指标程序的复杂性是指其： 指令数量 控制流复杂性 数据流复杂性 因此Collberg等人基于此提出了三种指标来评价混淆转换： Potency：即上述提及的程序的复杂度，如果混淆转换增加了程序复杂性，则它是有效的转换。在论文MBA-Blast中提到可以通过4中方法增加程序复杂性：(1)增加布尔运算符和算术运算符的数量；(2)引入新的整数或bit向量；(3)隐藏真实参数；(4)打乱计算顺序。 Resilience：即混淆对反混淆的健壮性。 Cost：主要分为两部分：产生混淆程序的代价，以及与原始程序相比，混淆程序所需的额外执行时间和空间。 Correctness：混淆后的程序应当与源程序有相同的语义和功能。 另一个常见的度量标准是隐身性，即检测到混淆的难度。Collberg定义了隐秘隐身(分析人员无法确定是否已应用混淆)和局部隐身(分析人员无法确定在何处应用了混淆)。 2. 已有工作2.1 MBA表达式MBA(混合布尔算数)表达式是混合了算术运算符(加法、乘法等)和布尔运算符(与、或、非等)的表达式。 2.1.1 多项式MBA表达式下面给出了一些有关MBA表达式的定义： Definition 1(多项式MBA表达式)MBA表达式$E$，$$E = \\sum_{i \\in I} a_i \\left( \\prod_{j \\in J_i} e_{i,j}(x_0,…,x_{t-1}) \\right)$$其中累和与累积是模$2^n$的，$a_i$是一个常数，$e_{i,j}$是变量$x_0,…,x_{t-1} \\ in \\ \\lbrace 0,1 \\rbrace ^n$的按位表达式，具体公式参加论文。根据定义，多项式MBA表达式的组合仍然是多项式MBA表达式。为简洁起见，本文其余部分中的“MBA表达式”一词代表多项式MBA表达式。此外，本研究仅限于常用的运算符：算术{+，-，×}和布尔值{∧，∨，⊕，¬}，对于此类运算符，我们同时使用按位和布尔项。 2.1.2 基于MBA的混淆表达式的混淆使用MBA表达式混淆运算符的过程依赖于两部分： MBA重写：用等效的MBA表达式重写所选的运算符。 身份的插入：假定$e$是将被混淆的表达式的一部分，那么$e$可以被写为$f(f^{-1}(e))$，其中$f$为在$\\mathbb{Z}/2^n \\mathbb{Z}$上的可逆函数。在周等人的工作中，$f$是仿射函数。由于该过程与编码过程非常接近，因此我们通常将此步骤称为编码步骤。为了强化混淆的效果，还可以交替多次使用上述两个方法，交替多次使用在现实场景中十分流行。 不透明常量对于常量也可以使用MBA表达式来混淆隐藏。隐藏常量使用置换多项式，它们是$\\mathbb{Z}/2^n \\mathbb{Z}$上的可逆多项式。常数混淆(或不透明常数)按以下方式构造： 令多项式$P \\in P_m(\\mathbb{Z}/2^n \\mathbb{Z})$，$Q$是$P$的反函数：$P(Q(X))=X, \\forall X \\in \\mathbb{Z}/2^n \\mathbb{Z}$ 令$K\\in \\mathbb{Z}/2^n \\mathbb{Z}$是想要隐藏的常量 令$E$是变量$(x_1,…,x_t)\\in (\\mathbb{Z}/2^n \\mathbb{Z})^t$非平凡等于0的MBA表达式，例如$E=x+y-(x\\oplus y)-2\\times (x\\land y)$ 那么$K$可以被$P(E+Q(K))=P(Q(K))=K$替换，无论$(x_1,…,x_t)$取何值该替换始终成立。 2.1.3 生成新的MBA等式Zhou等人提供了一个生成新的MBA等式的方法，该方法是从定理1中推导出来的的： Theorem 1令$n$是bit位数，$s$为按位表达式的数量，$t$为变量的数量，令 $(X_1,…,X_k,…,X_t) \\in \\lbrace \\lbrace 0, 1 \\rbrace ^n \\rbrace ^t$是变量的n位表示的向量 $e_0,…,e_j,…,e_{s-1}$是按位表达式 $e = \\sum_{j=0}^{s-1} a_j e_j$是一个线性MBA表达式，有$a_j$个整数 后续见论文 2.2 表达式简化对表达式进行简化有两种方法： 计算两个相等对象的统一表示(规范形式) 寻找一个相等，但更简洁的表示形式 第一种简化方法是研究最多的，因为它可以证明表达式的等价性并检查是否等于零。但是，规范形式未必是最简单的形式。由于混淆的设计既可以应对人工分析和自动分析，因此程序和表达式的简洁性定义是二义的：对于人类而言，可读性更重要；而对于机器而言，性能问题则更重要。 算术多项式的简洁性难以定义，例如：$$(x-3)^2-x^2+7x-7=x+2$$$$(1+x)^100=1+100x+…+100x^99+x^100$$有时多项式展开后更简洁，有时不展开更易读。 布尔函数的简化通常是将表达式规约为范式。 2.3 比特向量逻辑计算机系统需要一个适合于机器逻辑的框架，用以描述元素和对这些元素的操作。在机器级别上，对象使用位向量(例如二进制)表示，处理器上任意可用的运算可以用来构建表达式。位向量逻辑适用于这种机器表示形式：每个对象都由一个位向量表示，传统上考虑的运算符为：算术$+,-,\\times,/$，布尔值$\\oplus,\\wedge,\\lor,\\lnot$，移位$\\ll,\\gg$，串联$\\circ$等。通常实现位向量逻辑的工具是SMT求解器，例如Z3和Boolector。尽管它们是约束求解器，而不是简化器，但它们有时提供简化，例如Z3的简化函数。 2.4 术语重写重写系统由一组对象以及转换这些对象的操作组成。在术语重写的情况下，那些对象是术语(或表达式)。 2.5 DAG表示在计算机中，程序可以用抽象语法树AST和有向无环图DAG表示，同样的，表达式也可以用这两种图来表示。 Definition 5：DAG representation.MBA表达式的DAG表示是一个有下列特征的有向无环图： 所有的叶子节点表示常量或变量，其他节点表示算术操作或位操作； 边代表操作顺序； 仅有一个根节点； 公共表达式在图中仅出现一次。 值得注意的是，DAG表示与紧凑术语图表示是等价的。 2.6 优化与反混淆编译器通常具有与机器无关的优化阶段，该阶段程序的以IR表示(例如LLVM)。执行效率更高的代码其可读性较差，优化有时与反混淆有一个共同的目标。例如，消除死代码或常量替换(使用常量代替值不会改变的变量)能够提高代码可读性。某些混淆技术甚至可能无法抵抗优化过程，这类混淆实在是毫无用处。在本节中，我们介绍两种可以在理论上对任何程序进行混淆的优化技术，它们基于程序的行为而不是基于其描述：超优化和程序合成。 2.6.1 超优化超优化即为单个无循环汇编指令序列找到最佳代码。一般最佳代码是指执行最快的代码，或者时代码体积择最小的代码。Massalin等提出的超优化方法时暴力法，它列举了增加长度的指令序列，并选择与目标序列等价的最低成本序列。 尽管超优化在一些混淆中是有用的，但它不能运行在我们定义的上下文中，否则会导致两个问题： 对于超优化来说，最佳代码的定义基于性能(更快、更小)，这与我们的可读性目标不同； 与混淆相比，优化的对象的代码长度较小(例如优化只能操作10余条指定，而混淆可以操作更多)。 2.6.2 程序合成程序合成是根据用户意图自动寻找可执行程序的过程，这种意图是通过各种形式的约束来表达的，例如输入输出示例、演示、自然语言等。程序合成已经有了许多实际应用：生成最佳代码序列（超优化可以看作是程序合成的特殊情况）、自动执行重复的编程任务、优化对性能至关重要的内部循环等。 3. MBA简化的难点3.1 操作符不兼容布尔运算和算术运算难以交互，因此需要特殊方法来处理混合计算。IDEA是90年代提出分组密码，以结合使用整数算术和按位运算符而闻名。IDEA的主要特征之一是缺少S盒，取而代之的是，它依赖于三个关键组件： 乘法$\\odot$ 加法$\\boxplus$ 位异或$\\oplus$ IDEA的方法为本工作中的混合计算提供了灵感。同样的，密码学中加密的研究和混淆也有许多相似之处。 3.2 已有的MBA简化工具1. SMT求解器 位向量逻辑是处理MBA表达式的良好理论框架，实现位向量逻辑的工具有SMT求解器。SMT求解器包括Z3、Boolector、Yices。Z3使用位向量的原理，提供了多项式简化以及布尔运算简化，同时prove方法能够实现证明MBA表达式及其简化之间的等价性。但是Z3对于本文要解决的MBA表达式，其处理效率并不高，Z3中提出的两个步骤很有启发：第一个是重写，用以执行基本简化，重写通常是SMT求解器中所谓的预处理部分。第二步称为位爆破(也称为平整化)，即用二进制数代替整数重写整个公式。Boolector和Yices不能简化MBA表达式，只能证明MBA表达及其简化是等效的。 编译器中的优化pass 现代编译器(如LLVM)中的优化pass可以简化部分的MBA表达式，但是对复杂MBA就显得无能为力了。 3.3 表达式的复杂性指标对一个MBA表达式，其复杂性的定义是比较困难的。例如表达式$x+y$和$(x \\lor y) + (\\lnot x \\lor y) - (\\lnot x)$，两个表达式对任意输入$x,y$，其计算结果都是相同的，但是左侧明显比右侧更简洁。如何科学的定义表达式的复杂性，这里介绍几个常用的指标。 1. DAG节点数 由于可以使用DAG来表示一个expression，因此可以用DAG的节点数来衡量表达式的复杂性，节点越多越复杂。 2. MBA交替 MBA运算之所以复杂，是因为它混合了布尔计算和算术计算，因此可以使用MBA交替来衡量连接不同类型操作的操作数。例如$x \\land y + x$，该表达式的MBA交替为1。纯算术或纯布尔表达式的MBA替换为0。我们定义操作符$op \\in \\lbrace +,-,\\times, \\oplus,\\wedge,\\lor,\\lnot \\rbrace$，则MBA交替是DAG中连接不同类型的运算符的边的数目。即：对于一个图$G=(V,E)$，其MBA交替$alt_{MBA}(G)$是：$$alt_{MBA}(G) = |\\lbrace (v_1, v_2), type(v_1) \\not = type(v_2) \\rbrace |, (v_1, v_2) \\in E$$这些边代表了简化MBA表达式的难点，因为包含相同类型边的子图可以通过经典简化技术进行简化，而包含不同类型的子图则很难简化。 3. 平均位向量大小 在Obfuscation with Mixed Boolean-Arithmetic Expressions这篇文献中还提到了一个称为平均位向量大小的指标。在DAG中，对于一个节点$v$，其位向量大小$bvsize(v)$是： 若$v$是不是操作符，则它表示变量或常量的位数，位数可以从上下文中推导。 若$v$是操作符： 若$v \\in \\lbrace +,-,\\times, \\oplus, \\lor \\rbrace$，且$v_1,v_2$为操作对象，则$bvsize(v)=max(bvsize(v_1),bvsize(v_2))$，即位数最大的那个； 若$v$为布尔操作$\\land$，则$bvsize(v)=min(bvsize(v_1),bvsize(v_2))$，即位数最小的那个，例如$0b10110101 \\land 0b1111$，前者的高四位经操作后都为0，所以取后者位数； 若$v$为一元操作符$\\lbrace \\lnot, - \\rbrace$，则$bvsize(v)=bvsize(v_1)$。 增加变量的位数，可能会使混淆的破解变难罢了，但是变量位数的增加对表达式的复杂性并无影响，因此位向量大小作为评价表达式的复杂性无多大意义。 4. MBA混淆技术分析本章介绍如何对表达式进行混淆和去混淆。随后提出了基于位和基于字的两种方法。两种方法在GitHub上都可找到：arybo是用C和Python实现的，并且是基于位爆方法的；SSPAM是用Python实现的，并且可以通过使用模式匹配在字级上工作。 4.1 手动重建混淆过程4.1.1 从汇编到源码使用Miasm逆向工程框架生成了混淆表达式的Python代码，并删除了与标志有关的表达式。源码以及反汇编的Python代码可参见论文图4.1、图4.2，得到的最终表达式见论文。 4.1.2 其他混淆在分析该MBA混淆表达的示例时，必须对其进行简化，以便排除与MBA混淆不相关的技术。 位向量尺寸扩展在4.1.1中得到的表达式中，有两条是这样的：$$f=((0x0D000000+0x67000000 \\times (e+e-(0xFF \\land d))) \\gg 0x18)$$$$R = (0xFF \\land (0xC2 + 0xE5 \\times (0x22 \\lor (0xAE)f) + (0xFFFFB22D)f))$$最终结果$R$是8位的(因为与上8位的0xFF)，所以可以将所有的表达式都简化为8位。但是由于存在位移操作，作者的做法是将$f$中的常量右移了24位，其余的都是直接截取后8位，最后再将16进制数转换成10进制。 编码1.4.2节中介绍了使用编码的数据流混淆技术：相关变量在写入内存之前先进行编码，然后在读取时进行解码。传统上编码是一个仿射函数。 因此，此处作者使用了编码函数$x \\mapsto 229x + 247$，解码函数为$x \\mapsto 237 \\times (x-247)$。 4.1.3 MBA表达式的反混淆本节举例介绍了如何得出混淆表达式，很多推导没看懂，在此不再整理。 4.2 使用位爆炸的简化第一个简化方法是基于比特向量逻辑，即位爆炸方法。 4.2.1 描述操作布尔表达式的范式是代数范式ANF，ANF是只包含$\\oplus$和$\\land$的表达式。 5. MBA混淆技术的健壮性5.1 MBA混淆应对黑盒攻击的健壮性黑盒共计通过程序的输入和输出来推断程序的信息，为此通常要考虑两个问题：找到一个函数的良好近似需要多少个输入/输出对，以及应该使用哪种算法来构建该近似，在黑盒中重构函数的难度通常取决于函数本身，有几种策略可以提高重构函数的难度： 添加不影响计算结果的变量； 增加位向量的大小，因为这会增加可能的重构函数的解空间； 增加表达式的节点数，因为这也会减慢输入/输出对的计算。操作符混合并不能明显提高对黑盒攻击的抵抗性，因为它仅能减缓黑盒攻击的速度，而不能使反混淆攻击失败。 5.2 针对简化工具的弹性因为简化工具使用表达式的实际描述，因此它是白盒攻击。 5.2.1 位爆炸爆破方法的最大优势是将MBA简化问题转换为布尔表达式简化问题，该领域已经有很多前人展开过工作。使用位爆炸法时，我们可以使用几种范式来为任何表达式提供唯一的表示形式。位爆炸的主要缺点是布尔表达式的规范化在内存和时间上代价很高。另一个问题是，从布尔表达式到字级表达式的识别并不容易。在尝试识别一个运算符时，我们提供了一些技巧，但是识别包含多个运算符的更复杂表达式的问题显然是将来需要解决的问题。作者使用arybo工具反混淆了几个MBA混淆表达式，当表达式位数为8位时只用了0.09s就能正确识别出原始表达式，但是当表达式位数为12位时，解析时间达到了61.32s。对于位数量较少的表达式，使用位爆破的简化非常有效。因此，可以通过提高位数来提高MBA混淆表达式的弹性。不过，作者在3.4.3节中介绍的还原方法可以轻松简化这种混淆。 5.2.2 符号简化因为使用符号简化的算法在字级别上起作用，所以简化不受表达式位数增加的影响，另外，AST表达式的“大小”也远小于位爆破方法中的表示。例如，x+y在字级具有3个节点，可容纳任意数量的位；而4位的位爆破法则有3、6、17、41个节点。这种方法的主要缺点是，它高度依赖于所选的重写规则集。即使具有所有混淆规则的列表，也不能保证具有令人满意的反混淆。对于该种方法，作者使用了SSPAM工具来进行测试。对于使用一般混淆(公共可用)的混淆方法混淆的表达式，SSPAM都能够很快的进行发混淆。随后作者又使用Algorithm 2对原表达式进行混淆，每个表达式都会生成20个混淆表达式，这些混淆表达式作为输入送入SSPAM中，SSPAM不能从20个混淆表达式中成功反混淆出原表达式。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Information Security","slug":"Computer-Science/Information-Security","permalink":"http://w4ow.github.io/categories/Computer-Science/Information-Security/"}],"tags":[{"name":"MBA","slug":"MBA","permalink":"http://w4ow.github.io/tags/MBA/"}]},{"title":"Install Syntia with Ubuntu 18.04","slug":"CS/Security/syntia_install","date":"2019-09-08T16:00:00.000Z","updated":"2019-09-08T16:00:00.000Z","comments":true,"path":"2019/09/09/CS/Security/syntia_install/","link":"","permalink":"http://w4ow.github.io/2019/09/09/CS/Security/syntia_install/","excerpt":"Syntia是基于程序合成的反混淆框架，它使用程序跟踪作为一个blackbox来产生随机的输入输出对，利用这些输入输出对，程序合成器可以学习代码的底层语义。本文介绍了Ubuntu下安装syntia","text":"Syntia是基于程序合成的反混淆框架，它使用程序跟踪作为一个blackbox来产生随机的输入输出对，利用这些输入输出对，程序合成器可以学习代码的底层语义。本文介绍了Ubuntu下安装syntia 1. 下载源码1git clone https://github.com/RUB-SysSec/syntia 2. 安装第三方Python库Syntiasyntia是一个第三方Python库，使用的是Python2。为了避免Python版本紊乱，可以使用conda创建一个Python2.7的虚拟环境，在该环境中安装syntia。在下载的源码中有setup.py文件，使用下面命令可以安装该Python库： 1python setup.py install 3. 安装依赖软件依赖软件包含在install_deps.sh脚本文件中，原则上可以通过执行该脚本文件来安装4个依赖，但是实际操作却总是报错。因此我使用手动安装 3.1 安装Unicorn12345678910111213# 使用git下载源码git clone https://github.com/unicorn-engine/unicorn.gitcd unicorn# compile./make.sh# installsudo ./make.sh install# 验证，命令执行后出现success，可认为是安装成功了./samples/sample_all.sh 3.2 安装Capstone12345678910111213# 使用git下载源码git clone https://github.com/aquynh/capstone.gitcd capstone# compile./make.sh# installsudo ./make.sh install# 验证，我也不清楚验证结果是什么样代表正确安装./tests/test* 3.3 安装Miasm1234567891011121314151617181920212223# 1. 安装额外Python依赖库# 使用git下载源码git clone https://github.com/serpilliere/elfesteem.git elfesteemcd elfesteempython setup.py buildpython setup.py install# 2. 安装miasmcd ..# 使用git下载源码git clone https://github.com/cea-sec/miasm.gitcd miasmpython setup.py buildpython setup.py install# 验证# 可以通过在Python编程环境中import miasm来验证，若不报错则说明成功安装 3.4 安装Z31234567891011# 使用git下载源码git clone https://github.com/Z3Prover/z3.gitcd z3python scripts/mk_make.py --pythoncd buildmakemake install # 该语句执行后会打印 Z3 was successfully installed.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Information Security","slug":"Computer-Science/Information-Security","permalink":"http://w4ow.github.io/categories/Computer-Science/Information-Security/"}],"tags":[{"name":"MBA","slug":"MBA","permalink":"http://w4ow.github.io/tags/MBA/"}]},{"title":"熵权法","slug":"Math/entropy-weight-method","date":"2019-09-04T16:00:00.000Z","updated":"2019-09-04T16:00:00.000Z","comments":true,"path":"2019/09/05/Math/entropy-weight-method/","link":"","permalink":"http://w4ow.github.io/2019/09/05/Math/entropy-weight-method/","excerpt":"熵权法计算权值，Python3实现","text":"熵权法计算权值，Python3实现 1. 输入矩阵假设计算矩阵为：$$x =\\begin{bmatrix}1 &amp; 2 &amp; 2 \\\\2 &amp; 1 &amp; 1\\end{bmatrix}$$ 2. 极差标准化评价指标分为正指标和逆指标，计算公式如下 $$x_{ij}’=\\frac{x_{ij} - \\min_{j=1}^n x_{ij}}{\\max_{j=1}^n x_{ij} - \\min_{j=1}^n x_{ij}}$$ 此处仅展示正指标计算公式。将所有指标都视为正指标，标准化后的$x=[[0,1,1],[1,0,0]]$，可以使用scikit learn库中的MinMaxScaler()方法对数据进行最大最小归一化。 3. 计算指标信息熵信息熵是一个对象所能提供的信息量大小的量化指标，其范围在$(0,1)$之间。 $e$应当为$1*n$大小的矩阵，式中$e_j$代表第$j$项指标的信息熵，信息熵的计算公式为：$$e_j = (-\\frac{1}{\\ln m})\\sum_{i=1}^m (p_{ij} \\cdot \\ln p_{ij})$$其中$p_{ij}$为第$j$个指标的状态为$i$时的概率，即$$p_{ij}= \\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}}$$因此$$e_j = (-\\frac{1}{\\ln m})\\sum_{i=1}^m (\\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}} \\cdot \\ln(\\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}}))$$应用到上述矩阵，可以得到$e=[0.9183, 0.9183, 0.9183]$即 指标名称 信息熵 指标1 0.9183 指标2 0.9183 指标3 0.9183 4.计算指标权重$w$应当为$1*n$大小的矩阵，式中$w_j$代表第$j$项指标的权重$$w_j = \\frac{1 - e_j}{\\sum_{j=1}^n (1-e_j)}$$应用到上述$e$，可以得到$w=[0.33, 0.33, 0.33]$，即 指标名称 权重 指标1 0.33 指标2 0.33 指标3 0.33 5. Coding12345678910111213141516171819202122# language = python3import mathimport numpy as npimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfile = \"test.csv\"data = pd.read_csv(file, header = None)x = data.values.astype(np.float64)x_std = MinMaxScaler().fit_transform(x)def Entropy_Weight(data): m, n = np.shape(data) p = data / data.sum(axis = 0) p[np.where(data == 0)] = 0.01 e = (-1.0 / np.log(m)) * np.nan_to_num(np.sum(p * np.log(p), axis = 0)) w = (1 - e) / np.sum(1 - e) return ww = Entropy_Weight(x_std)","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/tags/Mathematics/"}]},{"title":"常见排序算法总结与比较","slug":"CS/Algorithm/sort","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-07T16:00:00.000Z","comments":true,"path":"2019/08/08/CS/Algorithm/sort/","link":"","permalink":"http://w4ow.github.io/2019/08/08/CS/Algorithm/sort/","excerpt":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。","text":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。 1. 总体比较时间复杂度与稳定性 类别 名称 平均复杂度 最好情况 最差情况 空间复杂度 稳定性 交换比较类 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 交换比较类 快速排序 $O(nlogn)$ $O(n^2)$ $O(n^2)$ $O(logn)$ 不稳定 选择类 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 选择类 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 插入类 直接插入 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 插入类 二分排序 $O(n^2)$ $O(nlogn)$ $O(n^2)$ – 稳定 插入类 希尔排序 $O(nlogn)$ $O(n)$ $O(n^s)1$ $O(1)$ 不稳定 其他 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 其他 基数排序 $O(log_R B)$ – $O(log_R B)$ $O(n)$ 稳定 其他 二叉排序 $O(nlogn)$ – $O(nlogn)$ $O(n)$ 稳定 其他 计数排序 $O(n+k)$ – $O(n+k)$ $O(k)$ 稳定 其他 拓扑排序 $O(n+e)$ – – $O(n)$ – 其他 枚举排序 $O(n^2)$ – – – – 算法特性 名称 时间复杂度与初序 移动次数与初序 比较次数与初序 排序趟数与初序 每趟确定最终位置 冒泡排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 快速排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 选择排序 ❌ ❌ ❌ ❌ - 堆排序 ❌ ❌ ❌ - ⭕️ 直接插入 ⭕️ ⭕️ ⭕️ ❌ ❌ 二分排序 - - ❌ - - 希尔排序 ⭕️ - ⭕️ - ❌ 归并排序 ❌ ❌ ⭕️ - - 基数排序 ❌ ❌ ❌ - - 二叉排序 ⭕️ - - - - 计数排序 ⭕️ - - - - 拓扑排序 - - - - - 枚举排序 - - - - - 2. 冒泡排序冒泡排序是一种典型的交换排序算法，相邻两数两两⽐比较并交换，直到所有数据排序完成，每一趟排序总能够将无序队列中的最⼤/小置于队尾。适用情况: 待排序列列较小时性能较优。最坏情况: 初始序列基本有序但顺序相反最好情况: 初始序列列基本有序(没有插⼊快，因为要两两比较)应用: 对基本有序序列查前n个元素 12345678void BubbleSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) for (int j = 0; j &lt; array.size() - i; j++) if (array[j] &gt; array[j + 1]) swap(array[j + 1], array[j]);&#125; 3. 选择排序反复选择未排序序列中最大或最小元素，并将其放于已排序序列尾部，直到未排序序列长度为0 1234567891011void SelectSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) &#123; int minIndex = i; for (int j = i; j &lt; array.size(); j++) if (array[j] &lt; array[minIndex]) minIndex = j; swap(array[i], array[minIndex]); &#125;&#125; 4. 直接插入排序将数据分为有序和无序两部分，首先有序部分为空，依次从无序部分中拿出元素插入到有序序列中可能出现情况: 最后一趟开始前，所有元素都不在正确位置上最佳情况: 基本有序下，插⼊排序是最快的 123456789101112void InsertionSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 1; i &lt; array.size(); i++) &#123; int temp = array[i], j = i; while (j &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = temp; &#125;&#125; 5. 归并排序n越⼤大越好优点: 当待排序列列较大，内存一次性放不不下时，需要外部排序，通常使用归并排序归并趟数: m个元素k路归并趟数$s = log_k m$ 12345678910111213141516171819202122232425262728293031void MergeSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return MergeSort(array, left, right);&#125;void Merge(vector&lt;int&gt;&amp; array, int l1, int r1, int l2, int r2) &#123; int i = l1, j = l2; vector&lt;int&gt; temp(array.size()); int index = 0; while (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123; if (array[i] &lt;= array[j]) temp[index++] = array[i++]; else temp[index++] = array[j++]; &#125; while (i &lt;= r1) temp[index++] = array[i++]; while (j &lt;= r2) temp[index++] = array[j++]; for (int i = 0; i &lt; index; i++) array[l1 + i] = temp[i];&#125;void MergeSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; MergeSort(array, left, mid); MergeSort(array, mid + 1, right); Merge(array, left, mid, mid + 1, right); &#125;&#125; 6. 快速排序分治法优点: 平均最快，平均比较次数最少最好情况: 每次能够均匀划分最坏情况: 序列有序，或不均匀划分优化: 快排需要使用递归，因此处理左右子段时，先处理短子段可以减少时间复杂度。先处理短⼦段的话，每次递归深度都是短⼦段的长度对排序对象的要求: 待排序列的存储方式是顺序存储 1234567891011121314151617181920212223242526void QuickSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return QuickSort(array, left, right);&#125;int Partition(vector&lt;int&gt;&amp; array, int left, int right) &#123; int temp = array[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[right] &gt; temp) right--; array[left] = array[right]; while (left &lt; right &amp;&amp; array[left] &lt; temp) left++; array[right] = array[left]; &#125; array[left] = temp; return left;&#125;void QuickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int pos = Partition(array, left, right); QuickSort(array, left, pos - 1); QuickSort(array, pos + 1, right); &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://w4ow.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://w4ow.github.io/tags/Sort/"}]},{"title":"LeetCode 探索初级算法","slug":"CS/Algorithm/Primary_Algorithm","date":"2019-08-06T16:00:00.000Z","updated":"2019-08-06T16:00:00.000Z","comments":true,"path":"2019/08/07/CS/Algorithm/Primary_Algorithm/","link":"","permalink":"http://w4ow.github.io/2019/08/07/CS/Algorithm/Primary_Algorithm/","excerpt":"LeetCode 探索初级算法","text":"LeetCode 探索初级算法 1 字符串1.1 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。 示例 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 解法：双指针法 设置双指针i、j分别指向头尾，交换头尾后各向中间进1. 1234567def reverseString(s): i, j = 0, len(s) - 1 while i &lt; j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return s 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 此题还可利用内置的reverse()函数或者s[::-1]来得到反转后的字符串，但这过于投机取巧。 1.2 整数反转给你一个32位的有符号整数$x$，返回将$x$中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围$[−2^{31}, 2^{31}−1]$，就返回$0$。 示例 12输入: -123输出: -321 解法：栈 每次对$x$除$10$取余，并将余数乘10累加到res中。 1234567891011def reverse(x): # sign为正负号 sign = -1 if x &lt; 0 else 1 # 取整数部分，相当于取绝对值 x = x * sign res = 0 while x != 0: res = res * 10 + x % 10 x = x // 10 res = res * sign return res if -2**31 &lt; res &lt; 2**31 - 1 else 0 复杂度分析 时间复杂度：$O(log(x))$ 空间复杂度：$O(1)$ 此题还可将数字转换为字符串后直接逆转字符串，但这显然不是本题想要考察的内容。 1.3 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1 示例 12345输入：s = &quot;leetcode&quot;输出：0.输入：s = &quot;loveleetcode&quot;,输出：2. 解法：hash表存储数频 两边遍历字符串：第一遍使用hash映射出每个字符出现的频次，第二遍找出频次为1的字符并返回索引。 123456def firstUniqChar(s): frequency = collections.Counter(s) for i, c in enumerate(s): if frequency[c] == 1: return i return -1 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(\\Sigma)$，$\\Sigma=26$为字符表大小 1.4 有效的字母异位词给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词，即s和t中每个字符出现的次数都相同。 示例 12345678输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false输入: s = &quot;aacc&quot;, t = &quot;ccac&quot;输出: false 解法：hash表 可以构建两个哈希表，分别保存s和t的词频，并比较这两个哈希表是否相同 12def isAnagram(s, t): return collections.Counter(s) == collections.Counter(t) 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(2S)$，其中$S$为字符串长度 此外，本题还可对两个字符串进行排序，并比较排序后的字符串是否相同，即return sorted(s) == sorted(t)，其时间复杂度为$O(n\\log n)$，空间复杂度为$O(\\log n)$ 1.5 验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写 示例 12345输入: &quot;A man, a plan, a canal: Panama&quot;输出: true输入: &quot;race a car&quot;输出: false 解法：双指针法 利用双指针分别从头和尾进行比较，两个关键函数：isalnum()判断是否为字母数字，以及lower()转换成小写字母 12345678910111213def isPalindrome(s): i, j = 0, len(s) - 1 while i &lt; j: # 判定条件i&lt;j的作用是防止在s=\", . ?~\"这样的字符串中因i&gt;j而越界 while i &lt; j and not s[i].isalnum(): i += 1 while i &lt; j and not s[j].isalnum(): j -= 1 if s[i].lower() != s[j].lower(): return False i += 1 j -= 1 return True 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 2 数组2.1 旋转数组给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数 示例 12345输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100] 解法1：暴力法 旋转k次，每次将数组向右旋转移动一位 1234567891011void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int pre, tmp; for (int i = 0; i &lt; k; ++i) &#123; int pre = nums[nums.size() - 1]; for (int j = 0; j &lt; nums.size(); ++j) &#123; tmp = nums[j]; nums[j] = pre; pre = tmp; &#125; &#125;&#125; 复杂度分析 时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$ 空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$ 解法2：使用额外数组 使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上. 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; arr = nums; for (int i = 0; i &lt; nums.size(); ++i) arr[(i + k) % nums.size()] = nums[i]; for (int i = 0; i &lt; nums.size(); ++i) nums[i] = arr[i];&#125; 复杂度分析 时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$ 空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$ 解法3：使用环状替换 如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。 现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上 12345678910111213141516void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 复杂度分析 时间复杂度：只遍历了一遍数组，$O(n)$ 空间复杂度：只用了常数个额外空间，$O(1)$ 解法4：数组反转 先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end());&#125; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$，没有使用额外空间 2.2 从数组中删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成. 解法：双指针法 数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例： 1234567[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ i i i j j j[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ... i i i j j j 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int j:nums) if (!i || j &gt; nums[i - 1]) nums[i++] = j; return i; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.3 买卖股票的最佳时机II给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1234567891011输入: [7,1,5,3,6,4]输出: 7解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入， 在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。输入: [1,2,3,4,5]输出: 4解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票， 之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 解法：暴力法 首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论： 一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断； 一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况； 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt; 2) return 0; int profit = 0; bool has_buy = false; if (prices[0] &lt; prices[1]) &#123; profit -= prices[0]; has_buy = true; &#125; for (int i = 1; i &lt; prices.size() - 1; ++i) &#123; if (has_buy == true &amp;&amp; prices[i] &gt; prices[i + 1]) &#123; profit += prices[i]; has_buy = false; &#125; else if (has_buy == false &amp;&amp; prices[i] &lt; prices[i + 1]) &#123; profit -= prices[i]; has_buy = true; &#125; &#125; if (has_buy == true) profit += *(prices.end() - 1); return profit; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.4 存在重复给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。 解法：使用unorder_set 使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set; for (auto it : nums) &#123; if (set.count(it) &gt; 0) return true; else set.insert(it); &#125; return false; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.5 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解法：使用异或 该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) ans ^= i; return ans; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.6 两个数组的交集II给定两个数组，编写一个函数来计算它们的交集。 示例 12345输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]输出: [2,3,5] 解法：使用find()函数 使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;nums1.size();i++) &#123; auto it=find(nums2.begin(),nums2.end(),nums1[i]); if(it!=nums2.end()) &#123; res.push_back(*it); nums2.erase(it); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \\sim O(n^2)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.7 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。 示例 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 解法：反向遍历 首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; digits[digits.size() - 1]++; for (auto i = digits.size() - 1; i &gt; 0; --i) &#123; if (digits[i] == 10) &#123; digits[i] = 0; digits[i - 1]++; &#125; &#125; if (digits[0] == 10) &#123; digits[0] = 0; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.8 移动零给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。 示例 123输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。 解法：双指针法 设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1. 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j = 0; while (i &lt; nums.size()) &#123; if (nums[i] == 0) i++; else &#123; swap(nums[i], nums[j]); i++; j++; &#125; &#125; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 2.9 两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 123输入: nums = [2, 7, 11, 15], target = 9输出: [0,1]说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1] 解法1：暴力法 暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; ans.push_back(i); ans.push_back(j); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 解法2：两遍哈希表 以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_set; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash_set.count(target - nums[i]) &gt; 0) &#123; ans.push_back(hash_set[target - nums[i]]); ans.push_back(i); break; &#125; hash_set[nums[i]] = i; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 2.10 有效的数独示例 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 解法：一次遍历 使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中 1234567891011121314151617181920class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;unordered_map&lt;int,int&gt;&gt; rows(9), cols(9), boxes(9); for(int i = 0; i &lt; 9; ++ i) &#123; for(int j = 0; j &lt; 9; ++ j) &#123; int box_index = (i / 3) * 3 + j / 3; char n = board[i][j]; if(n != '.') &#123; if(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n)) return false; rows[i][n] = 1; cols[j][n] = 1; boxes[box_index][n] = 1; &#125; &#125; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 2.11 旋转图像给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。 示例 12345678910111213给定matrix= [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 解法：翻转 先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$ 12345678910class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (int i = 0; i &lt; matrix.size(); ++i) for (int j = i; j &lt; matrix[0].size(); ++j) swap(matrix[i][j], matrix[j][i]); for (int i = 0; i &lt; matrix.size(); ++i) reverse(matrix[i].begin(), matrix[i].end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://w4ow.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://w4ow.github.io/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://w4ow.github.io/tags/String/"}]},{"title":"C++中的内联函数","slug":"CS/C++/inline_in_C++","date":"2019-07-30T01:45:00.000Z","updated":"2019-07-30T01:45:00.000Z","comments":true,"path":"2019/07/30/CS/C++/inline_in_C++/","link":"","permalink":"http://w4ow.github.io/2019/07/30/CS/C++/inline_in_C++/","excerpt":"内联函数相关知识点梳理","text":"内联函数相关知识点梳理 1. 内联函数的作用引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏： 1#define Expression(a, b) (((a) + (b)) * ((a) - (b))) 该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它使用预处理器实现，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏不能进行参数有效性检测，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。 另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。 为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。 2. inline与宏定义的区别 inline函数的本质是一个函数，而宏不是； inline函数在编译时展开，宏在预编译时展开； 在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换； inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能； 宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。 3. inline的优点 inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高； 类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性； inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。 4. inline的使用场合 用于取代表达式形式的宏定义； 用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，定义在类体内的函数会被自动转换成内联函数。 5. inline的缺点inline是以代码复制为代价的，仅仅省去了函数调用的开销，从而提高函数的执行效率。若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低。另外，每一处内联函数的调用都需要复制代码，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline： 函数体内代码较长：使用inline将导致较高的内存消耗； 函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大； 不用于类的构造函数和析构函数。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"C++中的数据类型及其大小","slug":"CS/C++/data_type_in_C++","date":"2019-07-29T11:58:00.000Z","updated":"2019-07-29T11:58:00.000Z","comments":true,"path":"2019/07/29/CS/C++/data_type_in_C++/","link":"","permalink":"http://w4ow.github.io/2019/07/29/CS/C++/data_type_in_C++/","excerpt":"在C/C++中的数据类型及其所占空间大小总结","text":"在C/C++中的数据类型及其所占空间大小总结 1. 内置数据类型常见的内置数据类型如下表所示，可以使用sizeof查看其大小： type size char 1B unsigned char 1B signed char 1B int 4B unsigned int 4B signed int 4B short (int) 2B long (int) 8B float 4B double 8B long double 16B wchar_t 2B or 4B 其中wchar_t是宽字符型，其定义为 1typedef short int wchar_t; 也就是说，实际上wchar_t和short int是等价的。 2. 数组与字符串对数组使用sizeof运算，其大小为数组中元素的个数*元素所占内存大小，而对于char数组型的字符串，例如char str[] = &quot;Hello&quot;，其大小为字符个数+1，因为结尾需要保存\\0。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。 3. 自定义数据类型3.1. class及struct3.1.1. 空类对于一个空类，例如 1234class A&#123;&#125; 其大小为1B，因为C++中每一个类都有一个独一无二的地址，因此即使是空类也会为其分配1B的内存空间。 3.1.2. 类对象所占内存大小类所占的内存大小由其成员变量决定，成员函数不计算在内，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如 123456789101112131415161718192021222324252627282930313233343536373839404142// sizeof(A) = 4class A&#123; int a;&#125;;// sizeof(B) = 4, 成员函数不计入class B&#123; int a; int fun1() &#123; return 0; &#125;&#125;;// sizeof(C) = 1, 结构体不计入class C&#123; struct stc1 &#123; int sa; char sb; &#125;;&#125;;// sizeof(D) = 1, 联合体不计入class D&#123; union un1 &#123; int ua; short ub; &#125;;&#125;;// sizeof(E) = 1, class不计入class E&#123; class cl1 &#123; int ca; short cb; &#125;;&#125;; 3.1.3. 类对象的字节对齐由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能从某些特定地址开始存取，如果不对其，会给存取效率带来损失。 字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 如果类中包含虚函数，则无论其有多少个虚函数，这些虚函数所占内存均为4B，因为内存中需要保存一个虚表指针成员 举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class A&#123; int i;&#125;;class B&#123; char ch;&#125;;class C&#123; int i; short s;&#125;;class D&#123; int i; short j; char ch;&#125;;class E&#123; int i; int ii; short j; char ch; char ch2;&#125;;class F&#123; int i; int ii; int iii; short j; char ch; char ch2;&#125;;struct G&#123; char ch; int i; short b2;&#125;;class H&#123; int i; virtual void fun1() &#123;&#125; virtual void fun2() &#123;&#125;&#125;;class I : public A, public B &#123;&#125;;class J : virtual public A &#123;&#125;;class K : virtual public A, virtual B &#123;&#125;;class L&#123; int i; static int ii;&#125;// sizeof(A) = 4// sizeof(B) = 1// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)// sizeof(J) = 8// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中) 3.2. union联合体的大小取决于该体中所有的成员中占用空间最大的一个成员的大小，并且同样的需要对齐： 123456789101112131415161718192021union u1&#123; double a; int b;&#125;;union u2&#123; char a[13]; int b;&#125;;union u3&#123; char a[13]; char b;&#125;;// sizeof(u1) = 8;// sizeof(u2) = 13 + 3(以int的整数倍补齐);// sizeof(u3) = 13;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"Ubuntu下GDB的使用","slug":"CS/Linux/gdb_in_ubuntu","date":"2019-07-27T14:00:00.000Z","updated":"2019-07-27T14:00:00.000Z","comments":true,"path":"2019/07/27/CS/Linux/gdb_in_ubuntu/","link":"","permalink":"http://w4ow.github.io/2019/07/27/CS/Linux/gdb_in_ubuntu/","excerpt":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧","text":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧 1. 使用GDB调试可执行文件123gdb a.out # 不带参数或gdb --args a.out 参数 # 带参数 2. GDB常用命令12345678910111213141516171819202122232425r [args] # 带参数从头开始执行程序b arg # 在arg处设置断点，arg可以为行数、地址b xxx if (condition) # 条件断点b test.c:30 if n==100 # 当变量n等于100的时候在test.c的30行处加断点n (next) # 单步执行，如遇函数则直接返回函数的执行结果s (step) # 单步执行，如遇函数则进入函数体执行stop # 停止执行q (quit) # 退出GDBuntil # 当不想反复执行循环时，可以用until跳出循环finish # 跳出当前函数c (continue) # 继续执行，直到下一个断点或程序结束p arg # 打印出arg的值，arg可以为变量或地址whatis variable # 打印出变量的类型ptype variable # 打印出变量的类型，只不过比whatis更详细i variables variable # 打印出定义variable的文件i source # 查看当前程序i b # 查看arg，arg可以为断点、变量值、i args # 打印出当前函数的参数值i locals # 打印出当前函数中所有局部变量值i r (r_name) # 查看所有寄存器(寄存器r_name)的值i threads # 查看线程d b # 删除断点，b为断点编号bt # 查看函数的back tracel (list) arg # 显示arg附近的前后共10行代码，arg可以为行数或函数名watch arg # 设置监控，在arg改变时停止(需要先加断点) 3. 设置断点1234# 当欲设断点在当前文件中时，可以b+行数或b+函数名b 45/main# 当欲设断点在其他文件中时，b 文件名:行数b head.cpp:45","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"http://w4ow.github.io/tags/GDB/"}]},{"title":"C++中const、define和static","slug":"CS/C++/const_define_static_in_C++","date":"2019-07-03T03:29:37.000Z","updated":"2019-07-02T16:00:00.000Z","comments":true,"path":"2019/07/03/CS/C++/const_define_static_in_C++/","link":"","permalink":"http://w4ow.github.io/2019/07/03/CS/C++/const_define_static_in_C++/","excerpt":"关键字const、define和static相关知识点整理","text":"关键字const、define和static相关知识点整理 1. const和define区别 宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查; const常量存在于程序的数据段，并在堆栈分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查; 2. C++中关键字const的作用 定义常量; 修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const: 12void fun(A a);void fun(A const &amp;a); 修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量: 123const char *GetChar()&#123;&#125;;char *ch = GetChar(); // errorconst char *ch = GetChar() //correct const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下: 1int GeoCount() const; 3. 静态变量static1. static的作用 一个static变量可以维持其值在被调用的过程中不变； 在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问； 模块内的一个static修饰的函数只可以被该模块内的函数调用。 2. static变量和普通变量的区别1. static全局变量和普通全局变量 static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值； static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用； （相同点）两种都以静态存储方式存储； 2. static局部变量和普通局部变量 static局部变量只被初始化一次，下一次使用依据上一次的结果 3. static函数和普通函数 static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品； static函数作用域仅在本文件中，普通函数可在其他文件被调用；","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"MacOS/Ubuntu 18.10 安装PyTorch","slug":"CS/Linux/PyTorch_for_Linux","date":"2019-03-29T16:00:00.000Z","updated":"2018-03-29T16:00:00.000Z","comments":true,"path":"2019/03/30/CS/Linux/PyTorch_for_Linux/","link":"","permalink":"http://w4ow.github.io/2019/03/30/CS/Linux/PyTorch_for_Linux/","excerpt":"MacOS/Ubuntu 18.10 安装PyTorch","text":"MacOS/Ubuntu 18.10 安装PyTorch 1. MacOS/Ubuntu 18.10 安装Conda管理环境MacOS下前往Anaconda官网下载安装即可Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加export PATH=”/home/user_name/anaconda3/bin:$PATH”并source一下即可 2. MacOS/Ubuntu 18中安装PyTorch (可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch 123conda create -n environment_name python=X.X (2.7/3.6) # 创建虚拟环境conda info --env # 显示所有的conda虚拟环境conda activate environment_name # 激活虚拟环境 修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源 12345678# for Anacondaconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# for PyTrochconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes 安装PyTorch 12conda install pytorch torchvisionconda deactivate # 使用结束后退出虚拟环境 3. 虚拟环境中安装jupyter如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter 1python3 -m pip install jupyter","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://w4ow.github.io/tags/PyTorch/"},{"name":"MacOS","slug":"MacOS","permalink":"http://w4ow.github.io/tags/MacOS/"}]},{"title":"Ubuntu 18.10安装LLVM","slug":"CS/Linux/LLVM_for_Ubuntu","date":"2018-12-29T16:00:00.000Z","updated":"2018-12-29T16:00:00.000Z","comments":true,"path":"2018/12/30/CS/Linux/LLVM_for_Ubuntu/","link":"","permalink":"http://w4ow.github.io/2018/12/30/CS/Linux/LLVM_for_Ubuntu/","excerpt":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本","text":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本 1.安装cmake安装LLVM需要使用cmake，可以使用如下命令安装: 1sudo apt install cmake 2.修改swap分区(可选，不推荐)从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下： 查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间: 123sudo swapon --showorfree -h 检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值 1df -h 在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。 123sudo swapoff -a # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，sudo fallocate -l 20G /swapfile # 创建swapfilels -lh /swapfile # 验证是否成功创建swapfile， 如果显示-rw——1 root root 20G 日期 /swapfile 则表示创建成功 启用交换文件 12sudo chmod 600 /swapfile # 锁定swapfile权限sudo mkswap /swapfile # 将文件标记为交换空间 若显示:Setting up swapspace…… 则表示成功标记swapfile，标记之后启用该文件 12sudo swapon /swapfile # 启用free -h # 验证 永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留 12sudo cp /etc/fstab /etc/fstab.bak # 备份echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab # 将swap文件信息添加到/etc/fstab文件 3.安装LLVM-8.0 Debug版本 首先去LLVM官网下载必要的软件包; 获取源码: 1234567891011121314151617181920212223# 在适当位置放置LLVM源码，此处放在home下cd ~mkdir tmp# 解压LLVM源码cd tmptar -Jxvg llvm-7.0.0.src.tar.xzmv llvm-7.0.0.src llvm# 解压clang源码(此时在tmp目录下)cd llvm/toolstar -Jxvg cfe-7.0.0.src.tar.xzmv cfe-7.0.0.src clang# 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)cd clang/toolstar -Jxvg clang-tools-extra-7.0.0.src.tar.xzmv clang-tools-extra-7.0.0.src extra# 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)cd ~/tmp/llvm/projectstar -Jxvg compiler-rt-7.0.0.src.tar.xzmv compiler-rt-7.0.0.src compiler-rt 开始安装 123456789101112# 在tmp目录下新建build文件夹cd buildcmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Debug ../llvmmake -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半sudo make install# 将路径添加到环境变量中cd ~vim .bashrcexport PATH=/usr/lib/llvm-7/binexport LD_LIBRARY_PATH=/usr/lib/llvm-7/libsource .bashrc 重启终端并测试 123clang -vclang++ -vclang test.c","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"LLVM","slug":"LLVM","permalink":"http://w4ow.github.io/tags/LLVM/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu 18.10安装与配置","slug":"CS/Linux/install_ubuntu","date":"2017-06-03T16:00:00.000Z","updated":"2017-06-03T16:00:00.000Z","comments":true,"path":"2017/06/04/CS/Linux/install_ubuntu/","link":"","permalink":"http://w4ow.github.io/2017/06/04/CS/Linux/install_ubuntu/","excerpt":"Ubuntu 18.10安装与配置","text":"Ubuntu 18.10安装与配置 1. 安装Ubuntu 18.10安装过程不多说，安装镜像可以去中科大镜像下载。 2. 安装搜狗输入法 前往搜狗输入法官网下载deb安装文件，双击安装； 前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt； 当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法； 重启系统。 3. 修改软件源应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn 4. 安装Chrome前往Chrome官网下载.deb安装包，双击安装即可。 5. 开启夜览模式夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整： 打开Terminal安装dconf-editor 1sudo apt install dconf-editor 在终端打开dconf-editor 1dconf-editor dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature 关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适 6. 系统美化安装Tweaks工具用以配置桌面 12sudo apt updatesudo apt install gnome-tweak-tool 在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有： Weather In The Clock，点击屏幕上方的时间可以展示天气; Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏； 7. 配置终端 安装zsh与git 12sudo apt install zsh sudo apt install git 安装oh-my-zsh 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 将Shell切换到zsh，登出并重新登入 1chsh -s /bin/zsh 在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题 1ZSH_THEME=\"ys\" 安装一些强大的zsh插件首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令： 1source ~/.oh-my-zsh/plugins/incr/incr*.zsh 同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"}]},{"title":"死锁问题","slug":"CS/Operating-System/deadlock","date":"2015-03-16T06:12:00.000Z","updated":"2015-03-16T06:12:00.000Z","comments":true,"path":"2015/03/16/CS/Operating-System/deadlock/","link":"","permalink":"http://w4ow.github.io/2015/03/16/CS/Operating-System/deadlock/","excerpt":"关于死锁的一些归纳和总结","text":"关于死锁的一些归纳和总结 1. 死锁产生的原因和必要条件进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。 可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。 不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。 因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点： 系统资源不足。这是根本原因，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时； 进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。 对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4： 互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用； 请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源； 不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占； 循环等待。若干个进程形成循环等待链。 2. 死锁的预防通过破坏死锁的必要条件来控制死锁的策略称为死锁预防，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。 破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的优点是安全简单易实现，缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源。 破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”。 破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高。 3. 死锁的避免与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的前提是每个进程清除自己需要多少资源，因此死锁避免还是有局限性的。 系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全； 银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。 4. 银行家算法银行家算法有5种数据结构： 系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲； 最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k； 分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数； 需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源； 请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。 当某个进程i对j类资源提出k个请求是，需要按照下列步骤检查： 若$Request[j]&lt;=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错； 若$Request[j]&lt;=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i； 系统进行试探性分配，并修改相应的表： Available[j] -= Request[j]; Allocation[i][j] += Request[j]; Need[i][j] -= Request[j]; 调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。 判断当前状态是否安全 添加两个数组： Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa； Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。 检查当前状态的完整过程如下： 初始化Work和Finish。Work[j]=Available[j], Finish[i]=false; 在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4: Finish[h] = false; Need[h][j] &lt;= Work[j] 由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2 若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。 5. 死锁检测6. 死锁解除","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Deadlock","slug":"Deadlock","permalink":"http://w4ow.github.io/tags/Deadlock/"}]},{"title":"进程、线程与协程之间的区别与联系","slug":"CS/Operating-System/process-and-thread-coroutines","date":"2015-03-12T06:12:00.000Z","updated":"2015-03-12T06:12:00.000Z","comments":true,"path":"2015/03/12/CS/Operating-System/process-and-thread-coroutines/","link":"","permalink":"http://w4ow.github.io/2015/03/12/CS/Operating-System/process-and-thread-coroutines/","excerpt":"进程、线程与协程之间的区别与联系","text":"进程、线程与协程之间的区别与联系 1. 进程进程是程序的动态执行。保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。一块CPU在某一时刻只能运行一个进程，多进程是通过进程调度抢占CPU来实现的。 进程间的通信方式 无名管道(Pipe)、有名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存(Shared Memory)、套接字(Socket)。 2. 线程线程也被称为轻量级进程(Lightweight Process，LWP)，是操作系统调度(CPU调度)执行的最小单位。 2.1 线程与进程的区别与联系联系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 资源分配给进程，同一进程的所有线程共享该进程的所有资源； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属进程的资源。进程维护的是程序所包含的资源(静态资源)，如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等；线程所维护的运行相关的资源(动态资源)，如：运行栈、调度相关的控制信息、待处理的信号集等； 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致创建进程的系统开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 3. 协程协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总有一个入口，一次返回，并且调用顺序是明确的。而协程的调用和子程序不同，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。 协程的优点 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显； 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://w4ow.github.io/tags/Process/"}]},{"title":"进程间的通信方式","slug":"CS/Operating-System/communication-of-process","date":"2015-03-09T06:12:00.000Z","updated":"2015-03-09T06:12:00.000Z","comments":true,"path":"2015/03/09/CS/Operating-System/communication-of-process/","link":"","permalink":"http://w4ow.github.io/2015/03/09/CS/Operating-System/communication-of-process/","excerpt":"同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。","text":"同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。 1. 进程通信的概念进程的特征之一是其具有独立性，一个进程不能访问另一个进程的程序或者数据，以保证进程之间不会相互干扰，但这样也造成了进程间无法直接交换数据。 一般而言，进程通过两种方案来实现进程间的通信 发送、接受双方通过磁盘等外设交换数据。这种通信方式需要I/O操作的支持。 利用内核运行在内核态的特点，通过对内核空间读写来交换数据。这种通信方式是在内存中完成的。 根据进程通信交换信息量的大小，可以将进程通信分为两种： 低级通信。进程之间一次只传输少量数据，速度快，效率低，通信过程对用户不透明。这类通信主要用于互斥与同步的工具，P、V原语是低级通信原语 高级通信。一次可以传输大量信息，效率高，对用户透明，编程简单。高级通信又分为三种： 共享内存通信方式：利用共享内存通信； 消息传递通信方式：利用OS提供的消息系统通信； 共享文件通信方式：又被称为管道通信。 高级通信方式既适用于集中式操作系统，又适用于分布式操作系统。 2. 共享内存通信方式共享内存是指在内存中划出一块区域作为数据共享区，称为共享内存分区，通信双方将自己的虚拟地址空间映射到共享内存分区上。通信时通过对该分区读写实现通信。该方式是进程间最快捷、最有效的通信方式，Unix、Windows和OSX都采用了这种通信方式。 3. 消息缓冲(消息队列)通信方式消息缓冲属于直接通信方式，该方法中，发送进程直接发送原语到接收进程的消息队列，而接受进程使用接受原语从消息队列中取出信息，进程间以消息为单位进行信息交换。该方法与生产者-消费者问题类似。该方式与共享内存有点相似，该方法使用内存中的公用消息缓冲区来传递消息。 4. 信箱通信方式该方式是间接通信方式，通信双方通过一种叫信箱的共享数据结构来进行交互。该方法和消息队列没什么区别，也是在内存中设置一种特殊的数据结构。 5. 管道通信方式所谓的管道就是一种共享通信文件，也称为pipe文件，专门用于进程间通信。管道有三个特点： 管道专门用于特性 管道只能单向传送数据 管道对用户透明 管道分为两种： 无名管道。无名管道是利用系统调用pipe建立起来的无路径名的无名文件，并且是一个临时文件，该文件物理上由文件系统的高速缓冲区构成，且很少启动外部设备。当进程不再需要无名管道时，系统关闭并回收与它相关联的索引节点。此外，通过文件系统看不到无名管道的存在。 有名管道。有名管道是一个有目录和索引的长期存在的真实文件，不能与文件系统中的任何文件重名，且在文件系统中能看到该有名管道。 6. 信号量7. 套接字","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://w4ow.github.io/tags/Process/"}]},{"title":"进程的基本概念","slug":"CS/Operating-System/process","date":"2015-03-07T06:12:00.000Z","updated":"2015-03-07T06:12:00.000Z","comments":true,"path":"2015/03/07/CS/Operating-System/process/","link":"","permalink":"http://w4ow.github.io/2015/03/07/CS/Operating-System/process/","excerpt":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。","text":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。 1. 进程的概念1.1 程序的顺序执行在计算机中常使用程序这个概念，程序是一个在时间上严格按先后次序操作实现算法功能的指令序列，程序本身是静态的，是指令编译出的结果。在单道程序设计环境中，程序总是顺序执行的，若有多个程序，则各个程序试一次呗调入内存的。程序的顺行执行有以下三个特点： 顺序性。CPU严格按照程序规定的顺序(即指令顺序)执行程序的操作，每个操作都必须在前一个操作结束后才能执行； 封闭性。程序一旦开始执行，其结果仅由初始条件和程序本身操作决定，不受外界因素影响； 可再现性。当初始条件相同，程序的运行结果也相同。 单道程序的顺序性、封闭性和可再现性给程序的编制、调试带来了便利，但是资源利用率底。 1.2 程序的并发执行1.3 进程1.3.1. 进程的定义单道程序环境下，程序与CPU执行的活动是一致的。多道环境下，并发破坏了程序的封闭性和可再现性，程序与CPU执行的活动不再一一对应。程序是完成某一特定功能的指令序列，是一个静态过程，而CPU执行的活动是一个动态的过程。因此20世纪60年代Dijkstra引入了进程的概念。他给出的进程定义是：行为的规则称为程序，程序在CPU上执行时的活动称为进程。 1.3.2. 进程的结构通常程序是不能并发执行的，为了使程序及它所要使用的资源能独立运行，OS为程序配置了一个特殊的数据结构进程控制块PCB(Process Control Block)，PCB用来存储程序向前执行过程中所要记录的有关运行信息，即该进程动态之行的相关资料。因此： 进程实体 = 程序段 + 相关数据段 + PCB 1.3.3. 进程的特征进程作为OS的一个实体有以下5个特征。 动态性。进程是程序的一次执行，因此进程是动态的，具有生命期。 并发性。多个进程实体在一段时间内能够并发执行，从而提高系统资源利用率。 独立性。每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位。 异步性。各进程按各自独立的、不可预知的速度向前推进。对单CPU系统而言，任何时刻只能有一个进程占用CPU。 结构性。每个进程的结构都由程序段、数据段和PCB组成。 1.3.4. 进程和程序的区别 程序是指令的有序集合，是静态的；Process是程序在CPU上的一次执行，是动态的； 程序作为软件可以长期保存；Process有自己的生命周期； 程序不会占有和调度资源；Process会为其分配和调度资源； 进程与程序之间无一一对应关系，一个程序可以多次执行产生多个进程，不同进程也可以包含同一个程序； 程序是记录在存储介质上的指令有序集合；进程则由程序段、数据段、PCB组成。 2. 进程的状态及转换2.1. 5状态进程模型进程有5个状态：创建、就绪、运行、阻塞、终止，下面对其一一说明。 进程的创建。通常有4件事会导致新进程的产生： 在一个批处理环境中，为了响应一个任务的要求而产生进程； 在一个交互式环境中，当一个新用户企图登录时会产生进程； 操作系统代替用户程序产生进程； 由用户程序产生进程。通常进程都是由操作系统产生的，但是一个进程也可以产生另一个进程，分别称为父进程和子进程。 进程的终止。当一个进程执行到自然结束点，或因不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程进入终止态。处于终止态的进程不能被再次调度执行，与其相关的数据信息由OS临时保存，随后OS逐步释放为其分配的资源，最后释放PCB。 进程的就绪。进程获得了除CPU之外的所需资源，一旦得到CPU就可运行。就绪状态的进程会组成就绪队列。 进程的运行。进程获得了CPU和其他资源，正在CPU上运行时的状态。 进程的阻塞。进程运行中发生了某种等待事件(如I/O操作)而暂时不能运行的状态，此状态的进程不能竞争CPU，而需要等事件完成后转到就绪态才能竞争。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://w4ow.github.io/tags/Process/"}]}]}