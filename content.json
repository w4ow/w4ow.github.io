{"meta":{"title":"Simita","subtitle":null,"description":null,"author":null,"url":"http://w4ow.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-06-13T10:15:30.163Z","updated":"2021-06-13T10:15:30.163Z","comments":true,"path":"404.html","permalink":"http://w4ow.github.io/404.html","excerpt":"","text":"这里是知识的荒漠"},{"title":"ALL CATEGORIES","date":"2020-09-02T02:17:43.837Z","updated":"2019-06-28T15:35:37.000Z","comments":true,"path":"categories/index.html","permalink":"http://w4ow.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-02T02:17:43.840Z","updated":"2019-06-28T15:23:09.000Z","comments":true,"path":"mylist/index.html","permalink":"http://w4ow.github.io/mylist/index.html","excerpt":"","text":""},{"title":"ALL TAGS","date":"2020-09-02T02:17:43.843Z","updated":"2019-06-28T15:35:48.000Z","comments":true,"path":"tags/index.html","permalink":"http://w4ow.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HEXO的使用","slug":"computer_science/Tools/hexo使用详解","date":"2021-06-13T10:19:20.370Z","updated":"2021-06-13T10:26:34.626Z","comments":true,"path":"2021/06/13/computer_science/Tools/hexo使用详解/","link":"","permalink":"http://w4ow.github.io/2021/06/13/computer_science/Tools/hexo使用详解/","excerpt":"HEXO是一个基于Markdown的静态网页博客生成框架","text":"HEXO是一个基于Markdown的静态网页博客生成框架","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://w4ow.github.io/tags/HEXO/"}]},{"title":"Vim常用命令","slug":"computer_science/Linux/vim-cmd","date":"2020-07-30T12:26:52.000Z","updated":"2020-08-01T02:26:08.000Z","comments":true,"path":"2020/07/30/computer_science/Linux/vim-cmd/","link":"","permalink":"http://w4ow.github.io/2020/07/30/computer_science/Linux/vim-cmd/","excerpt":"Vim常用快捷键及命令","text":"Vim常用快捷键及命令 1. 快捷键及命令1 光标移动12345gg # 跳至文档首部G # 跳至文档结尾^ # 跳至行首$ # 跳至行尾ngg/nG/:n # 跳至第n行 1.2 复制粘贴删除12345678yy # 复制当前行yw # 复制光标所在wordp # 将内容粘贴到当前行上面P # 将内容粘贴到当前行下面dd # 删除当前行cc # 删除当前行并进入编辑模式dw # 删除光标所在word或符号cw # 删除光标所在word并进入编辑模式 2. vimrc常用配置1:set nu # 设置行号","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://w4ow.github.io/tags/Vim/"}]},{"title":"Ubuntu下查看CPU个数","slug":"computer_science/Linux/cores-in-ubuntu","date":"2020-07-30T11:24:10.000Z","updated":"2020-07-30T11:48:58.000Z","comments":true,"path":"2020/07/30/computer_science/Linux/cores-in-ubuntu/","link":"","permalink":"http://w4ow.github.io/2020/07/30/computer_science/Linux/cores-in-ubuntu/","excerpt":"一台机器中基本上只有一个物理CPU核，不过为了提高机器的性能，通常生产厂商会在CPU上集成多个内核，而内核又可以被分为多个线程。其中，内核是物理上的划分，而多线程是逻辑上的划分。","text":"一台机器中基本上只有一个物理CPU核，不过为了提高机器的性能，通常生产厂商会在CPU上集成多个内核，而内核又可以被分为多个线程。其中，内核是物理上的划分，而多线程是逻辑上的划分。 在Ubuntu系统中可以使用下列命令查询核心数 查看物理CPU个数： 1cat /proc/cpuinfo| grep \"physical id\"| sort| uniq| wc -l 查看每个物理CPU中内核数： 1cat /proc/cpuinfo| grep \"cpu cores\"| uniq 查看逻辑CPU个数 1cat /proc/cpuinfo| grep \"processor\"| wc -l 查看线程数： 1grep 'processor' /proc/cpuinfo | sort -u | wc -l","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"}]},{"title":"Conda更改镜像源","slug":"computer_science/Tools/conda-channel-change","date":"2019-11-07T02:00:00.000Z","updated":"2019-11-07T02:00:00.000Z","comments":true,"path":"2019/11/07/computer_science/Tools/conda-channel-change/","link":"","permalink":"http://w4ow.github.io/2019/11/07/computer_science/Tools/conda-channel-change/","excerpt":"修改Conda默认的镜像源为清华镜像","text":"修改Conda默认的镜像源为清华镜像 1. 修改为Tsinghua源12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/freeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mainconda config --set show_channel_urls yes 2. 换回默认源1conda config --remove-key channels","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"http://w4ow.github.io/tags/Conda/"}]},{"title":"SSH中scp命令的使用","slug":"computer_science/Tools/ssh-scp","date":"2019-11-06T07:00:00.000Z","updated":"2019-11-06T07:00:00.000Z","comments":true,"path":"2019/11/06/computer_science/Tools/ssh-scp/","link":"","permalink":"http://w4ow.github.io/2019/11/06/computer_science/Tools/ssh-scp/","excerpt":"在SSH中，scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。类似的工具有rsync。scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。","text":"在SSH中，scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。类似的工具有rsync。scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 1. 命令格式1scp [参数] [原路径] [目标路径] 2. 命令参数 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 3. 使用示例12345# 从远程拷贝到本地$scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/# 从本地拷贝到远程$scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://w4ow.github.io/tags/SSH/"}]},{"title":"Jupyter Notebook中添加、删除Python kernel的方法","slug":"computer_science/Tools/manage-kernel-of-notebook","date":"2019-10-20T11:00:00.000Z","updated":"2019-10-20T11:00:00.000Z","comments":true,"path":"2019/10/20/computer_science/Tools/manage-kernel-of-notebook/","link":"","permalink":"http://w4ow.github.io/2019/10/20/computer_science/Tools/manage-kernel-of-notebook/","excerpt":"在通过Anaconda使用Jupyter时，有时我们创建了多个Python环境(包括虚拟环境)，但是启动Jupyter Notebook后，在新建notebook选项中却找不到我们所创建的Python环境，此时我们可以通过向notebook中添加Python kernel解决该问题。","text":"在通过Anaconda使用Jupyter时，有时我们创建了多个Python环境(包括虚拟环境)，但是启动Jupyter Notebook后，在新建notebook选项中却找不到我们所创建的Python环境，此时我们可以通过向notebook中添加Python kernel解决该问题。 1. 添加Kernel1.1 切换环境，安装内核首先切换到想要使用的Python环境中，若是虚拟环境则激活该虚拟环境。随后可以使用如下命令查看该环境下搜索并安装Python内核： 123conda search ipykernel # 搜索内核conda install ipykernel # 安装内核 1.2 在notebook中安装内核使用以下命令安装notebook内核， 1python -m ipykernel install --name name_you_want (--user) 其中name_you_want是将在notebook的新建中所显示的Python环境名字，安装时若权限不够，则添加–user 1.3 重新启动Jupyter Notebook重启Notebook，可以在新建下拉菜单中看到name_you_want选项，大功告成。 2. 查看kernel使用该命令可以查看notebook所有已安装kernel 1jupyter kernelspec list 3. 删除kernel使用以下命令可以删除指定kernel 1jupyter kernelspec remove kernel_name","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"http://w4ow.github.io/tags/Conda/"}]},{"title":"修改jupyter notebook默认工作路径","slug":"computer_science/Tools/work-dir-of-notebook","date":"2019-10-15T02:00:00.000Z","updated":"2019-10-15T14:00:00.000Z","comments":true,"path":"2019/10/15/computer_science/Tools/work-dir-of-notebook/","link":"","permalink":"http://w4ow.github.io/2019/10/15/computer_science/Tools/work-dir-of-notebook/","excerpt":"修改jupyter notebook默认工作路径","text":"修改jupyter notebook默认工作路径 1. 生成配置文件 12# Mac &amp; Ubuntu &amp; Windows在Terminal中运行下面命令jupyter notebook --generate-config 如果在Windows中出现‘jupyter’不是内部或外部命令，也不是可运行的批处理文件，可以通过下面命令安装notebook 1pip install notebook 2. 修改配置文件 找到如下所示的两行，第二行去注释并改成工作路径即可。 1234567macOS:## The directory to use for notebooks and kernels.#c.NotebookApp.notebook_dir = ''Ubuntu &amp; Windows:## The default URL to redirect to from `/`#c.NotebookApp.default_url = '/tree'","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"http://w4ow.github.io/tags/Conda/"}]},{"title":"线性MBA表达式存在定理证明","slug":"computer_science/Information-Security/Linear MBA Expressions","date":"2019-10-10T05:22:00.000Z","updated":"2019-10-10T08:41:00.000Z","comments":true,"path":"2019/10/10/computer_science/Information-Security/Linear MBA Expressions/","link":"","permalink":"http://w4ow.github.io/2019/10/10/computer_science/Information-Security/Linear MBA Expressions/","excerpt":"定理来源参见论文Information Hiding in Software with Mixed Boolean-Arithmetic Transforms中定理1.","text":"定理来源参见论文Information Hiding in Software with Mixed Boolean-Arithmetic Transforms中定理1. 1. MBA表达式的定义多项式MBA表达式形如：$$\\sum_{i \\in I} a_i (\\prod_{j \\in J} e_{i,j}(x_1,…,x_t))$$其中$a_i$是整数，$x_i$是在$B^n$上的变量，$e_{i,j}$是对变量$x_i$的按位表达式。例如：$$f(x,y,z,t)=8458(x \\lor y \\land z)^3((xy)\\land x \\lor t) + x + 9(x \\lor y)yz^3$$是一个多项式MBA表达式，其中，表达式中变量总共有4个，即$t = 4$,即$x_1 = x, x_2 = y, x_3 = z$, $x_4 = t$，另外，$a$总共有3个值，分别是$a_0=8458, a_1=1, a_2 = 9$。对于$a_0$，总共有4个$e_{i,j}$作为其右部累积，即$e_{0,0}=e_{0,1}=e_{0,2}=x \\lor y \\land z,e_{0,3}=(xy) \\land x \\lor t$。同样的，$a_1$仅又结合了一个$e_{0,0}=x$。至此算是比较清晰的解释了什么是MBA表达式 线性MBA表达式形如：$$\\sum_{i \\in I}a_i e_i(x_1,…x_t)$$线性MBA表达式是多项式MBA表达式的子集，例如：$$f(x,y)=x+y-(x \\oplus (\\lnot y)) - 2(x \\lor y) + 12564$$是一个线性MBA表达式，其变量仅两个$x,y$，而$a=\\lbrace 1,1,-1,-2,12564 \\rbrace$，对于每个$a_i$，仅右结合一个$e_i$，这是线性MBA和多项式MBA的区别。 2. 定理1:线性MBA表达式存在定理假设$n,s,t$为正整数， 变量$x_i \\in B^n, i=1,…,t$，即$x_i$形如$1011…010_{(n)}$； $a_j$是一个正整数，$j=0,1,…,s-1$; $e_j$是对$x_i$的按位表达式，$j=0,1,…,s-1$。由于该定理适用于线性MBA，因此对每个$a_j$仅右结合一个$e_j$，例如$e_j(x_1,x_2,x_3)=x_1 \\lor x_2 \\oplus x_3$,尤其需要注意的是，由于$e_j$是按位运算，因此有：$e_j(x_1,…,x_t)=\\left( \\begin{matrix} f_j(x_{1,0},…,x_{t,0}) \\\\ \\vdots \\\\f_j(x_{1,n-1},…,x_{t,n-1}) \\end{matrix} \\right) = \\left( \\begin{matrix} f_j(y_0) \\\\ \\vdots \\\\f_j(y_0) \\end{matrix} \\right)$ $e=\\sum_{j=0}^{s-1}a_j e_j$是一个线性MBA表达式，则$e_j$是一个映射：$e_j:B^{n \\times t} \\to B$，由于$B$这个二进制数可以转换成模$2^n$的整数(在计算机中整数由补码表示，假设所有整数的二进制位数为$n$，则计算机中所有的数都需要模$2^n$)，因此$e_j:B^{n \\times t} \\to Z/2^n$，同样的,$e:B^{n \\times t} \\to Z/2^t$； $F=\\left( \\begin{matrix} f_0(0) \\cdots f_{s-1}(0) \\\\ \\vdots \\\\f_0(2^t-1) \\cdots f_{s-1}(2^t-1) \\end{matrix} \\right)$是一个$2^t \\times s$的矩阵，表示$f_j$对每一bit位操作的所有可能的值，在Zhou的论文中说$F$是一个真值表； $V=(a_0,…,a_{s-1})^T$； $e=0$当且仅当$F \\cdot V = 0$在环$Z/2^n$上有非平凡的解。 3. 证明对于定理中的第5点，$F$为什么是$2^t \\times s$，原因是，首先$f_j$也就是$e_j$总共有$s-1$个不同的表达式，这是列数为$s$的原因，其次，$y_i$是一个$t \\times 1$的向量，$y_i$中的每个分量都是从$x_j$中第$i$个位置取出，例如$y_i=(1,0,1)$，那么对这个$t$位的$y_i$，其可能取值自然是$(0,1,…,2^t-1)$，也就有了$f_j$所有可能的取值是$(f(0),f(1),…,f(2^t-1))$，矩阵因此而来。 假设$F \\cdot V = 0$，有：$\\forall x_1,…x_t \\in B^n, y_i = (x_{1,i},…,x_{t,i}), i=0,…,n-1$,$$e(x_1,…,x_t)=\\sum_{j=0}^{s-1}a_je_j(x_1,…,x_t)$$ 对于$e_j$有:$$e_j(x_1,…,x_t) = [f_j(y_0),…,f_j(y_{n-1})] = \\sum_{i=0}^{n-1}2^i f_j(y_i) \\tag{1}$$例如，$(x_1,x_2,x_3) = (101,110,001)$，且$e_j(x_1,x_2,x_3)=x_1 \\land x_2 \\oplus x_3$,则将$x_1,x_2,x_3$代入后可得$e_j(x_1,x_2,x_3)=101=5$,因为$e_j$是按位运算，因此可以把$e_j$拆分为$n$个$f_j$，每个$f_j$都是相同的，且每个$f_j$都是对一个不同变量的同一bit位操作的，这样就可以得到$e_j(x_1,x_2,x_3) = e_j(101,110,001)=[f_j(110), f_j(010), f_j(101)]=2^0f_j(110) + 2^1f_j(010) + 2^2f_j(101) = 5$;将$(1)$带入$e$中可以得到：$$e = \\sum_{j=0}^{s-1}a_j e_j(x_1,…x_t) = \\sum_{j=0}^{s-1}a_j \\sum_{i=0}^{n-1}2^if_j(y_i)=\\sum_{i=0}^{n-1}2^i \\sum_{j=0}^{s-1}a_j f_j (y_i) \\tag{2}$$在$F \\cdot V=0$中，有$\\left(\\begin{matrix} \\vdots \\\\f_0(y_i) \\cdots f_{s-1}(y_i) \\\\ \\vdots \\end{matrix} \\right) \\cdot \\left( \\begin{matrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{s-1}\\end{matrix} \\right) = \\left( \\begin{matrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0\\end{matrix} \\right)$,即$\\sum_{j=0}^{s-1}a_j f_j(y_i)=0$,代入$(2)$中可以得到：$$(2)=\\sum_{i=0}^{n-1}2^i \\sum_{j=0}^{s-1}a_j f_j (y_i)=\\sum_{i=0}^{n-1}2^i \\times 0 = 0$$以上证明了$F \\cdot V = 0 \\Rightarrow e = 0$,下面证明$e=0 \\Rightarrow F \\cdot V = 0$: 假设$e \\equiv 0$，令$m_i = \\sum_{j=0}^{s-1}a_j f_j (x_{1,i}, … , x_{t,i})$，则有：$$e=\\sum_{i=0}^{n-1}2^i \\cdot m_i = 2^0m_0 + 2^1m_1 +…+2^{n-1}m_{n-1} \\equiv 0 \\tag{3}$$假定我们有任意输入$x_{1,k},…,x_{t,k}$，且其$m_k = \\bar{m} \\not = 0$,则将其代入$(3)$中有：$$e=2^0 \\bar{m} + 2^1 \\bar{m} +…+2^{n-1} \\bar{m} \\equiv 0 \\Rightarrow \\bar{m} = 0$$但是$\\bar{m}=0$与假设的$\\bar{m} \\not = 0$矛盾，因此可以得出结论对任意的$m_i$都有$m_i=0$，即$\\sum_{j=0}^{s-1}a_j f_j (x_{1,i}, … , x_{t,i})=0$，进而有$F \\cdot V = 0$.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Information Security","slug":"Computer-Science/Information-Security","permalink":"http://w4ow.github.io/categories/Computer-Science/Information-Security/"}],"tags":[{"name":"MBA Obfuscation","slug":"MBA-Obfuscation","permalink":"http://w4ow.github.io/tags/MBA-Obfuscation/"}]},{"title":"Latex常见数学符号整理","slug":"computer_science/Tools/tex","date":"2019-09-22T03:00:00.000Z","updated":"2019-09-22T03:00:00.000Z","comments":true,"path":"2019/09/22/computer_science/Tools/tex/","link":"","permalink":"http://w4ow.github.io/2019/09/22/computer_science/Tools/tex/","excerpt":"LaTeX常见数学符号整理","text":"LaTeX常见数学符号整理 1. 数学模式重音符 Show Code $\\hat{a}$ \\hat{a} $\\check{a}$ \\check{a} $\\tilde{a}$ \\tilde{a} $\\acute{a}$ \\acute{a} $\\grave{a}$ \\grave{a} $\\dot{a}$ \\dot{a} $\\ddot{a}$ \\ddot{a} $\\breve{a}$ \\breve{a} $\\bar{a}$ \\bar{a} $\\vec{a}$ \\vec{a} 2. 小写希腊字母 Show Code $\\alpha$ \\alpha $\\theta$ \\theta $o$ o $\\upsilon$ \\upsilon $\\beta$ \\beta $\\vartheta$ \\vartheta $\\pi$ \\pi $\\phi$ \\phi $\\gamma$ \\gamma $\\iota$ \\iota $\\varpi$ \\varpi $\\varphi$ \\varphi $\\delta$ \\delta $\\kappa$ \\kappa $\\rho$ \\rho $\\chi$ \\chi $\\epsilon$ \\epsilon $\\lambda$ \\lambda $\\varrho$ \\varrho $\\psi$ \\psi $\\varepsilon$ \\varepsilon $\\mu$ \\mu $\\sigma$ \\sigma $\\omega$ \\omega $\\zeta$ \\zeta $\\nu$ \\nu $\\varsigma$ \\varsigma $\\eta$ \\eta $\\xi$ \\xi $\\tau$ \\tau 3. 大写希腊字母 Show Code $\\Gamma$ \\Gamma $\\Lambda$ \\Lambda $\\Sigma$ \\Sigma $\\Psi$ \\Psi $\\Delta$ \\Delta $\\Xi$ \\Xi $\\Upsilon$ \\Upsilon $\\Omega$ \\Omega $\\Theta$ \\Theta $\\Pi$ \\Pi $\\Phi$ \\Phi 4. 二元关系符该表中的所有符号都可以通过在代码前加上\\not来得到其否定形式。 Show Code $&lt;$ &lt; $&gt;$ &gt; $=$ = $\\le$ \\le $\\ge$ \\ge $\\equiv$ \\equiv $\\ll$ \\ll $\\gg$ \\gg $\\doteq$ \\doteq $\\sim$ \\sim $\\simeq$ \\simeq $\\approx$ \\approx $\\subset$ \\subset $\\supset$ \\supset $\\cong$ \\cong $\\subseteq$ \\subseteq $\\supseteq$ \\supseteq $\\Join$ \\Join$^a$ $\\in$ \\in $\\ni$ \\ni $\\propto$ propto $\\mid$ \\mid $\\parallel$ \\parallel $:$ : $^a$使用宏包latexsym来得到这个符号 5. 二元运算符 Show Code $+$ + $-$ - $\\cdot$ \\cdot $\\pm$ \\pm $\\mp$ \\mp $\\div$ \\div $\\times$ \\times $/$ / $\\setminus$ \\setminus $\\star$ \\star $\\ast$ \\ast $\\circ$ \\circ $\\cup$ \\cup $\\cap$ \\cap $\\bullet$ \\bullet $\\lor$ \\lor $\\land$ \\land $\\oplus$ \\oplus $\\odot$ \\odot $\\boxplus$ \\boxplus 6. 大尺度运算符 Show Code $\\sum_{1}^{2}$ \\sum_{1}^{2} $\\prod_{1}^{2}$ \\prod_{1}^{2} $\\int_{1}^{2}$ \\int_{1}^{2} 7. 箭头 Show Code $\\gets$ \\gets $\\to$ \\to $\\leftrightarrow$ \\leftrightarrow $\\Leftarrow$ \\Leftarrow $\\Rightarrow$ \\Rightarrow $\\Leftrightarrow$ \\Leftrightarrow $\\mapsto$ \\mapsto 8. 定界符 Show Code $($ ( $)$ ) $\\left( \\right)$ \\left( \\right) $\\lbrace \\rbrace$ { } or \\lbrace \\rbrace 9. 其他符号 Show Code $…$ … $\\cdots$ \\cdots $\\forall$ \\forall $\\exists$ \\exists $’$ ‘ $\\prime$ \\prime $\\triangle$ \\triangle $\\infty$ \\infty $\\bot$ \\bot $\\top$ \\top $\\angle$ \\angle $\\surd$ \\surd $\\nabla$ \\nabla $\\heartsuit$ \\heartsuit $\\clubsuit$ \\clubsuit $\\spadesuit$ \\spadesuit $\\neg$ \\neg or \\lnot $\\vdots$ \\vdots 10. 数学字母 字样 命令 宏包 $\\mathrm{ABCabc}$ \\mathrm{ABCabc} $\\mathit{ABCabc}$ \\mathit{ABCabc} $\\mathcal{ABCabc}$ \\mathcal{ABCabc} $\\mathfrak{ABCabc}$ \\mathfrak{ABCabc} eufrak $\\mathbb{ABCabc}$ \\mathbb{ABCabc} amsfonts or asmsymb","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"http://w4ow.github.io/tags/Latex/"}]},{"title":"基于Mixed Boolean-Arithmetic的混淆","slug":"computer_science/Information-Security/Obfuscation with Mixed Boolean-Arithmetic","date":"2019-09-16T05:00:00.000Z","updated":"2019-10-11T08:41:00.000Z","comments":true,"path":"2019/09/16/computer_science/Information-Security/Obfuscation with Mixed Boolean-Arithmetic/","link":"","permalink":"http://w4ow.github.io/2019/09/16/computer_science/Information-Security/Obfuscation with Mixed Boolean-Arithmetic/","excerpt":"基础介绍","text":"基础介绍 Introduction软件保护用于保护程序免受不必要的分析，程序混淆是软件保护的一种手段。程序混淆是指对代码进行转换使程序变的难以理解。混淆以两种主要方式隐藏程序的语义：1.改变code和data(例如，改变数据的值)，2.添加无关信息(例如垃圾代码)。MBA(Mixed Boolean-Arithmetic)混淆技术结合两种方法来混淆常见的数学表达式，例如重写运算符、引入新的运算符和常量等。 1. Background1.1 程序混淆的定义及应用混淆是对程序的动态转换行为，其目的是使程序的分析变的困难，同时保证程序的可观察性。 混淆通常有四个属性： 功能：混淆后的程序必须具有与原始程序相同的功能； 效率：与原始程序相比，混淆后的程序的大小和执行时间必须是可接受的； 健壮性：混淆程序必须比原始程序更难分析； 正确性：混淆后的程序应当与源程序有相同的语义和功能。 软件混淆应用领域包括软件加密、打包、反调试或防篡改等，应用范围包括但不限于： 恶意检测：避免恶意软件的恶意检测； 保护知识产权：保护商业软件中的算法或协议； 权限管理：无论是通过许可检查来保护对软件的访问，还是通过数字版权管理(DRM)方案保护数字内容，这些技术通常都会嵌入关键信息(例如加密密钥和协议)，并且使用混淆来保护这些信息。嵌入在程序中的DRM方案(例如VOD服务或视频游戏保护)目前是现代环境中混淆的主要来源之一； 保护个人敏感数据：例如，在移动应用程序中，设备中保存了大量敏感数据(例如银行帐户详细信息)。混淆可以保护这些数据以及处理数据的协议。 1.2 理论混淆和实际混淆1.2.1 密码混淆密码混淆旨在为混淆提供一个正式的上下文，特别是围绕量化分析给定程序$P$的混淆程序$\\mathcal O(P)$的难度。 软件混淆的正式研究由Barak等人发起，他们引入了虚拟黑匣子(VBB)的概念作为混淆程序的最佳属性。VBB保证任何可以从程序$\\mathcal O(P)$的输入/输出行为中学到的，从$P$中也可以学到。 Barak提出了不可区分混淆的定义：如果两个相同大小的程序P1和P2实现相同的功能，则它们的混淆$\\mathcal O(P_1)$和$\\mathcal O(P_2)$应无法区分。 Goldwasser等人提供了最佳可能混淆的定义：从$\\mathcal O(P)$中提取的任何信息都可以通过类似大小的其他功能相同的的程序取得。 他们还证明，对于有效的混淆器，不可区分混淆和最佳混淆是等价的。 2013年，Garg等人提出了通用的不可区分混淆，该混淆基于三个组成部分：作为计算模型的分支程序，完全同态加密和多线性映射。 1.2.2 实际混淆密码混淆在实际上难以应用，因此商用混淆一般都是基于不同程序转换的组合。一些最常用的商用混淆有strong.protect和Arxan3。混淆主要在以下三个层次上工作： 源代码混淆在源代码上操作的混淆，这种混淆能够充分利用编程语言的特性。因为混淆步骤是在编译之前进行的，因此它也更容易集成到现有的编译链中。这种方法的主要缺点是对不同的语言需要设计不同的混淆。 中间代码混淆IR设计的目的之一是独立于任何源语言或目标语言，因此在IR上进行混淆更加通用，能够处理不同高级语言和汇编语言的程序，但同时这种混淆集成更加困难，因为很难将混淆器添加到现有的编译工具链中。 汇编语言混淆与IR和源码相比，汇编级混淆会导致大量信息的丢失，因此很难实现仅在汇编时工作的通用混淆器。 1.3 程序分析程序分析指对程序进行分析，从而得到有用信息。从反汇编程序中可以推断出控制流和数据流两种不同的信息，因此可以从数据流和控制流两种不同的角度分析程序。 控制流：程序的控制流规定了程序的执行过程，通常用Control Flow Graph(CFG)和Call Graph(CG)表示控制流。在CFG中，节点被称为Basic Block(BB)，每一个BB包含多条指令，并且BB中的代码都是顺序执行的。而CFG中的edge则表示BB之间的可能执行路径。在CG中，节点代表一个函数，边代表函数之间的调用。 数据流：和控制流不同，数据流没有固定的图形表示：不同的数据流分析会产生不同的表示。典型的数据流分析是到达定义，该分析中包括确定每个变量可能已定义的位置。这些信息可以从CFG中观察每个BB的输入和输出提取。 程序分析的手段也分为两类： 静态分析程序的静态分析无需执行程序，而是分析程序源码(可通过反汇编获得，但反汇编通常比较困难)。静态分析的第一步通常是重建函数的CFG或程序的CG(可以利用工具)。为了模拟程序的运行，可以使用符号执行。静态分析可以安全分析潜在恶意二进制文件，因为不需要执行。但是由于静态分析会分析程序所有可能的执行路径，所以可能会导致过度分析。 动态分析程序的动态分析是在特定输入上完成的，并推断出所采用的执行路径和数据修改的信息。由于仅分析了可能的执行路径的子集，因此可能导致分析不足。动态分析的例子包括： 调试：在执行期间，逐步或使用断点以交互方式观察程序。 跟踪：记录每条执行的指令，并离线分析(执行后)。 数据污染：标记一个或多个变量，并在程序执行时观察它们对程序的影响。 大多数动态分析技术也可以静态地用于符号执行。 1.4 经典混淆技术1.4.1 控制流混淆几种简单地控制流混淆技术：inlining和outlining、Opaque Predicate、Control Flow Flattening等 inlining &amp; outlining内联指用程序本身来代替对函数g的调用。即，若函数$f$调用函数$g$，则可以使用内联将函数$g$的代码插入到函数$f$中，使两者成为一体，从而省去调用。外联则相反，是将函数内一段代码独立成一个函数。这两种技术都能够达到修改函数的CFG和CG的目的，但不修改程序的功能，从而达到控制流混淆的技术。 Opaque Predicate不透明谓词是是控制流复杂化的混淆技术，这种方法可以再混淆工具Obfuscator-LLVM中找到。传统的不透明谓词用于在CFG中创建伪分支。例如，$$\\forall x, y \\in \\mathbb{N}, \\mathrm{if} \\ x = y^2,\\mathrm{then} \\ P = (x \\equiv 0\\ mod\\ 4) \\vee (x \\equiv 1\\ mod\\ 4) \\equiv True $$上面的例子中$P$的值始终为$true$，则$P=flase$的分支将永远不会执行，那么就可以在这些不会被执行的路径中插入垃圾代码以达到混淆的目的。应对不透明谓词的方法通常是通过使用符号执行来收集不透明谓词，并使用SMT求解器来解决混淆。 Control Flow Flattening控制流扁平化的想法是通过在数据流中编码控制流的信息来完全改变函数CFG的结构。实现此目的的一种方法是为BB编号，并创建一个使用变量管理执行的调度程序，该变量确定BB的执行顺序。在每个BB的末尾，变量都会更新，执行将返回到调度程序。 1.4.2 数据流混淆常见数据流混淆技术：变量拆分、改变变量表示、编码等。 变量拆分将一个变量拆分为多个变量，可以增加程序分析的难度。例如：$$\\mathcal{O}(x) \\to x_1 \\times a + x_2$$其中$\\mathcal{O}(x)$代表混淆转换，即将变量$x$拆分为$x_1, x_2$等。 改变变量表示通过改变变量的表示形式，可以隐藏变量的值以及应用与于变量的操作。例如，一般计算机中使用二进制表示整数，可以通过改成使用三进制表示整数从而达到隐藏数据的目的 编码编码是最常见的数据流混淆技术之一。编码旨在防止变量的值在程序执行过程中显式的出现在内存中。这项技术被借用到密码白盒领域。实际上，混淆中的编码通常是仿射函数，因为它们很容易相互转换并且在性能开销较小。传统上，变量必须在进行计算之前先解码，计算之后还需重新编码。 1.4.3 白盒白盒加密技术是加密技术和实际混淆技术之间的交叉领域，其目的是在白盒攻击环境中保护程序中的加密算法，即程序的运行环境是可控的。与理论上可以应用于任何程序并隐藏数据或算法的混淆相比，只有加密算法是白盒，并且该过程可以使用算法的特殊性来帮助隐藏所使用的密钥。白盒密码术是混淆密码算法中的重要概念，通常是混淆器中必不可少的。 1.5 混淆技术的评价指标程序的复杂性是指其： 指令数量 控制流复杂性 数据流复杂性 因此Collberg等人基于此提出了三种指标来评价混淆转换： Potency：即上述提及的程序的复杂度，如果混淆转换增加了程序复杂性，则它是有效的转换。在论文MBA-Blast中提到可以通过4中方法增加程序复杂性：(1)增加布尔运算符和算术运算符的数量；(2)引入新的整数或bit向量；(3)隐藏真实参数；(4)打乱计算顺序。 Resilience：即混淆对反混淆的健壮性。 Cost：主要分为两部分：产生混淆程序的代价，以及与原始程序相比，混淆程序所需的额外执行时间和空间。 Correctness：混淆后的程序应当与源程序有相同的语义和功能。 另一个常见的度量标准是隐身性，即检测到混淆的难度。Collberg定义了隐秘隐身(分析人员无法确定是否已应用混淆)和局部隐身(分析人员无法确定在何处应用了混淆)。 2. 已有工作2.1 MBA表达式MBA(混合布尔算数)表达式是混合了算术运算符(加法、乘法等)和布尔运算符(与、或、非等)的表达式。 2.1.1 多项式MBA表达式下面给出了一些有关MBA表达式的定义： Definition 1(多项式MBA表达式)MBA表达式$E$，$$E = \\sum_{i \\in I} a_i \\left( \\prod_{j \\in J_i} e_{i,j}(x_0,…,x_{t-1}) \\right)$$其中累和与累积是模$2^n$的，$a_i$是一个常数，$e_{i,j}$是变量$x_0,…,x_{t-1} \\ in \\ \\lbrace 0,1 \\rbrace ^n$的按位表达式，具体公式参加论文。根据定义，多项式MBA表达式的组合仍然是多项式MBA表达式。为简洁起见，本文其余部分中的“MBA表达式”一词代表多项式MBA表达式。此外，本研究仅限于常用的运算符：算术{+，-，×}和布尔值{∧，∨，⊕，¬}，对于此类运算符，我们同时使用按位和布尔项。 2.1.2 基于MBA的混淆表达式的混淆使用MBA表达式混淆运算符的过程依赖于两部分： MBA重写：用等效的MBA表达式重写所选的运算符。 身份的插入：假定$e$是将被混淆的表达式的一部分，那么$e$可以被写为$f(f^{-1}(e))$，其中$f$为在$\\mathbb{Z}/2^n \\mathbb{Z}$上的可逆函数。在周等人的工作中，$f$是仿射函数。由于该过程与编码过程非常接近，因此我们通常将此步骤称为编码步骤。为了强化混淆的效果，还可以交替多次使用上述两个方法，交替多次使用在现实场景中十分流行。 不透明常量对于常量也可以使用MBA表达式来混淆隐藏。隐藏常量使用置换多项式，它们是$\\mathbb{Z}/2^n \\mathbb{Z}$上的可逆多项式。常数混淆(或不透明常数)按以下方式构造： 令多项式$P \\in P_m(\\mathbb{Z}/2^n \\mathbb{Z})$，$Q$是$P$的反函数：$P(Q(X))=X, \\forall X \\in \\mathbb{Z}/2^n \\mathbb{Z}$ 令$K\\in \\mathbb{Z}/2^n \\mathbb{Z}$是想要隐藏的常量 令$E$是变量$(x_1,…,x_t)\\in (\\mathbb{Z}/2^n \\mathbb{Z})^t$非平凡等于0的MBA表达式，例如$E=x+y-(x\\oplus y)-2\\times (x\\land y)$ 那么$K$可以被$P(E+Q(K))=P(Q(K))=K$替换，无论$(x_1,…,x_t)$取何值该替换始终成立。 2.1.3 生成新的MBA等式Zhou等人提供了一个生成新的MBA等式的方法，该方法是从定理1中推导出来的的： Theorem 1令$n$是bit位数，$s$为按位表达式的数量，$t$为变量的数量，令 $(X_1,…,X_k,…,X_t) \\in \\lbrace \\lbrace 0, 1 \\rbrace ^n \\rbrace ^t$是变量的n位表示的向量 $e_0,…,e_j,…,e_{s-1}$是按位表达式 $e = \\sum_{j=0}^{s-1} a_j e_j$是一个线性MBA表达式，有$a_j$个整数 后续见论文 2.2 表达式简化对表达式进行简化有两种方法： 计算两个相等对象的统一表示(规范形式) 寻找一个相等，但更简洁的表示形式 第一种简化方法是研究最多的，因为它可以证明表达式的等价性并检查是否等于零。但是，规范形式未必是最简单的形式。由于混淆的设计既可以应对人工分析和自动分析，因此程序和表达式的简洁性定义是二义的：对于人类而言，可读性更重要；而对于机器而言，性能问题则更重要。 算术多项式的简洁性难以定义，例如：$$(x-3)^2-x^2+7x-7=x+2$$$$(1+x)^100=1+100x+…+100x^99+x^100$$有时多项式展开后更简洁，有时不展开更易读。 布尔函数的简化通常是将表达式规约为范式。 2.3 比特向量逻辑计算机系统需要一个适合于机器逻辑的框架，用以描述元素和对这些元素的操作。在机器级别上，对象使用位向量(例如二进制)表示，处理器上任意可用的运算可以用来构建表达式。位向量逻辑适用于这种机器表示形式：每个对象都由一个位向量表示，传统上考虑的运算符为：算术$+,-,\\times,/$，布尔值$\\oplus,\\wedge,\\lor,\\lnot$，移位$\\ll,\\gg$，串联$\\circ$等。通常实现位向量逻辑的工具是SMT求解器，例如Z3和Boolector。尽管它们是约束求解器，而不是简化器，但它们有时提供简化，例如Z3的简化函数。 2.4 术语重写重写系统由一组对象以及转换这些对象的操作组成。在术语重写的情况下，那些对象是术语(或表达式)。 2.5 DAG表示在计算机中，程序可以用抽象语法树AST和有向无环图DAG表示，同样的，表达式也可以用这两种图来表示。 Definition 5：DAG representation.MBA表达式的DAG表示是一个有下列特征的有向无环图： 所有的叶子节点表示常量或变量，其他节点表示算术操作或位操作； 边代表操作顺序； 仅有一个根节点； 公共表达式在图中仅出现一次。 值得注意的是，DAG表示与紧凑术语图表示是等价的。 2.6 优化与反混淆编译器通常具有与机器无关的优化阶段，该阶段程序的以IR表示(例如LLVM)。执行效率更高的代码其可读性较差，优化有时与反混淆有一个共同的目标。例如，消除死代码或常量替换(使用常量代替值不会改变的变量)能够提高代码可读性。某些混淆技术甚至可能无法抵抗优化过程，这类混淆实在是毫无用处。在本节中，我们介绍两种可以在理论上对任何程序进行混淆的优化技术，它们基于程序的行为而不是基于其描述：超优化和程序合成。 2.6.1 超优化超优化即为单个无循环汇编指令序列找到最佳代码。一般最佳代码是指执行最快的代码，或者时代码体积择最小的代码。Massalin等提出的超优化方法时暴力法，它列举了增加长度的指令序列，并选择与目标序列等价的最低成本序列。 尽管超优化在一些混淆中是有用的，但它不能运行在我们定义的上下文中，否则会导致两个问题： 对于超优化来说，最佳代码的定义基于性能(更快、更小)，这与我们的可读性目标不同； 与混淆相比，优化的对象的代码长度较小(例如优化只能操作10余条指定，而混淆可以操作更多)。 2.6.2 程序合成程序合成是根据用户意图自动寻找可执行程序的过程，这种意图是通过各种形式的约束来表达的，例如输入输出示例、演示、自然语言等。程序合成已经有了许多实际应用：生成最佳代码序列（超优化可以看作是程序合成的特殊情况）、自动执行重复的编程任务、优化对性能至关重要的内部循环等。 3. MBA简化的难点3.1 操作符不兼容布尔运算和算术运算难以交互，因此需要特殊方法来处理混合计算。IDEA是90年代提出分组密码，以结合使用整数算术和按位运算符而闻名。IDEA的主要特征之一是缺少S盒，取而代之的是，它依赖于三个关键组件： 乘法$\\odot$ 加法$\\boxplus$ 位异或$\\oplus$ IDEA的方法为本工作中的混合计算提供了灵感。同样的，密码学中加密的研究和混淆也有许多相似之处。 3.2 已有的MBA简化工具1. SMT求解器 位向量逻辑是处理MBA表达式的良好理论框架，实现位向量逻辑的工具有SMT求解器。SMT求解器包括Z3、Boolector、Yices。Z3使用位向量的原理，提供了多项式简化以及布尔运算简化，同时prove方法能够实现证明MBA表达式及其简化之间的等价性。但是Z3对于本文要解决的MBA表达式，其处理效率并不高，Z3中提出的两个步骤很有启发：第一个是重写，用以执行基本简化，重写通常是SMT求解器中所谓的预处理部分。第二步称为位爆破(也称为平整化)，即用二进制数代替整数重写整个公式。Boolector和Yices不能简化MBA表达式，只能证明MBA表达及其简化是等效的。 编译器中的优化pass 现代编译器(如LLVM)中的优化pass可以简化部分的MBA表达式，但是对复杂MBA就显得无能为力了。 3.3 表达式的复杂性指标对一个MBA表达式，其复杂性的定义是比较困难的。例如表达式$x+y$和$(x \\lor y) + (\\lnot x \\lor y) - (\\lnot x)$，两个表达式对任意输入$x,y$，其计算结果都是相同的，但是左侧明显比右侧更简洁。如何科学的定义表达式的复杂性，这里介绍几个常用的指标。 1. DAG节点数 由于可以使用DAG来表示一个expression，因此可以用DAG的节点数来衡量表达式的复杂性，节点越多越复杂。 2. MBA交替 MBA运算之所以复杂，是因为它混合了布尔计算和算术计算，因此可以使用MBA交替来衡量连接不同类型操作的操作数。例如$x \\land y + x$，该表达式的MBA交替为1。纯算术或纯布尔表达式的MBA替换为0。我们定义操作符$op \\in \\lbrace +,-,\\times, \\oplus,\\wedge,\\lor,\\lnot \\rbrace$，则MBA交替是DAG中连接不同类型的运算符的边的数目。即：对于一个图$G=(V,E)$，其MBA交替$alt_{MBA}(G)$是：$$alt_{MBA}(G) = |\\lbrace (v_1, v_2), type(v_1) \\not = type(v_2) \\rbrace |, (v_1, v_2) \\in E$$这些边代表了简化MBA表达式的难点，因为包含相同类型边的子图可以通过经典简化技术进行简化，而包含不同类型的子图则很难简化。 3. 平均位向量大小 在Obfuscation with Mixed Boolean-Arithmetic Expressions这篇文献中还提到了一个称为平均位向量大小的指标。在DAG中，对于一个节点$v$，其位向量大小$bvsize(v)$是： 若$v$是不是操作符，则它表示变量或常量的位数，位数可以从上下文中推导。 若$v$是操作符： 若$v \\in \\lbrace +,-,\\times, \\oplus, \\lor \\rbrace$，且$v_1,v_2$为操作对象，则$bvsize(v)=max(bvsize(v_1),bvsize(v_2))$，即位数最大的那个； 若$v$为布尔操作$\\land$，则$bvsize(v)=min(bvsize(v_1),bvsize(v_2))$，即位数最小的那个，例如$0b10110101 \\land 0b1111$，前者的高四位经操作后都为0，所以取后者位数； 若$v$为一元操作符$\\lbrace \\lnot, - \\rbrace$，则$bvsize(v)=bvsize(v_1)$。 增加变量的位数，可能会使混淆的破解变难罢了，但是变量位数的增加对表达式的复杂性并无影响，因此位向量大小作为评价表达式的复杂性无多大意义。 4. MBA混淆技术分析本章介绍如何对表达式进行混淆和去混淆。随后提出了基于位和基于字的两种方法。两种方法在GitHub上都可找到：arybo是用C和Python实现的，并且是基于位爆方法的；SSPAM是用Python实现的，并且可以通过使用模式匹配在字级上工作。 4.1 手动重建混淆过程4.1.1 从汇编到源码使用Miasm逆向工程框架生成了混淆表达式的Python代码，并删除了与标志有关的表达式。源码以及反汇编的Python代码可参见论文图4.1、图4.2，得到的最终表达式见论文。 4.1.2 其他混淆在分析该MBA混淆表达的示例时，必须对其进行简化，以便排除与MBA混淆不相关的技术。 位向量尺寸扩展在4.1.1中得到的表达式中，有两条是这样的：$$f=((0x0D000000+0x67000000 \\times (e+e-(0xFF \\land d))) \\gg 0x18)$$$$R = (0xFF \\land (0xC2 + 0xE5 \\times (0x22 \\lor (0xAE)f) + (0xFFFFB22D)f))$$最终结果$R$是8位的(因为与上8位的0xFF)，所以可以将所有的表达式都简化为8位。但是由于存在位移操作，作者的做法是将$f$中的常量右移了24位，其余的都是直接截取后8位，最后再将16进制数转换成10进制。 编码1.4.2节中介绍了使用编码的数据流混淆技术：相关变量在写入内存之前先进行编码，然后在读取时进行解码。传统上编码是一个仿射函数。 因此，此处作者使用了编码函数$x \\mapsto 229x + 247$，解码函数为$x \\mapsto 237 \\times (x-247)$。 4.1.3 MBA表达式的反混淆本节举例介绍了如何得出混淆表达式，很多推导没看懂，在此不再整理。 4.2 使用位爆炸的简化第一个简化方法是基于比特向量逻辑，即位爆炸方法。 4.2.1 描述操作布尔表达式的范式是代数范式ANF，ANF是只包含$\\oplus$和$\\land$的表达式。 5. MBA混淆技术的健壮性5.1 MBA混淆应对黑盒攻击的健壮性黑盒共计通过程序的输入和输出来推断程序的信息，为此通常要考虑两个问题：找到一个函数的良好近似需要多少个输入/输出对，以及应该使用哪种算法来构建该近似，在黑盒中重构函数的难度通常取决于函数本身，有几种策略可以提高重构函数的难度： 添加不影响计算结果的变量； 增加位向量的大小，因为这会增加可能的重构函数的解空间； 增加表达式的节点数，因为这也会减慢输入/输出对的计算。操作符混合并不能明显提高对黑盒攻击的抵抗性，因为它仅能减缓黑盒攻击的速度，而不能使反混淆攻击失败。 5.2 针对简化工具的弹性因为简化工具使用表达式的实际描述，因此它是白盒攻击。 5.2.1 位爆炸爆破方法的最大优势是将MBA简化问题转换为布尔表达式简化问题，该领域已经有很多前人展开过工作。使用位爆炸法时，我们可以使用几种范式来为任何表达式提供唯一的表示形式。位爆炸的主要缺点是布尔表达式的规范化在内存和时间上代价很高。另一个问题是，从布尔表达式到字级表达式的识别并不容易。在尝试识别一个运算符时，我们提供了一些技巧，但是识别包含多个运算符的更复杂表达式的问题显然是将来需要解决的问题。作者使用arybo工具反混淆了几个MBA混淆表达式，当表达式位数为8位时只用了0.09s就能正确识别出原始表达式，但是当表达式位数为12位时，解析时间达到了61.32s。对于位数量较少的表达式，使用位爆破的简化非常有效。因此，可以通过提高位数来提高MBA混淆表达式的弹性。不过，作者在3.4.3节中介绍的还原方法可以轻松简化这种混淆。 5.2.2 符号简化因为使用符号简化的算法在字级别上起作用，所以简化不受表达式位数增加的影响，另外，AST表达式的“大小”也远小于位爆破方法中的表示。例如，x+y在字级具有3个节点，可容纳任意数量的位；而4位的位爆破法则有3、6、17、41个节点。这种方法的主要缺点是，它高度依赖于所选的重写规则集。即使具有所有混淆规则的列表，也不能保证具有令人满意的反混淆。对于该种方法，作者使用了SSPAM工具来进行测试。对于使用一般混淆(公共可用)的混淆方法混淆的表达式，SSPAM都能够很快的进行发混淆。随后作者又使用Algorithm 2对原表达式进行混淆，每个表达式都会生成20个混淆表达式，这些混淆表达式作为输入送入SSPAM中，SSPAM不能从20个混淆表达式中成功反混淆出原表达式。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Information Security","slug":"Computer-Science/Information-Security","permalink":"http://w4ow.github.io/categories/Computer-Science/Information-Security/"}],"tags":[{"name":"MBA Obfuscation","slug":"MBA-Obfuscation","permalink":"http://w4ow.github.io/tags/MBA-Obfuscation/"}]},{"title":"使用conda管理Python虚拟环境","slug":"computer_science/Tools/python-virtualenv-conda","date":"2019-09-08T16:00:00.000Z","updated":"2019-09-08T16:00:00.000Z","comments":true,"path":"2019/09/09/computer_science/Tools/python-virtualenv-conda/","link":"","permalink":"http://w4ow.github.io/2019/09/09/computer_science/Tools/python-virtualenv-conda/","excerpt":"使用conda管理Python虚拟环境","text":"使用conda管理Python虚拟环境 1. 安装Anaconda可以在Anaconda官网下载相应Python版本的软件，或者使用如下命令： 123wget https://repo.continuum.io/archive/Anaconda3-2018.12-Linux-x86_64.shbash Anaconda3-2018.12-Linux-x86_64.sh 2. 创建Python虚拟环境1conda create -n virtual_env_name python=x.x 3. 激活/关闭虚拟环境1234# 激活source activate virtual_env_name# 关闭source deactivate 4. 为相应的虚拟环境安装包1conda install -n virtual_env_name [package] 5. 删除虚拟环境1conda env remove -n(--name) virtual_env_name 6. 常用conda命令12conda env list # 列出所有已创建的虚拟环境conda upgrade conda # 升级","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Tools","slug":"Computer-Science/Tools","permalink":"http://w4ow.github.io/categories/Computer-Science/Tools/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"http://w4ow.github.io/tags/Conda/"}]},{"title":"Install Syntia with Ubuntu 18.04","slug":"computer_science/Information-Security/syntia_install","date":"2019-09-08T16:00:00.000Z","updated":"2019-09-08T16:00:00.000Z","comments":true,"path":"2019/09/09/computer_science/Information-Security/syntia_install/","link":"","permalink":"http://w4ow.github.io/2019/09/09/computer_science/Information-Security/syntia_install/","excerpt":"Syntia是基于程序合成的反混淆框架，它使用程序跟踪作为一个blackbox来产生随机的输入输出对，利用这些输入输出对，程序合成器可以学习代码的底层语义。本文介绍了Ubuntu下安装syntia","text":"Syntia是基于程序合成的反混淆框架，它使用程序跟踪作为一个blackbox来产生随机的输入输出对，利用这些输入输出对，程序合成器可以学习代码的底层语义。本文介绍了Ubuntu下安装syntia 1. 下载源码1git clone https://github.com/RUB-SysSec/syntia 2. 安装第三方Python库Syntiasyntia是一个第三方Python库，使用的是Python2。为了避免Python版本紊乱，可以使用conda创建一个Python2.7的虚拟环境，在该环境中安装syntia。在下载的源码中有setup.py文件，使用下面命令可以安装该Python库： 1python setup.py install 3. 安装依赖软件依赖软件包含在install_deps.sh脚本文件中，原则上可以通过执行该脚本文件来安装4个依赖，但是实际操作却总是报错。因此我使用手动安装 3.1 安装Unicorn12345678910111213# 使用git下载源码git clone https://github.com/unicorn-engine/unicorn.gitcd unicorn# compile./make.sh# installsudo ./make.sh install# 验证，命令执行后出现success，可认为是安装成功了./samples/sample_all.sh 3.2 安装Capstone12345678910111213# 使用git下载源码git clone https://github.com/aquynh/capstone.gitcd capstone# compile./make.sh# installsudo ./make.sh install# 验证，我也不清楚验证结果是什么样代表正确安装./tests/test* 3.3 安装Miasm1234567891011121314151617181920212223# 1. 安装额外Python依赖库# 使用git下载源码git clone https://github.com/serpilliere/elfesteem.git elfesteemcd elfesteempython setup.py buildpython setup.py install# 2. 安装miasmcd ..# 使用git下载源码git clone https://github.com/cea-sec/miasm.gitcd miasmpython setup.py buildpython setup.py install# 验证# 可以通过在Python编程环境中import miasm来验证，若不报错则说明成功安装 3.4 安装Z31234567891011# 使用git下载源码git clone https://github.com/Z3Prover/z3.gitcd z3python scripts/mk_make.py --pythoncd buildmakemake install # 该语句执行后会打印 Z3 was successfully installed.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Information Security","slug":"Computer-Science/Information-Security","permalink":"http://w4ow.github.io/categories/Computer-Science/Information-Security/"}],"tags":[{"name":"MBA Obfuscation","slug":"MBA-Obfuscation","permalink":"http://w4ow.github.io/tags/MBA-Obfuscation/"}]},{"title":"熵权法","slug":"Mathematics/entropy-weight-method","date":"2019-09-04T16:00:00.000Z","updated":"2019-09-04T16:00:00.000Z","comments":true,"path":"2019/09/05/Mathematics/entropy-weight-method/","link":"","permalink":"http://w4ow.github.io/2019/09/05/Mathematics/entropy-weight-method/","excerpt":"熵权法计算权值，Python3实现","text":"熵权法计算权值，Python3实现 1. 输入矩阵假设计算矩阵为：$x=[[1,2,2],[2,1,1]]$ 2. 极差标准化评价指标分为正指标和逆指标，计算公式如下 $$x_{ij}’=\\frac{x_{ij} - \\min_{j=1}^n x_{ij}}{\\max_{j=1}^n x_{ij} - \\min_{j=1}^n x_{ij}}$$ 此处仅展示正指标计算公式。将所有指标都视为正指标，标准化后的$x=[[0,1,1],[1,0,0]]$，可以使用scikit learn库中的MinMaxScaler()方法对数据进行最大最小归一化。 3. 计算指标信息熵信息熵是一个对象所能提供的信息量大小的量化指标，其范围在$(0,1)$之间。 $e$应当为$1*n$大小的矩阵，式中$e_j$代表第$j$项指标的信息熵，信息熵的计算公式为：$$e_j = (-\\frac{1}{\\ln m})\\sum_{i=1}^m (p_{ij} \\cdot \\ln p_{ij})$$其中$p_{ij}$为第$j$个指标的状态为$i$时的概率，即$$p_{ij}= \\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}}$$因此$$e_j = (-\\frac{1}{\\ln m})\\sum_{i=1}^m (\\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}} \\cdot \\ln(\\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}}))$$应用到上述矩阵，可以得到$e=[0.9183, 0.9183, 0.9183]$即 指标名称 信息熵 指标1 0.9183 指标2 0.9183 指标3 0.9183 4.计算指标权重$w$应当为$1*n$大小的矩阵，式中$w_j$代表第$j$项指标的权重$$w_j = \\frac{1 - e_j}{\\sum_{j=1}^n (1-e_j)}$$应用到上述$e$，可以得到$w=[0.33, 0.33, 0.33]$，即 指标名称 权重 指标1 0.33 指标2 0.33 指标3 0.33 5. Coding12345678910111213141516171819202122# language = python3import mathimport numpy as npimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfile = \"test.csv\"data = pd.read_csv(file, header = None)x = data.values.astype(np.float64)x_std = MinMaxScaler().fit_transform(x)def Entropy_Weight(data): m, n = np.shape(data) p = data / data.sum(axis = 0) p[np.where(data == 0)] = 0.01 e = (-1.0 / np.log(m)) * np.nan_to_num(np.sum(p * np.log(p), axis = 0)) w = (1 - e) / np.sum(1 - e) return ww = Entropy_Weight(x_std)","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/categories/Mathematics/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://w4ow.github.io/tags/Mathematics/"}]},{"title":"C++11/14/17新特性简单总结","slug":"computer_science/C-C++/C++14新特性","date":"2019-08-11T02:12:00.000Z","updated":"2019-08-11T02:12:00.000Z","comments":true,"path":"2019/08/11/computer_science/C-C++/C++14新特性/","link":"","permalink":"http://w4ow.github.io/2019/08/11/computer_science/C-C++/C++14新特性/","excerpt":"C++11/14/17新特性简单总结","text":"C++11/14/17新特性简单总结 1. C++11新特性包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进 1. auto关键字C++11中引入auto第一种作用是为了自动类型推导，auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作。需要注意的是，使用auto声明一个变量时，必须对其进行初始化，因为auto是通过初始化表达式进行类型推导的。 2. decltype关键字decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型 3. nullptrnullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0 4. 序列for循环在C++中for循环可以使用类似python的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator） 5. Lambda表达式lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下： 1[函数对象参数]（操作符重载函数参数）-&gt;返回值类型&#123;函数体&#125; 6. 其他。。。2. C++14新特性C++14的新特性主要分为三个领域：Lambda函数、constexpr和类型推导。 函数返回类型auto lambda参数auto lambda捕获参数初始化 [[deprecated]] 二进制常量0b/0B 单引号分位符0b1111’0000 模板变量 3. C++17新特性 结构化绑定auto [a, b]构造函数模板推导std::pair{1, 5.0} inline变量 if constexpr fold表达式 非类型模板参数auto satic_assert自定义错误信息 typename代替class声明模板的模板参数 嵌套命名空间namespace X::Y {…} 新增加属性[[fallthrough]] [[maybe_unused]] [[nodiscard]] if/switch初始化 string_view variant/any/optional void_t container.extract 删除trigraphs（即三连字符??*)","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"C++中结构体和类的区别","slug":"computer_science/C-C++/different_between_struct_and_class","date":"2019-08-09T16:00:00.000Z","updated":"2019-08-09T16:00:00.000Z","comments":true,"path":"2019/08/10/computer_science/C-C++/different_between_struct_and_class/","link":"","permalink":"http://w4ow.github.io/2019/08/10/computer_science/C-C++/different_between_struct_and_class/","excerpt":"C++中结构体和类的区别","text":"C++中结构体和类的区别 1. C和C++中struct的不同 C中的结构体只能定义成员变量，不能定义成员函数，C++可以； C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性； C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1; C++中之所以要引入结构体，是为了保持和C程序的兼容性。C++中不使用结构体丝毫不会影响程序的表达能力，但有时仍会在C++中使用结构体，这是因为使用结构体将不同类型数据组成整体便于保存数据。（若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦。） 2. C++中struct和class的不同C++中struct和class唯一的不同是struct和class具有不同的默认访问控制属性，class中的成员的默认控制访问属性为private，而struct中的默认访问控制属性为public。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"常见排序算法总结与比较","slug":"computer_science/Algorithm/sort","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-07T16:00:00.000Z","comments":true,"path":"2019/08/08/computer_science/Algorithm/sort/","link":"","permalink":"http://w4ow.github.io/2019/08/08/computer_science/Algorithm/sort/","excerpt":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。","text":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。 1. 总体比较时间复杂度与稳定性 类别 名称 平均复杂度 最好情况 最差情况 空间复杂度 稳定性 交换比较类 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 交换比较类 快速排序 $O(nlogn)$ $O(n^2)$ $O(n^2)$ $O(logn)$ 不稳定 选择类 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 选择类 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 插入类 直接插入 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 插入类 二分排序 $O(n^2)$ $O(nlogn)$ $O(n^2)$ – 稳定 插入类 希尔排序 $O(nlogn)$ $O(n)$ $O(n^s)1$ $O(1)$ 不稳定 其他 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 其他 基数排序 $O(log_R B)$ – $O(log_R B)$ $O(n)$ 稳定 其他 二叉排序 $O(nlogn)$ – $O(nlogn)$ $O(n)$ 稳定 其他 计数排序 $O(n+k)$ – $O(n+k)$ $O(k)$ 稳定 其他 拓扑排序 $O(n+e)$ – – $O(n)$ – 其他 枚举排序 $O(n^2)$ – – – – 算法特性 名称 时间复杂度与初序 移动次数与初序 比较次数与初序 排序趟数与初序 每趟确定最终位置 冒泡排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 快速排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 选择排序 ❌ ❌ ❌ ❌ - 堆排序 ❌ ❌ ❌ - ⭕️ 直接插入 ⭕️ ⭕️ ⭕️ ❌ ❌ 二分排序 - - ❌ - - 希尔排序 ⭕️ - ⭕️ - ❌ 归并排序 ❌ ❌ ⭕️ - - 基数排序 ❌ ❌ ❌ - - 二叉排序 ⭕️ - - - - 计数排序 ⭕️ - - - - 拓扑排序 - - - - - 枚举排序 - - - - - 2. 冒泡排序冒泡排序是一种典型的交换排序算法，相邻两数两两⽐比较并交换，直到所有数据排序完成，每一趟排序总能够将无序队列中的最⼤/小置于队尾。适用情况: 待排序列列较小时性能较优。最坏情况: 初始序列基本有序但顺序相反最好情况: 初始序列列基本有序(没有插⼊快，因为要两两比较)应用: 对基本有序序列查前n个元素 12345678void BubbleSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) for (int j = 0; j &lt; array.size() - i; j++) if (array[j] &gt; array[j + 1]) swap(array[j + 1], array[j]);&#125; 3. 选择排序反复选择未排序序列中最大或最小元素，并将其放于已排序序列尾部，直到未排序序列长度为0 1234567891011void SelectSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) &#123; int minIndex = i; for (int j = i; j &lt; array.size(); j++) if (array[j] &lt; array[minIndex]) minIndex = j; swap(array[i], array[minIndex]); &#125;&#125; 4. 直接插入排序将数据分为有序和无序两部分，首先有序部分为空，依次从无序部分中拿出元素插入到有序序列中可能出现情况: 最后一趟开始前，所有元素都不在正确位置上最佳情况: 基本有序下，插⼊排序是最快的 123456789101112void InsertionSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 1; i &lt; array.size(); i++) &#123; int temp = array[i], j = i; while (j &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = temp; &#125;&#125; 5. 归并排序n越⼤大越好优点: 当待排序列列较大，内存一次性放不不下时，需要外部排序，通常使用归并排序归并趟数: m个元素k路归并趟数$s = log_k m$ 12345678910111213141516171819202122232425262728293031void MergeSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return MergeSort(array, left, right);&#125;void Merge(vector&lt;int&gt;&amp; array, int l1, int r1, int l2, int r2) &#123; int i = l1, j = l2; vector&lt;int&gt; temp(array.size()); int index = 0; while (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123; if (array[i] &lt;= array[j]) temp[index++] = array[i++]; else temp[index++] = array[j++]; &#125; while (i &lt;= r1) temp[index++] = array[i++]; while (j &lt;= r2) temp[index++] = array[j++]; for (int i = 0; i &lt; index; i++) array[l1 + i] = temp[i];&#125;void MergeSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; MergeSort(array, left, mid); MergeSort(array, mid + 1, right); Merge(array, left, mid, mid + 1, right); &#125;&#125; 6. 快速排序分治法优点: 平均最快，平均比较次数最少最好情况: 每次能够均匀划分最坏情况: 序列有序，或不均匀划分优化: 快排需要使用递归，因此处理左右子段时，先处理短子段可以减少时间复杂度。先处理短⼦段的话，每次递归深度都是短⼦段的长度对排序对象的要求: 待排序列的存储方式是顺序存储 1234567891011121314151617181920212223242526void QuickSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return QuickSort(array, left, right);&#125;int Partition(vector&lt;int&gt;&amp; array, int left, int right) &#123; int temp = array[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[right] &gt; temp) right--; array[left] = array[right]; while (left &lt; right &amp;&amp; array[left] &lt; temp) left++; array[right] = array[left]; &#125; array[left] = temp; return left;&#125;void QuickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int pos = Partition(array, left, right); QuickSort(array, left, pos - 1); QuickSort(array, pos + 1, right); &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://w4ow.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://w4ow.github.io/tags/Sort/"}]},{"title":"LeetCode 探索初级算法 字符串","slug":"computer_science/Algorithm/Primary_Algorithm_String","date":"2019-08-06T16:00:00.000Z","updated":"2019-08-06T16:00:00.000Z","comments":true,"path":"2019/08/07/computer_science/Algorithm/Primary_Algorithm_String/","link":"","permalink":"http://w4ow.github.io/2019/08/07/computer_science/Algorithm/Primary_Algorithm_String/","excerpt":"反转字符串 整数反转 字符串中的第一个唯一字符 有效的字母异位词 验证回文字符串 字符串转换整数(atoi) 实现strStr() 报数 最长公共前缀","text":"反转字符串 整数反转 字符串中的第一个唯一字符 有效的字母异位词 验证回文字符串 字符串转换整数(atoi) 实现strStr() 报数 最长公共前缀 1. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。 示例 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 解法1：双指针法设置双指针i、j分别指向头尾，交换头尾后各向中间进1. 1234567891011class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; swap(s[i], s[j]); i++; j--; &#125; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 解法2：reverse函数直接使用reverse()函数 123456class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; reverse(s.begin(), s.end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 2. 整数反转给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 12输入: 123输出: 321 解法：模拟栈每次对x取%10余，并将余数×10累加到res中 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; int res = 0, cur; while (x != 0) &#123; cur = x % 10; x /= 10; if (res &gt; INT_MAX/10 || (res == INT_MAX / 10 &amp;&amp; cur &gt; 7)) return 0; if (res &lt; INT_MIN/10 || (res == INT_MIN / 10 &amp;&amp; cur &lt; -8)) return 0; res = res * 10 + cur; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：$O(log(x))$ 空间复杂度：$O(1)$ 3. 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1 示例 12345s = &quot;leetcode&quot;返回0.s = &quot;loveleetcode&quot;,返回2. 解法：hash表使用map保存字符-位置键对，且这一键对的值为该字符出现的次数。随后从头按字符出现的次序遍历map，第一个键值为1的便是解。 123456789101112131415161718class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char,int&gt; hash; for (auto i : s) &#123; hash[i]++; &#125; for (int i = 0; i &lt; s.size(); ++i) if (hash[s[i]] == 1) return i; return -1; &#125;&#125;;**复杂度分析**- 时间复杂度：$O(n)$- 空间复杂度：$O(n)$ 4. 有效的字母异位词给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。 示例1 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例2 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 示例3 12输入: s = &quot;aacc&quot;, t = &quot;ccac&quot;输出: false 解法：hash表使用26大小的数组作为hash表，同时遍历s和t，并在对应位分别++和–。最后再遍历一遍hash表，如果存在不为0的元素，则说明s和t字符不对应，即不是异位词 12345678910111213141516class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.size() != t.size()) return false; int count[26] = &#123;0&#125;; for (int i = 0; i &lt; s.size(); ++i) &#123; count[s[i] - 'a']++; count[t[i] - 'a']--; &#125; for (auto i : count) if (i != 0) return false; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 5. 验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写 示例1 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例2 12输入: &quot;race a car&quot;输出: false 解法：双指针法利用双指针分别从头和尾进行比较，两个关键函数：isalnum()判断是否为字母数字，以及tolower()转换成小写字母 123456789101112131415class Solution &#123;public: bool isPalindrome(string s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; !isalnum(s[i])) i++; while (i &lt; j &amp;&amp; !isalnum(s[j])) j--; if (tolower(s[i++]) != tolower(s[j--])) return false; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 6. 字符串转换整数(atoi)请你来实现一个atoi函数，使其能将字符串转换成整数。 解法这题实在是太麻烦了，各种意想不到的输入都需要考虑到，因此这里提供一个懒人方法，使用sstream库。 123456789class Solution &#123;public: int myAtoi(string str) &#123; int digit = 0; istringstream is(str); is &gt;&gt; digit; return digit; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 7. 实现strStr()给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置(从0开始)。如果不存在，则返回-1 示例 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 解法1：暴力求解从头至尾遍历一遍 12345678class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if needle == \"\": return 0 for i in range(len(haystack)) : if needle == haystack[i : i + len(needle)]: return i return -1 复杂度分析 时间复杂度：$O(nm)$ 空间复杂度：$O(1)$ 解法2：KMP算法123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; getnext(string str) &#123; int len=str.size(); vector&lt;int&gt; next; next.push_back(-1);//next数组初值为-1 int j=0,k=-1; while(j&lt;len-1) &#123; if(k==-1||str[j]==str[k]) &#123; j++; k++; if(str[j]!=str[k]) next.push_back(k); else next.push_back(next[k]); &#125; else &#123; k=next[k]; &#125; &#125; return next; &#125; int strStr(string haystack, string needle) &#123; if(needle.empty()) return 0; int i=0;//源串 int j=0;//子串 int len1=haystack.size(); int len2=needle.size(); vector&lt;int&gt; next; next=getnext(needle); while((i&lt;len1)&amp;&amp;(j&lt;len2)) &#123; if((j==-1)||(haystack[i]==needle[j])) &#123; i++; j++; &#125; else &#123; j=next[j];//获取下一次匹配的位置 &#125; &#125; if(j==len2) return i-j; return -1; &#125;&#125;; 时间复杂度：$O(n+m)$ 空间复杂度：$O(n)$ 解法3：BM算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123;public: void get_bmB(string&amp; T,vector&lt;int&gt;&amp; bmB) &#123; int tlen=T.size(); for(int i=0;i&lt;256;i++) &#123; bmB.push_back(tlen); &#125; for(int i=0;i&lt;tlen-1;i++) &#123; bmB[T[i]]=tlen-i-1; &#125; &#125; void get_suff(string&amp; T,vector&lt;int&gt;&amp; suff) &#123; int tlen=T.size(); int k; for(int i=tlen-2;i&gt;=0;i--) &#123; k=i; while(k&gt;=0&amp;&amp;T[k]==T[tlen-1-i+k]) k--; suff[i]=i-k; &#125; &#125; void get_bmG(string&amp; T,vector&lt;int&gt;&amp; bmG) &#123; int i,j; int tlen=T.size(); vector&lt;int&gt; suff(tlen+1,0); get_suff(T,suff);//suff存储子串的最长匹配长度 //初始化 当没有好后缀也没有公共前缀时 for(i=0;i&lt;tlen;i++) bmG[i]=tlen; //没有好后缀 有公共前缀 调用suff 但是要右移一位 类似KMP里的next数组 for(i=tlen-1;i&gt;=0;i--) if(suff[i]==i+1) for(j=0;j&lt;tlen-1;j++) if(bmG[j]==tlen)//保证每个位置不会重复修改 bmG[j]=tlen-1-i; //有好后缀 有公共前缀 for(i=0;i&lt;tlen-1;i++) bmG[tlen-1-suff[i]]=tlen-1-i;//移动距离 &#125; int strStr(string haystack, string needle) &#123; int i=0; int j=0; int tlen=needle.size(); int slen=haystack.size(); vector&lt;int&gt; bmG(tlen,0); vector&lt;int&gt; bmB; get_bmB(needle,bmB); get_bmG(needle,bmG); while(i&lt;=slen-tlen) &#123; for(j=tlen-1;j&gt;-1&amp;&amp;haystack[i+j]==needle[j];j--); if(j==(-1)) return i; i+=max(bmG[j],bmB[haystack[i+j]]-(tlen-1-j)); &#125; return -1; &#125;&#125;; 时间复杂度：最差$O(n+m)$，最好$O(n)$ 空间复杂度：$O(n)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://w4ow.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://w4ow.github.io/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://w4ow.github.io/tags/String/"}]},{"title":"LeetCode 探索初级算法 数组","slug":"computer_science/Algorithm/Primary_Algorithm_Array","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-05T16:00:00.000Z","comments":true,"path":"2019/08/03/computer_science/Algorithm/Primary_Algorithm_Array/","link":"","permalink":"http://w4ow.github.io/2019/08/03/computer_science/Algorithm/Primary_Algorithm_Array/","excerpt":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像","text":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像 1. 旋转数组给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数 示例1 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例2 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 解法1：暴力解法旋转k次，每次将数组向右旋转移动一位 1234567891011void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int pre, tmp; for (int i = 0; i &lt; k; ++i) &#123; int pre = nums[nums.size() - 1]; for (int j = 0; j &lt; nums.size(); ++j) &#123; tmp = nums[j]; nums[j] = pre; pre = tmp; &#125; &#125;&#125; 复杂度分析 时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$ 空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$ 解法2：使用额外数组使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上. 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; arr = nums; for (int i = 0; i &lt; nums.size(); ++i) arr[(i + k) % nums.size()] = nums[i]; for (int i = 0; i &lt; nums.size(); ++i) nums[i] = arr[i];&#125; 复杂度分析 时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$ 空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$ 解法3：使用环状替换如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。 现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上 12345678910111213141516void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 复杂度分析 时间复杂度：只遍历了一遍数组，$O(n)$ 空间复杂度：只用了常数个额外空间，$O(1)$ 解法4：数组反转先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end());&#125; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$，没有使用额外空间 2. 从数组中删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成. 解法：双指针法数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例： 1234567[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ i i i j j j[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ... i i i j j j 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int j:nums) if (!i || j &gt; nums[i - 1]) nums[i++] = j; return i; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 3. 买卖股票的最佳时机II给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1 12345输入: [7,1,5,3,6,4]输出: 7解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入， 在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。 示例2 12345输入: [1,2,3,4,5]输出: 4解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票， 之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 解法：暴力解法首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论： 一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断； 一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况； 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt; 2) return 0; int profit = 0; bool has_buy = false; if (prices[0] &lt; prices[1]) &#123; profit -= prices[0]; has_buy = true; &#125; for (int i = 1; i &lt; prices.size() - 1; ++i) &#123; if (has_buy == true &amp;&amp; prices[i] &gt; prices[i + 1]) &#123; profit += prices[i]; has_buy = false; &#125; else if (has_buy == false &amp;&amp; prices[i] &lt; prices[i + 1]) &#123; profit -= prices[i]; has_buy = true; &#125; &#125; if (has_buy == true) profit += *(prices.end() - 1); return profit; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 4. 存在重复给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。 解法：使用unorder_set使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set; for (auto it : nums) &#123; if (set.count(it) &gt; 0) return true; else set.insert(it); &#125; return false; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 5. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解法：使用异或该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) ans ^= i; return ans; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 6. 两个数组的交集II给定两个数组，编写一个函数来计算它们的交集。 示例1 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 示例2 12输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]输出: [2,3,5] 解法：使用find()函数使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;nums1.size();i++) &#123; auto it=find(nums2.begin(),nums2.end(),nums1[i]); if(it!=nums2.end()) &#123; res.push_back(*it); nums2.erase(it); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \\sim O(n^2)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 7. 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。 示例 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 解法：反向遍历首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; digits[digits.size() - 1]++; for (auto i = digits.size() - 1; i &gt; 0; --i) &#123; if (digits[i] == 10) &#123; digits[i] = 0; digits[i - 1]++; &#125; &#125; if (digits[0] == 10) &#123; digits[0] = 0; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 8. 移动零给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。 示例 123输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。 解法：双指针法设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1. 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j = 0; while (i &lt; nums.size()) &#123; if (nums[i] == 0) i++; else &#123; swap(nums[i], nums[j]); i++; j++; &#125; &#125; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 9. 两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 123输入: nums = [2, 7, 11, 15], target = 9输出: [0,1]说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1] 解法1：暴力法暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; ans.push_back(i); ans.push_back(j); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 解法2：两遍哈希表以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_set; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash_set.count(target - nums[i]) &gt; 0) &#123; ans.push_back(hash_set[target - nums[i]]); ans.push_back(i); break; &#125; hash_set[nums[i]] = i; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 10. 有效的数独示例 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 解法：一次遍历使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中 1234567891011121314151617181920class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;unordered_map&lt;int,int&gt;&gt; rows(9), cols(9), boxes(9); for(int i = 0; i &lt; 9; ++ i) &#123; for(int j = 0; j &lt; 9; ++ j) &#123; int box_index = (i / 3) * 3 + j / 3; char n = board[i][j]; if(n != '.') &#123; if(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n)) return false; rows[i][n] = 1; cols[j][n] = 1; boxes[box_index][n] = 1; &#125; &#125; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 11. 旋转图像给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。 示例1 12345678910111213给定matrix= [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 解法：翻转先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$ 12345678910class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (int i = 0; i &lt; matrix.size(); ++i) for (int j = i; j &lt; matrix[0].size(); ++j) swap(matrix[i][j], matrix[j][i]); for (int i = 0; i &lt; matrix.size(); ++i) reverse(matrix[i].begin(), matrix[i].end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://w4ow.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://w4ow.github.io/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://w4ow.github.io/tags/LeetCode/"}]},{"title":"C++中的内联函数","slug":"computer_science/C-C++/inline_in_C++","date":"2019-07-30T01:45:00.000Z","updated":"2019-07-30T01:45:00.000Z","comments":true,"path":"2019/07/30/computer_science/C-C++/inline_in_C++/","link":"","permalink":"http://w4ow.github.io/2019/07/30/computer_science/C-C++/inline_in_C++/","excerpt":"内联函数相关知识点梳理","text":"内联函数相关知识点梳理 1. 内联函数的作用引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏： 1#define Expression(a, b) (((a) + (b)) * ((a) - (b))) 该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它使用预处理器实现，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏不能进行参数有效性检测，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。 另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。 为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。 2. inline与宏定义的区别 inline函数的本质是一个函数，而宏不是； inline函数在编译时展开，宏在预编译时展开； 在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换； inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能； 宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。 3. inline的优点 inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高； 类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性； inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。 4. inline的使用场合 用于取代表达式形式的宏定义； 用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，定义在类体内的函数会被自动转换成内联函数。 5. inline的缺点inline是以代码复制为代价的，仅仅省去了函数调用的开销，从而提高函数的执行效率。若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低。另外，每一处内联函数的调用都需要复制代码，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline： 函数体内代码较长：使用inline将导致较高的内存消耗； 函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大； 不用于类的构造函数和析构函数。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"C++中的数据类型及其大小","slug":"computer_science/C-C++/data_type_in_C++","date":"2019-07-29T11:58:00.000Z","updated":"2019-07-29T11:58:00.000Z","comments":true,"path":"2019/07/29/computer_science/C-C++/data_type_in_C++/","link":"","permalink":"http://w4ow.github.io/2019/07/29/computer_science/C-C++/data_type_in_C++/","excerpt":"在C/C++中的数据类型及其所占空间大小总结","text":"在C/C++中的数据类型及其所占空间大小总结 1. 内置数据类型常见的内置数据类型如下表所示，可以使用sizeof查看其大小： type size char 1B unsigned char 1B signed char 1B int 4B unsigned int 4B signed int 4B short (int) 2B long (int) 8B float 4B double 8B long double 16B wchar_t 2B or 4B 其中wchar_t是宽字符型，其定义为 1typedef short int wchar_t; 也就是说，实际上wchar_t和short int是等价的。 2. 数组与字符串对数组使用sizeof运算，其大小为数组中元素的个数*元素所占内存大小，而对于char数组型的字符串，例如char str[] = &quot;Hello&quot;，其大小为字符个数+1，因为结尾需要保存\\0。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。 3. 自定义数据类型3.1. class及struct3.1.1. 空类对于一个空类，例如 1234class A&#123;&#125; 其大小为1B，因为C++中每一个类都有一个独一无二的地址，因此即使是空类也会为其分配1B的内存空间。 3.1.2. 类对象所占内存大小类所占的内存大小由其成员变量决定，成员函数不计算在内，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如 123456789101112131415161718192021222324252627282930313233343536373839404142// sizeof(A) = 4class A&#123; int a;&#125;;// sizeof(B) = 4, 成员函数不计入class B&#123; int a; int fun1() &#123; return 0; &#125;&#125;;// sizeof(C) = 1, 结构体不计入class C&#123; struct stc1 &#123; int sa; char sb; &#125;;&#125;;// sizeof(D) = 1, 联合体不计入class D&#123; union un1 &#123; int ua; short ub; &#125;;&#125;;// sizeof(E) = 1, class不计入class E&#123; class cl1 &#123; int ca; short cb; &#125;;&#125;; 3.1.3. 类对象的字节对齐由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能从某些特定地址开始存取，如果不对其，会给存取效率带来损失。 字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 如果类中包含虚函数，则无论其有多少个虚函数，这些虚函数所占内存均为4B，因为内存中需要保存一个虚表指针成员 举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class A&#123; int i;&#125;;class B&#123; char ch;&#125;;class C&#123; int i; short s;&#125;;class D&#123; int i; short j; char ch;&#125;;class E&#123; int i; int ii; short j; char ch; char ch2;&#125;;class F&#123; int i; int ii; int iii; short j; char ch; char ch2;&#125;;struct G&#123; char ch; int i; short b2;&#125;;class H&#123; int i; virtual void fun1() &#123;&#125; virtual void fun2() &#123;&#125;&#125;;class I : public A, public B &#123;&#125;;class J : virtual public A &#123;&#125;;class K : virtual public A, virtual B &#123;&#125;;class L&#123; int i; static int ii;&#125;// sizeof(A) = 4// sizeof(B) = 1// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)// sizeof(J) = 8// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中) 3.2. union联合体的大小取决于该体中所有的成员中占用空间最大的一个成员的大小，并且同样的需要对齐： 123456789101112131415161718192021union u1&#123; double a; int b;&#125;;union u2&#123; char a[13]; int b;&#125;;union u3&#123; char a[13]; char b;&#125;;// sizeof(u1) = 8;// sizeof(u2) = 13 + 3(以int的整数倍补齐);// sizeof(u3) = 13;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"Ubuntu下GDB的使用","slug":"computer_science/Linux/gdb_in_ubuntu","date":"2019-07-27T14:00:00.000Z","updated":"2019-07-27T14:00:00.000Z","comments":true,"path":"2019/07/27/computer_science/Linux/gdb_in_ubuntu/","link":"","permalink":"http://w4ow.github.io/2019/07/27/computer_science/Linux/gdb_in_ubuntu/","excerpt":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧","text":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧 1. 使用GDB调试可执行文件123gdb a.out # 不带参数或gdb --args a.out 参数 # 带参数 2. GDB常用命令12345678910111213141516171819202122232425r [args] # 带参数从头开始执行程序b arg # 在arg处设置断点，arg可以为行数、地址b xxx if (condition) # 条件断点b test.c:30 if n==100 # 当变量n等于100的时候在test.c的30行处加断点n (next) # 单步执行，如遇函数则直接返回函数的执行结果s (step) # 单步执行，如遇函数则进入函数体执行stop # 停止执行q (quit) # 退出GDBuntil # 当不想反复执行循环时，可以用until跳出循环finish # 跳出当前函数c (continue) # 继续执行，直到下一个断点或程序结束p arg # 打印出arg的值，arg可以为变量或地址whatis variable # 打印出变量的类型ptype variable # 打印出变量的类型，只不过比whatis更详细i variables variable # 打印出定义variable的文件i source # 查看当前程序i b # 查看arg，arg可以为断点、变量值、i args # 打印出当前函数的参数值i locals # 打印出当前函数中所有局部变量值i r (r_name) # 查看所有寄存器(寄存器r_name)的值i threads # 查看线程d b # 删除断点，b为断点编号bt # 查看函数的back tracel (list) arg # 显示arg附近的前后共10行代码，arg可以为行数或函数名watch arg # 设置监控，在arg改变时停止(需要先加断点) 3. 设置断点1234# 当欲设断点在当前文件中时，可以b+行数或b+函数名b 45/main# 当欲设断点在其他文件中时，b 文件名:行数b head.cpp:45","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"http://w4ow.github.io/tags/GDB/"}]},{"title":"C++中const、define和static","slug":"computer_science/C-C++/const_define_static_in_C++","date":"2019-07-03T03:29:37.000Z","updated":"2019-07-02T16:00:00.000Z","comments":true,"path":"2019/07/03/computer_science/C-C++/const_define_static_in_C++/","link":"","permalink":"http://w4ow.github.io/2019/07/03/computer_science/C-C++/const_define_static_in_C++/","excerpt":"关键字const、define和static相关知识点整理","text":"关键字const、define和static相关知识点整理 1. const和define区别 宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查; const常量存在于程序的数据段，并在堆栈分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查; 2. C++中关键字const的作用 定义常量; 修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const: 12void fun(A a);void fun(A const &amp;a); 修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量: 123const char *GetChar()&#123;&#125;;char *ch = GetChar(); // errorconst char *ch = GetChar() //correct const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下: 1int GeoCount() const; 3. 静态变量static1. static的作用 一个static变量可以维持其值在被调用的过程中不变； 在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问； 模块内的一个static修饰的函数只可以被该模块内的函数调用。 2. static变量和普通变量的区别1. static全局变量和普通全局变量 static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值； static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用； （相同点）两种都以静态存储方式存储； 2. static局部变量和普通局部变量 static局部变量只被初始化一次，下一次使用依据上一次的结果 3. static函数和普通函数 static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品； static函数作用域仅在本文件中，普通函数可在其他文件被调用；","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://w4ow.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://w4ow.github.io/tags/C/"}]},{"title":"Introduction to Array","slug":"computer_science/Data-Structure/array","date":"2019-06-28T16:04:37.000Z","updated":"2019-06-28T16:00:00.000Z","comments":true,"path":"2019/06/29/computer_science/Data-Structure/array/","link":"","permalink":"http://w4ow.github.io/2019/06/29/computer_science/Data-Structure/array/","excerpt":"学习数组时的一个简单的笔记","text":"学习数组时的一个简单的笔记 数组及其初始化对于一个只声明未赋值的int型数组，如果该数组为全局变量，该数组会被初始化为0，若为局部变量，则被初始化为乱值； 矩阵的压缩存储稀疏矩阵：对于一个稀疏矩阵(即矩阵中的大部分元素为0)，可以使用三元组表示法对其压缩。在一个三元组中，每一个一个条目都形如(行号, 列号, 值)，稀疏矩阵中的每一个非零值由三元组表中的条目唯一表示。稀疏矩阵经过三元组压缩存储后，会失去随机存取能力； 特殊矩阵：特殊矩阵形如上三角矩阵、对角矩阵、对称矩阵等，特殊矩阵的压缩存储并不会丧失随机存取的能力。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://w4ow.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://w4ow.github.io/tags/Array/"}]},{"title":"MacOS/Ubuntu 18.10 安装PyTorch","slug":"computer_science/Linux/PyTorch_for_Linux","date":"2019-03-29T16:00:00.000Z","updated":"2018-03-29T16:00:00.000Z","comments":true,"path":"2019/03/30/computer_science/Linux/PyTorch_for_Linux/","link":"","permalink":"http://w4ow.github.io/2019/03/30/computer_science/Linux/PyTorch_for_Linux/","excerpt":"MacOS/Ubuntu 18.10 安装PyTorch","text":"MacOS/Ubuntu 18.10 安装PyTorch 1. MacOS/Ubuntu 18.10 安装Conda管理环境MacOS下前往Anaconda官网下载安装即可Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加export PATH=”/home/user_name/anaconda3/bin:$PATH”并source一下即可 2. MacOS/Ubuntu 18中安装PyTorch (可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch 123conda create -n environment_name python=X.X (2.7/3.6) # 创建虚拟环境conda info --env # 显示所有的conda虚拟环境conda activate environment_name # 激活虚拟环境 修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源 12345678# for Anacondaconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# for PyTrochconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes 安装PyTorch 12conda install pytorch torchvisionconda deactivate # 使用结束后退出虚拟环境 3. 虚拟环境中安装jupyter如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter 1python3 -m pip install jupyter","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://w4ow.github.io/tags/PyTorch/"},{"name":"MacOS","slug":"MacOS","permalink":"http://w4ow.github.io/tags/MacOS/"}]},{"title":"Introduction to Queue","slug":"computer_science/Data-Structure/Queue","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-03T16:00:00.000Z","comments":true,"path":"2019/03/04/computer_science/Data-Structure/Queue/","link":"","permalink":"http://w4ow.github.io/2019/03/04/computer_science/Data-Structure/Queue/","excerpt":"A note to queue","text":"A note to queue 1. 循环队列 计算大小为n的循环队列中元素的个数 $(rear - front + n) % n$ $(rear - front + n + 1) % n$ 循环队列判空 $front = rear$ 循环队列判满 $(rear + 1) % n = front $ 出队后头指针front的值 $ front = (front + 1) % m $","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://w4ow.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://w4ow.github.io/tags/Data-Structure/"},{"name":"Queue","slug":"Queue","permalink":"http://w4ow.github.io/tags/Queue/"}]},{"title":"Ubuntu 18.10安装LLVM","slug":"computer_science/Linux/LLVM_for_Ubuntu","date":"2018-12-29T16:00:00.000Z","updated":"2018-12-29T16:00:00.000Z","comments":true,"path":"2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","link":"","permalink":"http://w4ow.github.io/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","excerpt":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本","text":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本 1.安装cmake安装LLVM需要使用cmake，可以使用如下命令安装: 1sudo apt install cmake 2.修改swap分区(可选，不推荐)从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下： 查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间: 123sudo swapon --showorfree -h 检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值 1df -h 在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。 123sudo swapoff -a # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，sudo fallocate -l 20G /swapfile # 创建swapfilels -lh /swapfile # 验证是否成功创建swapfile， 如果显示-rw——1 root root 20G 日期 /swapfile 则表示创建成功 启用交换文件 12sudo chmod 600 /swapfile # 锁定swapfile权限sudo mkswap /swapfile # 将文件标记为交换空间 若显示:Setting up swapspace…… 则表示成功标记swapfile，标记之后启用该文件 12sudo swapon /swapfile # 启用free -h # 验证 永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留 12sudo cp /etc/fstab /etc/fstab.bak # 备份echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab # 将swap文件信息添加到/etc/fstab文件 3.安装LLVM-8.0 Debug版本 首先去LLVM官网下载必要的软件包; 获取源码: 1234567891011121314151617181920212223# 在适当位置放置LLVM源码，此处放在home下cd ~mkdir tmp# 解压LLVM源码cd tmptar -Jxvg llvm-7.0.0.src.tar.xzmv llvm-7.0.0.src llvm# 解压clang源码(此时在tmp目录下)cd llvm/toolstar -Jxvg cfe-7.0.0.src.tar.xzmv cfe-7.0.0.src clang# 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)cd clang/toolstar -Jxvg clang-tools-extra-7.0.0.src.tar.xzmv clang-tools-extra-7.0.0.src extra# 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)cd ~/tmp/llvm/projectstar -Jxvg compiler-rt-7.0.0.src.tar.xzmv compiler-rt-7.0.0.src compiler-rt 开始安装 123456789101112# 在tmp目录下新建build文件夹cd buildcmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Debug ../llvmmake -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半sudo make install# 将路径添加到环境变量中cd ~vim .bashrcexport PATH=/usr/lib/llvm-7/binexport LD_LIBRARY_PATH=/usr/lib/llvm-7/libsource .bashrc 重启终端并测试 123clang -vclang++ -vclang test.c","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"LLVM","slug":"LLVM","permalink":"http://w4ow.github.io/tags/LLVM/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu 18.10安装与配置","slug":"computer_science/Linux/install_ubuntu","date":"2017-06-03T16:00:00.000Z","updated":"2017-06-03T16:00:00.000Z","comments":true,"path":"2017/06/04/computer_science/Linux/install_ubuntu/","link":"","permalink":"http://w4ow.github.io/2017/06/04/computer_science/Linux/install_ubuntu/","excerpt":"Ubuntu 18.10安装与配置","text":"Ubuntu 18.10安装与配置 1. 安装Ubuntu 18.10安装过程不多说，安装镜像可以去中科大镜像下载。 2. 安装搜狗输入法 前往搜狗输入法官网下载deb安装文件，双击安装； 前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt； 当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法； 重启系统。 3. 修改软件源应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn 4. 安装Chrome前往Chrome官网下载.deb安装包，双击安装即可。 5. 开启夜览模式夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整： 打开Terminal安装dconf-editor 1sudo apt install dconf-editor 在终端打开dconf-editor 1dconf-editor dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature 关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适 6. 系统美化安装Tweaks工具用以配置桌面 12sudo apt updatesudo apt install gnome-tweak-tool 在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有： Weather In The Clock，点击屏幕上方的时间可以展示天气; Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏； 7. 配置终端 安装zsh与git 12sudo apt install zsh sudo apt install git 安装oh-my-zsh 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 将Shell切换到zsh，登出并重新登入 1chsh -s /bin/zsh 在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题 1ZSH_THEME=\"ys\" 安装一些强大的zsh插件首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令： 1source ~/.oh-my-zsh/plugins/incr/incr*.zsh 同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://w4ow.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://w4ow.github.io/tags/Ubuntu/"}]},{"title":"Introduction To Data Structure","slug":"computer_science/Data-Structure/introduction","date":"2016-09-22T16:00:00.000Z","updated":"2014-09-22T16:00:00.000Z","comments":true,"path":"2016/09/23/computer_science/Data-Structure/introduction/","link":"","permalink":"http://w4ow.github.io/2016/09/23/computer_science/Data-Structure/introduction/","excerpt":"对常见数据结构的一个简单地总结","text":"对常见数据结构的一个简单地总结 1. 数据结构定义数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成，记为： $Data Structure = (D, R)$ 其中$D$是数据元素的集合，$R$是$D$中元素之间的关系的集合。 通俗的理解，数据结构=逻辑结构(线性、非线性) + 存储结构(顺序、链式、索引、散列) 逻辑结构：数据元素间抽象化的相互关系 存储结构：数据在计算机中的存储形式，也是物理结构 2. 逻辑结构数据的逻辑结构是指数据之间的逻辑关系，比如一对一、一对多、多对一、多对多等。通常，逻辑关系可以分为两种：线性关系和非线性关系。线性关系指：除第一个外，每个元素有且只有一个前驱；除最后一个元素外，每个元素有且只有一个后继。 常见的逻辑结构有以下几种： 集合：数据元素间没有任何关系 线性结构：数据元素间存在线性关系 树：数据元素间有层次关系 图：数据元素间you网状关系 常见的线性结构：线性表、栈、队列、双队列、数组、串等常见的非线性结构：多维数组、树、图、广义表等 3. 存储结构数据的存储结构是指数据在计算机中的存储形式，也是数据的物理结构。 常见的存储结构有以下几种： 顺序存储：逻辑上相邻的节点存储在物理位置上相邻的存储单元中，节点之间的逻辑关系由存储单元的邻接关系体现 优点：可实现对节点的随机存取 缺点：不便于插入、删除，因为要大量移动数据 链式存储：逻辑上相邻的节点在物理存储上不相邻，而是通过指针等体现逻辑关系 优点：便于插入、删除，存储密度比顺序存储小 缺点：不便于查找 索引存储：通过建立索引表来标识节点的地址 散列存储：根据节点的关键字直接计算出节点的存储地址","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://w4ow.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://w4ow.github.io/tags/Data-Structure/"}]},{"title":"TCP中的拥塞控制简介","slug":"computer_science/Computer-Network/congestion_control","date":"2015-05-27T13:12:00.000Z","updated":"2015-05-27T13:12:00.000Z","comments":true,"path":"2015/05/27/computer_science/Computer-Network/congestion_control/","link":"","permalink":"http://w4ow.github.io/2015/05/27/computer_science/Computer-Network/congestion_control/","excerpt":"TCP中的拥塞控制的目的是控制网络拥塞的出现，网络拥塞的原因多种多样，比如某结点的缓存太小、某段链路带宽太低等等。为了防止网络拥塞，V.Jacobson在1988年的论文中提出了用于TCP的拥塞控制，由慢开始和拥塞避免组成，后来在TCP Reno版本中又加入了快重传和快恢复。这4种技术能够很好的避免网络拥塞。","text":"TCP中的拥塞控制的目的是控制网络拥塞的出现，网络拥塞的原因多种多样，比如某结点的缓存太小、某段链路带宽太低等等。为了防止网络拥塞，V.Jacobson在1988年的论文中提出了用于TCP的拥塞控制，由慢开始和拥塞避免组成，后来在TCP Reno版本中又加入了快重传和快恢复。这4种技术能够很好的避免网络拥塞。 1. 慢开始如果将网络通路比作高速公路，那么我们可以想象一下，如果这条路的出口只有一个车道，而入口却有很多车道，那么这条路必然会造成拥塞。慢开始就是针对这一情况而提出的。其基本思想是逐渐增大发送的数据大小(即拥塞窗口)直到指定的阈值(即慢开始阈值)。 在慢开始中，发送端除了要维护正常情况下根据接收端发来的窗口大小字段值而调整的发送窗口外，还要维护一个拥塞窗口(Congestion Window, CWND)，CWND的目的是为了避免发生拥塞，最终允许发送的字节数是CWND和发送窗口两者中的最小值。 下面介绍慢开始的具体步骤(假设CWND总是小于发送窗口)： 在TCP传输连接建立时，发送端将CWND初始化为该连接上当前使用的最大数据段大小(Maximum Segment Size, MSS)，即CWND=MSS，然后发送端发送一个MSS大小的数据段M1。 如果在定时器过期前发送端收到了该数据段的确认(即对M1的确认)，则发送端将CWND大小翻倍，即CWND=2MSS，并发送2MSS大小的数据，假定发送的数据段位M2、M3。 同样的，如果在定时器过期前发送端接收到确定(收到M3的确认即可，即只用确认最后一个)，再次将CWND翻倍，并以此类推。 当出现数据丢失时，需要将慢开始阈值(Slow Start Threshold, SSTHRESH)设置为当前CWND的一半，并将CWND重设为1MSS。并重新开始慢开始，此时若CWND再次达到SSTHRESH便停止使用慢开始，转用拥塞避免。 值得注意的是，一般SSTHRESH初始值为64KB。 2. 拥塞避免拥塞避免的基本思想是，当CWND再次达到SSTHRESH时，让拥塞窗口的大小每经过一个RTT(数据传输往返时间)时仅增加1MSS。如果这时还是发生了数据丢失，同样的还是把SSTHRESH设为当前CWND的一半，把CWND设为1MSS，并重新开始慢开始。 3. 快重传/快恢复快重传的基本思想是，当接收端收到一个不是按序到达的数据段时，TCP实体迅速发送一个重复ACK数据段，而不用等到有数据需要发送时才顺带发出重复ACK。在连续收到3个重复ACK数据段后，即认为对应确认号字段的数据丢失，TCP不等重传定时器超时就会重传丢失的数据段。 快恢复是在快重传发挥作用时，确切的说是收到第三个重复ACK时，把当前CWND设为当前SSTHRESH的一半，以减轻网络负载，然后执行拥塞避免算法。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://w4ow.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://w4ow.github.io/tags/Network/"}]},{"title":"常见路由算法","slug":"computer_science/Computer-Network/routing_algorithm","date":"2015-04-14T06:12:00.000Z","updated":"2015-04-14T06:12:00.000Z","comments":true,"path":"2015/04/14/computer_science/Computer-Network/routing_algorithm/","link":"","permalink":"http://w4ow.github.io/2015/04/14/computer_science/Computer-Network/routing_algorithm/","excerpt":"路由算法是指从源节点和目的节点之间选择一条最佳的路径用于传输数据。为了完成这个任务，在路由器中通常会收集和保存各种与传输路径相关的数据，如拓扑结构、端口度量、端口速率等，然后根据相应的路由算法生成路由表，在数据发送时提供路由选择。 一般而言，路由算法分为自适应路由算法和非自适应路由算法。","text":"路由算法是指从源节点和目的节点之间选择一条最佳的路径用于传输数据。为了完成这个任务，在路由器中通常会收集和保存各种与传输路径相关的数据，如拓扑结构、端口度量、端口速率等，然后根据相应的路由算法生成路由表，在数据发送时提供路由选择。 一般而言，路由算法分为自适应路由算法和非自适应路由算法。 1. 非自适应路由算法非自适应路由算法是指不能根据网络流量和拓扑结构的变化动态更新路由表的算法，这类算法使用静态路由表。 1.1 静态路由静态路由是指由管理员手动在路由表中一条条添加路由选项，这种方法费时费力，都不能称之为算法。不过RapidIO中采用了这种方法，RapidIO是嵌入式通信网络之一，其路由表建立的方式之一就是将路由表烧进芯片里。 1.2 扩散法扩散法是指当一个路由收到报文分组后，向它所有的端口复制扩散该报文。因为有多条路径，所以即使网络局部瘫痪也不影响通信，但是大量重复加重了网络负担，因此这种算法适合规模较小、通信负载轻、可靠性要求极高的通信场合，如军用通信。 1.3 随机走动法该方法指挡路有收到报文分组后，随机选择一个端口将其发送出去。这种方法通信效率低、实用价值低。 1.4 最短路径法该算法是指利用Dijkstra算法构建一个节点之间的最短路径，即跳数最少的路径，作为路由表。每次收到报文后查询路由表进行转发。 1.5 基于流量的路由算法最短路径算法只考虑网络拓扑结构，而基于流量的算法还会考虑网络流量及负载。 2. 自适应路由算法自适应路由算法是指能根据网络流量和拓扑情况而动更新路由表的算法。该类算法一般分为两类，一类是路由中只保留相邻器的路由信息的分散式路由算法，另一类是保留网络(或部分网络)中所有路由器的全部信息的总体式路由算法。 2.1 距离矢量路由算法距离矢量路由算法(Distance Vector, DV)是分散式路由算法的一种，而DV是指源节点和目的节点之间所经过的路由器的数目减一(需要减去源节点直连路由器)，该距离也称为跳数。采用DV的经典路由协议有RIP、内部网关协议IGRP、增强型内部网关协议EIGRP和边界网关协议BGP。 2.2 链路状态路由算法该算法是总体式路由算法的一种，又被称为最短路径优先算法，它和基于流量的路由算法有点类似，只是前者会动态更新路由表，而后者不会。使用该算法的路由协议有开放最短路径优先(OSPF)、中间系统-中间系统(IS-IS)、EIGPR(同时支持距离矢量算法和链路状态算法)等。 2.3 分级路由算法前面两种自适应路由算法中，每个路由器都要保存其他路由器的一些信息，随着网络规模的增加，路由表的规模也会增大，从而使路由器不能有效的进行流量控制，分级路由算法可以解决这个问题。 在分级路由中，路由器被分成很多组，称之为区域。每个路由器都只有自己所在区域路由器的信息。使用该算法的有OSPF、IS-IS、BGP。 总的来说，在部分区域内，一般使用的是距离矢量路由算法和链路状态路由算法，而在全局网络中一般使用分级路由算法","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Route","slug":"Route","permalink":"http://w4ow.github.io/tags/Route/"}]},{"title":"计算机网络物理层简介","slug":"computer_science/Computer-Network/physical_layer_in_network","date":"2015-03-22T06:12:00.000Z","updated":"2015-03-22T06:12:00.000Z","comments":true,"path":"2015/03/22/computer_science/Computer-Network/physical_layer_in_network/","link":"","permalink":"http://w4ow.github.io/2015/03/22/computer_science/Computer-Network/physical_layer_in_network/","excerpt":"物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议","text":"物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议 1. 物理层的主要作用物理层有如下几个作用 构建数据通路：即两个通信端之间的可以连续传输数据的物理通路 透明传输：作为物理通路的材质可能有很多，例如双绞线、光纤等，物理层需要确保数据对这些材质透明，即不管什么材质都不影响数据传输 传输数据：既然是通路其基本功能就是传输数据。物理层的基本传输单元是bit 数据编码：不同传输介质所支持的数据编码可能不同，如归零码、曼彻斯特码、差分曼彻斯特码等。物理层需要确保不同编码的数据能够正常在通路上传输 数据传输管理：对比特流的数据传输流量控制、差错控制、物理线路的激活与释放等 2. 物理层特性物理层需要规范其接口的特性，有了统一的标准，不同的厂商能够以相同的标准来实现彼此产品的互联 机械特性：定义了传输介质接线器、物理接口的形状和尺寸、引线数目和排列顺序以及连接器与接口之间的固定和锁定装置 电气特性：规定了在通路上传输比特流时线路上信号电压的高低、阻抗匹配情况，以及传输速率和传输距离限制等参数属性，主要分为三类： 非平衡型 差分接收器的非平衡型 平衡型 功能特性：指传输介质中各条线上所出现的某一电平的含义，以及物理接口各条信号线的用途，包括：接口信号线的功能规定，接口信号线的功能分类。 规程特性：利用接口传输比特流的全过程以及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时，DTE/DEC双方在各自电路上的动作顺序。 3. 物理层传输介质 导向性传输介质 双绞线 同轴电缆 光纤 非导向性传输介质 短波无线传输 地面微波接力通信 卫星通信","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://w4ow.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://w4ow.github.io/tags/Network/"}]},{"title":"计算机网络的拓扑结构","slug":"computer_science/Computer-Network/topology_of_network","date":"2015-03-22T06:12:00.000Z","updated":"2015-03-22T06:12:00.000Z","comments":true,"path":"2015/03/22/computer_science/Computer-Network/topology_of_network/","link":"","permalink":"http://w4ow.github.io/2015/03/22/computer_science/Computer-Network/topology_of_network/","excerpt":"计算机网络拓扑结构是指网络中各个端点之间的逻辑结构，本文对其进行简单介绍","text":"计算机网络拓扑结构是指网络中各个端点之间的逻辑结构，本文对其进行简单介绍 1. 网络拓扑中的基本概念 节点：即一个网络端口，如PC； 结点：通常连接了多个节点，如路由器和交换机； 链路：两个节点之间的线路； 通路：两个节点之间的通信线路，可能包含多条链路。 2. 星型拓扑结构目前应用最广的一种拓扑结构，各节点以交换机或集线器等设备连接在一起，其优点包括扩展方便、网速较快、易于维护，但缺点也很明显：核心交换机负载过重、通信过于依赖核心交换机等。 3. 环形拓扑结构这种网络因为传输速率低、扩展性差，已经被淘汰不用了，使用这种结构的有令牌环网。 4. 总线型拓扑结构该结构中，所有设备都连接到一条总线上，和环形拓扑不同的是不形成闭环。总线型拓扑结构会在总线两端加装“终接器”的设备，主要用于与总线进行阻抗匹配，最大限度吸收传送端部的能量，避免信号反射回总线产生不必要的干扰。其优点有：结构简单、易于扩展、易于维护，缺点有：传输速率低、故障诊断苦难、难以实现大规模扩展； 4. 树形拓扑结构树根为核心交换机，叶节点为终端设备 5. 网状拓扑结构网络可靠性高、布线复杂 6. 混合型拓扑结构应用广泛、维护困难 7. WLAN的拓扑结构 Ad-Hoc：点对点连接方式，只能单点通信，性能较差； Infrastructure：和星型拓扑类似。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://w4ow.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://w4ow.github.io/tags/Network/"}]},{"title":"死锁问题","slug":"computer_science/Operating-System/deadlock","date":"2015-03-16T06:12:00.000Z","updated":"2015-03-16T06:12:00.000Z","comments":true,"path":"2015/03/16/computer_science/Operating-System/deadlock/","link":"","permalink":"http://w4ow.github.io/2015/03/16/computer_science/Operating-System/deadlock/","excerpt":"关于死锁的一些归纳和总结","text":"关于死锁的一些归纳和总结 1. 死锁产生的原因和必要条件进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。 可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。 不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。 因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点： 系统资源不足。这是根本原因，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时； 进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。 对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4： 互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用； 请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源； 不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占； 循环等待。若干个进程形成循环等待链。 2. 死锁的预防通过破坏死锁的必要条件来控制死锁的策略称为死锁预防，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。 破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的优点是安全简单易实现，缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源。 破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”。 破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高。 3. 死锁的避免与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的前提是每个进程清除自己需要多少资源，因此死锁避免还是有局限性的。 系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全； 银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。 4. 银行家算法银行家算法有5种数据结构： 系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲； 最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k； 分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数； 需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源； 请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。 当某个进程i对j类资源提出k个请求是，需要按照下列步骤检查： 若$Request[j]&lt;=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错； 若$Request[j]&lt;=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i； 系统进行试探性分配，并修改相应的表： Available[j] -= Request[j]; Allocation[i][j] += Request[j]; Need[i][j] -= Request[j]; 调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。 判断当前状态是否安全 添加两个数组： Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa； Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。 检查当前状态的完整过程如下： 初始化Work和Finish。Work[j]=Available[j], Finish[i]=false; 在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4: Finish[h] = false; Need[h][j] &lt;= Work[j] 由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2 若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。 5. 死锁检测6. 死锁解除","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Deadlock","slug":"Deadlock","permalink":"http://w4ow.github.io/tags/Deadlock/"}]},{"title":"计算机网络的分类","slug":"computer_science/Computer-Network/classify_in_network","date":"2015-03-15T06:12:00.000Z","updated":"2015-03-15T06:12:00.000Z","comments":true,"path":"2015/03/15/computer_science/Computer-Network/classify_in_network/","link":"","permalink":"http://w4ow.github.io/2015/03/15/computer_science/Computer-Network/classify_in_network/","excerpt":"计算机网络分类","text":"计算机网络分类 1. 按覆盖范围分 局域网LAN：LAN是将一个较小的区域内的各种通信设备连接在一起组成的网络，最常见、最常应用的网络。LAN具有以下特点： 私有服务：LAN用于私用，例如校园网和企业网 分布范围小 结构简单、布线容易 网速较快，误码率低 城域网MAN：通常用于为一个城市范围提供服务 广域网WAN：分布范围最大，可以遍布一个国家甚至全球，特点有： 覆盖范围广 构建成本高 网络结构和类型复杂：可以连接多种不同的网络类型 传输速率低，误码率高 2. 按网络管理模式分 对等网：即网络中的各成员地位相等。这种网络配置简单，适合家庭、校园和小型办公室用户，但其缺点也很明显，例如管理困难、安全性差、成本高、性能差等； C/S网：客户/服务器网，其特点是易于管理、安全性高、性能好。 3. 按传输方式分 点对点传输网络：该网络中数据是以点对点的方式传输的，因此这类网络采用基于点对点的通信协议，如点对点协议PPP、基于以太网的点对点协议PPPOE等。 广播式传输网络：该网络中任一节点都可以通过公用信道传输数据到其他节点上，其他节点通过匹配数据地址来判断是否接收。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://w4ow.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://w4ow.github.io/tags/Network/"}]},{"title":"进程、线程与协程之间的区别与联系","slug":"computer_science/Operating-System/process-and-thread-coroutines","date":"2015-03-12T06:12:00.000Z","updated":"2015-03-12T06:12:00.000Z","comments":true,"path":"2015/03/12/computer_science/Operating-System/process-and-thread-coroutines/","link":"","permalink":"http://w4ow.github.io/2015/03/12/computer_science/Operating-System/process-and-thread-coroutines/","excerpt":"进程、线程与协程之间的区别与联系","text":"进程、线程与协程之间的区别与联系 1. 进程进程是程序的动态执行。保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。一块CPU在某一时刻只能运行一个进程，多进程是通过进程调度抢占CPU来实现的。 进程间的通信方式 无名管道(Pipe)、有名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存(Shared Memory)、套接字(Socket)。 2. 线程线程也被称为轻量级进程(Lightweight Process，LWP)，是操作系统调度(CPU调度)执行的最小单位。 2.1 线程与进程的区别与联系联系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 资源分配给进程，同一进程的所有线程共享该进程的所有资源； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属进程的资源。进程维护的是程序所包含的资源(静态资源)，如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等；线程所维护的运行相关的资源(动态资源)，如：运行栈、调度相关的控制信息、待处理的信号集等； 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致创建进程的系统开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 3. 协程协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总有一个入口，一次返回，并且调用顺序是明确的。而协程的调用和子程序不同，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。 协程的优点 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显； 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://w4ow.github.io/tags/Process/"}]},{"title":"进程间的通信方式","slug":"computer_science/Operating-System/communication-of-process","date":"2015-03-09T06:12:00.000Z","updated":"2015-03-09T06:12:00.000Z","comments":true,"path":"2015/03/09/computer_science/Operating-System/communication-of-process/","link":"","permalink":"http://w4ow.github.io/2015/03/09/computer_science/Operating-System/communication-of-process/","excerpt":"同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。","text":"同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。 1. 进程通信的概念进程的特征之一是其具有独立性，一个进程不能访问另一个进程的程序或者数据，以保证进程之间不会相互干扰，但这样也造成了进程间无法直接交换数据。 一般而言，进程通过两种方案来实现进程间的通信 发送、接受双方通过磁盘等外设交换数据。这种通信方式需要I/O操作的支持。 利用内核运行在内核态的特点，通过对内核空间读写来交换数据。这种通信方式是在内存中完成的。 根据进程通信交换信息量的大小，可以将进程通信分为两种： 低级通信。进程之间一次只传输少量数据，速度快，效率低，通信过程对用户不透明。这类通信主要用于互斥与同步的工具，P、V原语是低级通信原语 高级通信。一次可以传输大量信息，效率高，对用户透明，编程简单。高级通信又分为三种： 共享内存通信方式：利用共享内存通信； 消息传递通信方式：利用OS提供的消息系统通信； 共享文件通信方式：又被称为管道通信。 高级通信方式既适用于集中式操作系统，又适用于分布式操作系统。 2. 共享内存通信方式共享内存是指在内存中划出一块区域作为数据共享区，称为共享内存分区，通信双方将自己的虚拟地址空间映射到共享内存分区上。通信时通过对该分区读写实现通信。该方式是进程间最快捷、最有效的通信方式，Unix、Windows和OSX都采用了这种通信方式。 3. 消息缓冲(消息队列)通信方式消息缓冲属于直接通信方式，该方法中，发送进程直接发送原语到接收进程的消息队列，而接受进程使用接受原语从消息队列中取出信息，进程间以消息为单位进行信息交换。该方法与生产者-消费者问题类似。该方式与共享内存有点相似，该方法使用内存中的公用消息缓冲区来传递消息。 4. 信箱通信方式该方式是间接通信方式，通信双方通过一种叫信箱的共享数据结构来进行交互。该方法和消息队列没什么区别，也是在内存中设置一种特殊的数据结构。 5. 管道通信方式所谓的管道就是一种共享通信文件，也称为pipe文件，专门用于进程间通信。管道有三个特点： 管道专门用于特性 管道只能单向传送数据 管道对用户透明 管道分为两种： 无名管道。无名管道是利用系统调用pipe建立起来的无路径名的无名文件，并且是一个临时文件，该文件物理上由文件系统的高速缓冲区构成，且很少启动外部设备。当进程不再需要无名管道时，系统关闭并回收与它相关联的索引节点。此外，通过文件系统看不到无名管道的存在。 有名管道。有名管道是一个有目录和索引的长期存在的真实文件，不能与文件系统中的任何文件重名，且在文件系统中能看到该有名管道。 6. 信号量7. 套接字","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://w4ow.github.io/tags/Process/"}]},{"title":"进程的基本概念","slug":"computer_science/Operating-System/process","date":"2015-03-07T06:12:00.000Z","updated":"2015-03-07T06:12:00.000Z","comments":true,"path":"2015/03/07/computer_science/Operating-System/process/","link":"","permalink":"http://w4ow.github.io/2015/03/07/computer_science/Operating-System/process/","excerpt":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。","text":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。 1. 进程的概念1.1 程序的顺序执行在计算机中常使用程序这个概念，程序是一个在时间上严格按先后次序操作实现算法功能的指令序列，程序本身是静态的，是指令编译出的结果。在单道程序设计环境中，程序总是顺序执行的，若有多个程序，则各个程序试一次呗调入内存的。程序的顺行执行有以下三个特点： 顺序性。CPU严格按照程序规定的顺序(即指令顺序)执行程序的操作，每个操作都必须在前一个操作结束后才能执行； 封闭性。程序一旦开始执行，其结果仅由初始条件和程序本身操作决定，不受外界因素影响； 可再现性。当初始条件相同，程序的运行结果也相同。 单道程序的顺序性、封闭性和可再现性给程序的编制、调试带来了便利，但是资源利用率底。 1.2 程序的并发执行1.3 进程1.3.1. 进程的定义单道程序环境下，程序与CPU执行的活动是一致的。多道环境下，并发破坏了程序的封闭性和可再现性，程序与CPU执行的活动不再一一对应。程序是完成某一特定功能的指令序列，是一个静态过程，而CPU执行的活动是一个动态的过程。因此20世纪60年代Dijkstra引入了进程的概念。他给出的进程定义是：行为的规则称为程序，程序在CPU上执行时的活动称为进程。 1.3.2. 进程的结构通常程序是不能并发执行的，为了使程序及它所要使用的资源能独立运行，OS为程序配置了一个特殊的数据结构进程控制块PCB(Process Control Block)，PCB用来存储程序向前执行过程中所要记录的有关运行信息，即该进程动态之行的相关资料。因此： 进程实体 = 程序段 + 相关数据段 + PCB 1.3.3. 进程的特征进程作为OS的一个实体有以下5个特征。 动态性。进程是程序的一次执行，因此进程是动态的，具有生命期。 并发性。多个进程实体在一段时间内能够并发执行，从而提高系统资源利用率。 独立性。每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位。 异步性。各进程按各自独立的、不可预知的速度向前推进。对单CPU系统而言，任何时刻只能有一个进程占用CPU。 结构性。每个进程的结构都由程序段、数据段和PCB组成。 1.3.4. 进程和程序的区别 程序是指令的有序集合，是静态的；Process是程序在CPU上的一次执行，是动态的； 程序作为软件可以长期保存；Process有自己的生命周期； 程序不会占有和调度资源；Process会为其分配和调度资源； 进程与程序之间无一一对应关系，一个程序可以多次执行产生多个进程，不同进程也可以包含同一个程序； 程序是记录在存储介质上的指令有序集合；进程则由程序段、数据段、PCB组成。 2. 进程的状态及转换2.1. 5状态进程模型进程有5个状态：创建、就绪、运行、阻塞、终止，下面对其一一说明。 进程的创建。通常有4件事会导致新进程的产生： 在一个批处理环境中，为了响应一个任务的要求而产生进程； 在一个交互式环境中，当一个新用户企图登录时会产生进程； 操作系统代替用户程序产生进程； 由用户程序产生进程。通常进程都是由操作系统产生的，但是一个进程也可以产生另一个进程，分别称为父进程和子进程。 进程的终止。当一个进程执行到自然结束点，或因不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程进入终止态。处于终止态的进程不能被再次调度执行，与其相关的数据信息由OS临时保存，随后OS逐步释放为其分配的资源，最后释放PCB。 进程的就绪。进程获得了除CPU之外的所需资源，一旦得到CPU就可运行。就绪状态的进程会组成就绪队列。 进程的运行。进程获得了CPU和其他资源，正在CPU上运行时的状态。 进程的阻塞。进程运行中发生了某种等待事件(如I/O操作)而暂时不能运行的状态，此状态的进程不能竞争CPU，而需要等事件完成后转到就绪态才能竞争。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://w4ow.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://w4ow.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://w4ow.github.io/tags/Process/"}]}]}