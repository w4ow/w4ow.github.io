---
title: 形式语言与计算复杂性(四)：可判定性
date: 2021-07-04 16:00
# updated: 0000-00-00 00:00
mathjax: true
meta:
    date: true
categories: 
    - Mathematics
tags:
    - Lecture
---

{% post_link Mathematics/形式语言1 Lecture 0：绪论 %}<br>
{% post_link Mathematics/形式语言2 Lecture 1：正则语言 %}<br>
{% post_link Mathematics/形式语言3 Lecture 2：上下文无关语言 %}<br>
{% post_link Mathematics/形式语言4 Lecture Church-Turing %}
Lecture 4: 可判定性

---

<!-- more -->

# 1. 可判定性

我们研究问题的可判定性，其目的是在拿到一个问题时，先看看它是否能被图灵机解决，对于无法解决的问题，我们也就没有必要花费精力去研究了。如何研究问题的可判定性呢？首先从语言的可判定性入手，如果一个语言是不可判定的，那么以该语言描述的问题肯定是不可判定的。首先，最基本的，正则语言RL和上下文无关语言CFL都是可判定的，然后我们再介绍几种可判定语言。

## 1.1 正则语言的可判定性

1. 语言$A_{DFA}=\lbrace\langle B,w\rangle|B\mathrm{\ is\ a\ DFA\ that\ accepts\ input\ string}\ w\rbrace$是可判定的。
   **证明：**
   首先弄清楚我们要证明的是什么，$B$是一个DFA，本质上就是一个五元组，$w$是任意的字符串。然后我们给定一个图灵机$M$，其输入是一个二元组$\langle B,w\rangle$，$M$要判定这个$w$能否被这个$B$所识别，如果能识别，则$M$返回$accpet$，否则$reject$。
   搞清楚了这个，我们就可以构造一个$M$来判定$A_{DFA}$
   > $M$ = "给定输入$\langle B,w\rangle$，其中$B$是DFA，$w$是字符串：
   > 1. 首先$M$检查$B$和$w$是否是合法的，不是合法的则直接返回$reject$
   > 2. 使用$M$来模拟$B$，且输入是$w$
   >    1. 开始时$B$的状态是$q_0$，且当前输入位置为$w$的最左边
   >    2. 根据$B$的状态转移函数$\delta$更新$M$的状态和输入位置
   > 3. 如果模拟完成后，$M$处于$B$的接受状态，则$M$返回$accept$，否则$reject$"

2. 语言$A_{NFA}=\lbrace\langle B,w\rangle|B\mathrm{\ is\ a\ NFA\ that\ accepts\ input\ string}\ w\rbrace$是可判定的。
   **证明：**
   因为任意NFA都有一个等价的DFA，而我们在上面已经证明了图灵机$M$可以判定$A_{DFA}$，因此我们利用$M$进行证明：
   > $N$= "给定输入$\langle B,w\rangle$，其中$B$是NFA，$w$是字符串：
   > 1. 首先将NFA $B$转换为等价的DFA $C$
   > 2. 使用上面的图灵机$M$来模拟$C$，输入信号为$w$
   > 3. 如果模拟结束时，$N$处在接受状态，则$accpet$，否则$reject$"

3. 语言$A_{REX}=\lbrace\langle R,w\rangle|B\mathrm{\ is\ a\ regular\ expression\ that\ generate\ string}\ w\rbrace$是可判定的。
   **证明：**
   同样的，任意正则表达式都可转换为NFA：
   > $P$= "给定输入$\langle R,w\rangle$，其中$R$是正则表达式，$w$是字符串：
   > 1. 首先将$R$转换为等价的NFA $A$
   > 2. 使用上面的图灵机$N$来模拟$A$，输入信号为$w$
   > 3. 如果模拟结束时，$P$处在接受状态，则$accpet$，否则$reject$"

4. 语言$E_{DFA}=\lbrace\langle A\rangle|A\mathrm{\ is\ a\ DFA\ and}\ L(A)=\emptyset\rbrace$是可判定的(即一个不能识别任何字符串的DFA $A$)
   **证明**
   > $T$ = "给定输入$\langle A\rangle$，其中$A$是一个DFA：
   > 1. 首先标记$A$的开始状态
   > 2. 利用图灵机$T$反复标记那些**由已标记状态能够到达的状态**
   > 3. 如果没有任何一个$A$的接受状态被标记，则$T$返回$accept$，否则$reject$"

5. 语言$EQ_{DFA}=\lbrace\langle A,B\rangle|A\ \mathrm{and}\ B\mathrm{\ are\ DFAs\ and}\ L(A)=L(B)\rbrace$是可判定的
   **证明**
   直接证明有一定的难度，因此我们需要对其进行转换，因为上面已经证明了$E_{DFA}$是可以判定的，因此我们可以尝试将问题转换为$E_{DFA}$，即构造某种语言且该语言的自动机不能识别任何字符串。
   > $F$ = "给定输入$\langle A,B\rangle$，其中$A$和$B$是DFA
   > 1. 我们构造一个新的DFA $C$，使得$L(C)=(L(A)\cap\overline{L(B)})\cup(\overline{L(A)}\cap L(B))$，因为FA具有封闭性，因此$C$依然是一个DFA
   > 2. 利用图灵机$T$模拟$C$
   > 3. 如果$T$返回$accept$，则$F$返回$accept$，否则$reject$.

## 1.2 上下文无关语言的可判定性

1. 语言$A_{CFG}=\lbrace\langle G,w\rangle|G\mathrm{\ is\ a\ CFG\ that\ generates\ string}\ w\rbrace$是可判定的。
   **证明**
   我们可以用图灵机模拟CFG，从开始变量一直推导，看看能否产生$w$，但是因为推导过程中可能产生循环，因此推导过程可能是无限的。我们必须转换思路，一种可行的办法是将CFG转换为CNF，而从一个CNF推导出一个字符串$w$只要$2n-1$步，因此不会陷入循环。说明一下，**因为CNF只有两种形式的规则，假设目标字符串$w$的长度为$n$，从开始变量$S$开始，推导出一个长度为$n$且全为变量的字符串需要$n-1$步，然后将这$n$个变量变成终结符需要$n$步，因此共计$2n-1$步。**
   > $S$ = "给定输入$\langle G,w\rangle$，其中$G$是CFG，$w$是字符串
   > 1. 将$G$转换为CNF形式
   > 2. 列出所有在$2n-1$步内能够推导出的字符串，其中$n=|w|$。如果$n=0$，那么列出所有一步能推导出的字符串。
   > 3. 如果这些字符串中存在$w$，则$S$返回$accept$，否则$reject$.

   由$A_{CFG}$的可判定性我们也可以得到定理：
   > **定理**：所有的上下文无关语言都是可判定的
   因为所有的上下文无关语言都有等价的CFG，我们可以构造上下文无关语言的CFG，并利用图灵机$S$来进行判定。

2. 语言$E_{CFG}=\lbrace\langle G\rangle|G\mathrm{\ is\ a\ CFG\ and}\ L(G)=\emptyset\rbrace$是可判定的(即一个不能生成任何字符串的CFG $G$)
   **证明**
   我们可以利用上面的图灵机$S$，枚举所有可能的字符串，并查看图灵机能否生成该字符串，如果所有的字符串都不能生成，则$accept$。但是枚举所有的字符串是不可行的，因此我们需要换个思路。
   > $R$ = "给定输入$\langle G\rangle$，其中$G$是一个CFG：
   > 1. 首先标记$G$的所有终结符
   > 2. 利用图灵机$R$利用右边规则反复标记变量：**对于$G$中的规则$A\to U_1U_2\cdots U_k$，如果$U_1,...,U_k$都被标记了，那么标记变量$A$**
   > 3. 如果开始变量没有被标记，则$R$返回$accept$，否则$reject$"

3. 语言$EQ_{CFG}=\lbrace\langle G,H\rangle|G\ \mathrm{and}\ H\mathrm{\ are\ CFGs\ and}\ L(G)=L(H)\rbrace$是**不可判定的**
   DFA之所以能判定，是因为FA具有封闭性，因此可以构造等价的DFA $C$，但是上下文无关语言不具有封闭性。

最后我们给出RL、DFL和可判定语言之间的关系。
<img src="5_1.png" width="40%" height="40%">

# 2. 不可判定性 