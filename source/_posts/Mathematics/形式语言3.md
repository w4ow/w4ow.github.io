---
title: 形式语言与计算复杂性(二)：上下文无关语言
date: 2021-06-27 15:00
# updated: 0000-00-00 00:00
mathjax: true
meta:
    date: true
categories: 
    - Mathematics
tags:
    - Lecture
---

{% post_link Mathematics/形式语言1 Lecture 0：绪论 %}<br>
{% post_link Mathematics/形式语言2 Lecture 1：正则语言 %}
Lecture 3: 上下文无关语言

---

<!-- more -->

# 1. 上下文无关文法

上下文无关文法(Contex-Free Grammars, CFG)是有一系列替换规则组成的文法，每个替换规则由终结符和非终结符组成。非终结符，亦称为变量，是可以被替换的。例如下例是一个CFG。

$$\begin{aligned}
    &A \to 0A1 \\\\
    &A \to B \\\\
    &B \to \sigma
\end{aligned}$$

使用上下文无关文法，我们可以生成符合文法的字符串，例如使用上面描述的文法可以生成字符串$000\sigma111$： $A\Rightarrow0A1\Rightarrow00A11\Rightarrow000A111\Rightarrow000B111\Rightarrow000\sigma111$。相应的，该字符串的抽象语法书如图所示(此处用#代替了$\sigma$)：

<img src="1_1.png" width="30%" height="30%">

## 1.1 CFG的定义

> 一个上下文无关文法CFG是一个四元组$(V,\Sigma,R,S)$，其中
> 1. $V$是变量集合
> 2. $\Sigma$是终结符集合
> 3. $R$是规则集
> 4. $S\in V$是开始符

此外，还有两个比较重要的概念：
- Yield，也就是直接推导，即能从$uAw$直接通过一步得到$uvw$
- Derives，是间接推导，即通过若干个步骤:$u\stackrel{\ast}{\Rightarrow}v=u\Rightarrow u_1\Rightarrow u_2 \Rightarrow\cdots\Rightarrow u_k\Rightarrow v$
- Language，一个语法的语言是一个集合$\lbrace w\in\Sigma^\ast|S\stackrel{\ast}{\Rightarrow} w\rbrace$

## 1.2 CFG的歧义性

CFG中所谓的歧义性，是指一个语法能通过不同的方式生成同一个字符串，对这样的语法，我们称其为有歧义的语法，如下图所示，通常的字符串和语法规则，有两种不同的生成方式。

<img src="1_2.png" width="70%" height="70%">

为了准确定义歧义性，我们是首先定义最左推导

> 给定文法$G$，一个字符串$w$的最左推导是指，每次推导步骤中首先替换的是最左边的变量。

有了最左推导，我们可以将歧义性定义为$w$有多个不同的最左推导。例如上图中两种推导方式都是最左推导。

## 1.3 Chomsky Normal Form

所谓的Chomsky Normal Form(CNF)，是一种形式上极其简单的CFG，其规则集$R$仅包含两种形式

$$\begin{aligned}
    &A \to BC \\\\
    &A \to a
\end{aligned}$$

其中$A,B,C$是变量，且$B,C$不能是开始符，$a$是终结符。除了这两种形式之外，有时会允许出现$S\to\varepsilon$这个特殊的规则，$S$是开始符。

> **定理**
> 所有的上下文无关语言都是有CNF形式的CFG生成的

我们可以通过以下几个步骤将CFG转换为CNF形式(同样也是该定理的证明)：
1. 添加一个新的开始符$S_0$，并添加新规则$S_0\to S$，使新开始符生成旧开始符。该步骤保证了(新)开始符不会出现在规则的右边
2. 删除所有的涉及到非开始符的$\varepsilon$规则，即形如$A\to\varepsilon$的规则
   1. 如果存在规则$R\to uAv$，则再删除上述规则的同时添加$R\to uv$
   2. 同样的，如果存在规则$R\to A$，则添加规则$R\to\varepsilon$(若之前删除过$R\to\varepsilon$则不添加)
3. 删除所有的形如$A\to B$的规则，当存在规则$B\to u$时，添加规则$A\to u$(若之前删除过$A\to u$则不添加，$u$可以为变量或终结符)
4. 将剩下的规则转换为合适的形式
   1. 将规则$A\to u_1u_2\cdots u_k$($k\ge3$，$u_i$可以是终结符或变量)替换为多个规则：$A\to u_1A_1,A_1\to u_2A_2,...,A_{k-2}=u_{k-1}u_k$
   2. 对所有的终结符$v_i$，将其替换为变量$V_i$并添加规则$V_i=v_i$

下面，我们通过一个例子将CFG转换为CNF形式：

$$\begin{aligned}
    & S \to ASA|aB \\\\
    & A \to B|S \\\\
    & B \to b|\varepsilon
\end{aligned}$$

1. 添加新的开始符
   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB \\\\
    & A \to B|S \\\\
    & B \to b|\varepsilon
   \end{aligned}$$
2. 删除$\varepsilon$规则
   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB|a \\\\
    & A \to B|S|\varepsilon \\\\
    & B \to b
   \end{aligned}$$

   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB|a|SA|AS|S \\\\
    & A \to B|S \\\\
    & B \to b
   \end{aligned}$$
3. 删除形如$A\to B$的规则
   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB|a|SA|AS \\\\
    & A \to B|S \\\\
    & B \to b
   \end{aligned}$$

   $$\begin{aligned}
    & S_0 \to ASA|aB|a|SA|AS \\\\
    & S \to ASA|aB|a|SA|AS \\\\
    & A \to B|S \\\\
    & B \to b
   \end{aligned}$$

   $$\begin{aligned}
    & S_0 \to ASA|aB|a|SA|AS \\\\
    & S \to ASA|aB|a|SA|AS \\\\
    & A \to b|ASA|aB|a|SA|AS \\\\
    & B \to b
   \end{aligned}$$

4. 转换为合适的形式
   $$\begin{aligned}
    & S_0 \to AA_1|UB|a|SA|AS \\\\
    & S \to AA_1|UB|a|SA|AS \\\\
    & A \to b|AA_1|UB|a|SA|AS \\\\
    & A_1 \to SA \\\\
    & U \to a \\\\
    & B \to b
   \end{aligned}$$

---

# 2. Pushdown Automata

## 2.1 定义

所谓的Pushdown Automata(PDA)，就是比NFA多了一个栈的自动机，

> 一个PDA是一个六元组$(Q,\Sigma, \Gamma, \sigma, q_0, F)$，其中
> 1. $Q$是状态的有限集
> 2. $\Sigma$是输入字母表的有限集
> 3. $\Gamma$是栈字母表的有限集
> 4. $Q\times \Sigma_\varepsilon\times\Gamma_\varepsilon\to\mathcal{P}(Q\times\Gamma_\varepsilon)是转移函数$
> 5. $q_0\in Q$是开始状态
> 6. $F\subseteq Q$是终止状态集

对于NFA中无法识别的语言$\lbrace 0^n1^n|n\ge0\rbrace$，我们就可以使用PDA来识别它：

<img src="2_1.png" width="60%" height="60%">

在这个PDA图中，结点之间的边的标签是一个形如$a,b\to c$的伪二元组，其中$a\in\Sigma$是PDA的输入信号，用于转移状态，而$b\to c$则是将当前栈顶元素$b$替换为$c$，例如上图中，$q_1$转移到$q_2$时，$\varepsilon,\varepsilon\to\\$$，栈由空变为包含一个$\\$$。有些让人让人迷惑的点，在$q_2$到$q_2$的自循环中，其栈变化是$\varepsilon\to0$，但此时的栈明明经过上一个转换，应当是包含了一个$\\$$元素的。实际上这是对栈描述不同所引起的，在这里，**我们认为在$\\$$之上的$\varepsilon$才是真正的栈顶**。即**所有的形如$\varepsilon\to c$都被视为将$c$压入栈顶的操作**，同样的，**所有的形如$b\to\varepsilon$都将被视为栈顶元素$b$的出栈操作**。

此外，我们还给出一个能识别语言$\lbrace a^ib^jc^k|i,j,k\ge0\ and\ i=j\ or\ i=k\rbrace$的PDA，此图中，上半分支识别$a^ib^ic^k$，下半分支识别$a^ib^jc^i$。

<img src="2_2.png" width="50%" height="50%">

## 2.2 PDA与CFG的等价性

> **定理**
> 一个语言是上下文无关的当且仅当存在PDA能识别它
> **引理1**
> 一个语言是上下文无关的，那么存在PDA能识别它
> **引理2**
> PDA能识别的语言是上下文无关的

### 2.2.1 证明引理一

给定一个CFG $G$，我们尝试证明引理1：
1. 将标志符\$和开始变量入栈
2. 重复以下步骤：
   1. 如果栈顶元素是一个变量$A$，选择$A$的一个规则**从右往左**将$A$替换掉
   2. 如果栈顶元素是终结符$a$，那么就从输入中读取下一个符号$u$。如果$u$和$a$相同，则将栈顶元素$a$退栈，否则拒绝该分支(reject on this branch of the nondeterminism)
   3. 如果栈顶元素是\$，输入终止状态。Doing so accepts the input if it has all been read.

上面的说明不清不楚，我们通过例子来说明

例一：对于规则$s\to xyz$，PDA读取$a$后，我们应用从右往左的规则将栈中的$s$替换为$zyx$，首先将栈中的$s$替换为$z$，然后依次将$y,x$入栈

<img src="2_3.png" width="40%" height="40%">

例二：所有的CFG都可转换为以下形式

<img src="2_4.png" width="40%" height="40%">

例三：根据例一和例二，我们可以将以下CFG转换为PDA：
$$\begin{aligned}
    &S \to aTb | b \\\\
    &T \to Ta | \varepsilon
\end{aligned}$$

<img src="2_5.png" width="40%" height="40%">

### 2.2.2 证明引理二


## 2.3 总结

> **推论**：所有的正则语言都是上下文无关的。

这是因为，所有的正则语言都恒等于一个NFA，而任意NFA都是一个特殊的PDA，即没有栈空间的PDA，而PDA上下文无关语言是等价的。因此，正则语言都是上下文无关的。

---

# 3. 非上下文无关语言

与NFA相似，对于PDA无法识别的语言，我们称之为非上下文无关语言。同样的，我们可以用Pumping Lemma来证明一个语言是上下文无关的。

> **CFG的Pumping Lemma**
> 如果$A$是上下文无关语言，那么存在一个pumping length $p$，使得对于$A$中任意长度至少为$p$的字符串$s$，$s$可以被分为5部分$uvxyz$且满足以下情况：
> 1. $uv^ixy^iz \in A, i\ge0$
> 2. $|vy| > 0$
> 3. $|vxy| \le p$

---

# 4. 确定的上下文无关语言

在前文我们了解到，FA分为NFA和DFA。同样的，PDA也有确定性与非确定性之分，而且PDA是非确定的，当然也存在确定的PDA，我们称为DPDA，相对应的语言称为确定的CFL(DCFL)。在此我们给出DPDA的定义：

> **DPDA**
> 一个确定的DPA是一个六元组$(Q,\Sigma,\Gamma, \delta,q_0,F)$，其中
> 1. $Q$是有限状态集
> 2. $\Sigma$是有限输入字母表
> 3. $\Gamma$是有限栈字母表
> 4. $\delta:Q\times\Sigma_\varepsilon\times\Gamma_\varepsilon\to(Q\times\Gamma_\varepsilon)\cup\lbrace\emptyset\rbrace$是转移函数
> 5. $q_0\in Q$是开始状态
> 6. $F\subseteq Q$是终止状态集

其转移函数$\delta$必须满足：对于每一个$q\in Q, a\in \Sigma, x\in\Gamma$，以下四个状态的值都不为$\emptyset$: $\delta(q,a,x),\delta(q,a,\varepsilon),\delta(q,\varepsilon,x),\delta(q,\varepsilon,\varepsilon)$

最后，举两个例子，语言$\lbrace0^n1^n|n\ge0\rbrace$是DCFL，而$\lbrace a^ib^jc^k|i,j,k\ge0\ and\ i=j\ or\ i=k\rbrace$则是NCFL。

---

# 作业

1. Recall the CFG $G_4$ that we gave in Example 2.4. For convenience, let's rename its variables with single letters as follows.
$$\begin{aligned}
    &E \to E+T|T \\\\
    &T \to T\times F|F \\\\
    &F \to (E)|a
\end{aligned}$$

   Give parse trees and derivations for each string.
    1. a
    2. a+a
    3. a+a+a
    4. ((a))
   
   **Answer**
   1. $$\begin{aligned}
       E &\Rightarrow T \\\\
         &\Rightarrow F \\\\
         & \Rightarrow a
      \end{aligned}$$
   
   <img src="e11.png" width="2%" height="2%">

   ---

   2. $$\begin{aligned}
       E &\Rightarrow E+T \\\\
         &\Rightarrow T+T \\\\
         &\Rightarrow F+T \\\\
         &\Rightarrow a+T \\\\
         &\Rightarrow a+F \\\\
         &\Rightarrow a+a
      \end{aligned}$$
   
   <img src="e12.png" width="15%" height="15%">

   ---

   3. $$\begin{aligned}
       E &\Rightarrow E+T \\\\
         &\Rightarrow E+T+T \\\\
         &\Rightarrow T+T+T \\\\
         & \Rightarrow F+T+T \\\\
         & \Rightarrow a+T+T \\\\
         & \Rightarrow a+F+T \\\\
         & \Rightarrow a+a+T \\\\
         & \Rightarrow a+a+F \\\\
         & \Rightarrow a+a+a \\\\
      \end{aligned}$$
   
   <img src="e13.png" width="20%" height="20%">

   ---
   4. $$\begin{aligned}
       E &\Rightarrow T \\\\
         &\Rightarrow F \\\\
         &\Rightarrow (E) \\\\
         & \Rightarrow (T) \\\\
         & \Rightarrow (F) \\\\
         & \Rightarrow ((E)) \\\\
         & \Rightarrow ((T)) \\\\
         & \Rightarrow ((F)) \\\\
         & \Rightarrow ((a)) \\\\
      \end{aligned}$$
        
    <img src="e14.png" width="60%" height="60%">

2. Give a context-free grammar that generates the language
   $$A=\lbrace a^ib^jc^k|i=j\ or\ j=k\ where\ i,j,j\ge0\rbrace$$
   Is your grammar ambiguous? Why or why not?

   **Answer**
$$\begin{aligned}
    S &\to UT|XY \\\\
    U &\to aUb|\varepsilon \\\\
    T &\to cT|\varepsilon \\\\
    X &\to aX|\varepsilon \\\\
    Y &\to bYc|\varepsilon
\end{aligned}$$
   该CFG是歧义的，例如对于字符串$abc$，有两种生成过程

   <img src="e2.png" width="80%" height="80%">

3. Give an informal description of a pushdown automaton that recognizes the language $A$ in Exercise above.
   
   **Answer**
$$\begin{aligned}
    &Q = \lbrace q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8\rbrace \\\\
    &\Sigma = \lbrace a,b,c\rbrace \\\\
    &\Gamma = \lbrace a,b,\\$\rbrace \\\\
    & q_0 = q_1 \\\\
    & F = \lbrace q_4,q_8\rbrace \\\\
    & \delta 参考下图
\end{aligned}$$

   <img src="e3.png" width="90%" height="90%">

4. Convert the following CFG into an equivalent CFG in Chomsky normal form, using the procedure given in Theorem 2.9
$$\begin{aligned}
   &A \to BAB|B\varepsilon \\\\
   &B \to 00|\varepsilon
\end{aligned}$$

   **Answer**
   1. 添加新的开始规则
   $$\begin{aligned}
      &S \to A \\\\
      &A \to BAB|B\varepsilon \\\\
      &B \to 00|\varepsilon
   \end{aligned}$$
   2. 删除$\varepsilon$规则
   $$\begin{aligned}
      &S \to A \\\\
      &A \to BAB|B\varepsilon|AB|BA|A|\varepsilon \\\\
      &B \to 00
   \end{aligned}$$

   $$\begin{aligned}
      &S \to A|\varepsilon \\\\
      &A \to BAB|B|AB|BA|A \\\\
      &B \to 00
   \end{aligned}$$
   3. 删除形如$A\to B$的规则
   $$\begin{aligned}
      &S \to BAB|00|AB|BA|\varepsilon \\\\
      &A \to BAB|00|AB|BA \\\\
      &B \to 00
   \end{aligned}$$
   4. 化为合适的形式
   $$\begin{aligned}
      &S \to XB|YY|AB|BA|\varepsilon \\\\
      &A \to XB|YY|AB|BA \\\\
      &X \to BA \\\\
      &B \to YY \\\\
      &Y \to 0
   \end{aligned}$$

5. Show that $F=\lbrace a^ib^j|i=kj\ for\ some\ positive\ integer\ k\rbrace$ is not context free.
   **Answer(该证明未必正确)**
   假设$F$是上下文无关的，那么根据pumping lemma，令$p$为$F$的pumping length。首先我们考虑$k=3$的字符串$s=a^{3p}b^p$，根据pumping lemma，$s$可以被任意划分为五个部分$s=uvxyz$，且$|vy|>0$。现在我们分两种情况讨论：
   1. 考虑$v$和$y$中至少有一个是同时包含$a$和$b$两种字符，那么上$s'=uv^2xy^2z$中因为$v^2$和$y^2$会导致$s'$中出现$b$在$a$前的乱序，即$s'\not\in F$，因此这种情况不符合$F的定义。
   2. 考虑$v$和$y$都只包含一种字符：
      1. $v$和$y$中都只包含$a$，假设$|v|=m$，$|y|=n$，则$s'=uv^2xy^2z=a^{3p+m+n}b^p$，此时当且仅当$m+n$是$p$的整数倍时$s'\in F$，然而事实上$p$可以是任意值，例如$m+n=5$对$p=5$成立，但对$p=4$却不成立。此外，我们选用的字符串$s=a^{3p}b^p$，我们也可以选定字符串$s=a^{3(p+2)}b^{p+2}$。
      2. $v$和$y$中都只包含$b$，与上相似，假设$|v|=m$，$|y|=n$，则$s'=uv^2xy^2z=a^{3p}b^{p+m+n}$，当且仅当$3p$是$p+m+n$的整数倍时才成立。
      3. $v$中只包含$a$，$y$中只包含$b$，假设$|v|=m$，$|y|=n$，则$s'=uv^2xy^2z=a^{3p+m}b^{p+n}$，当且仅当$3p+m$是$p+n$的整数倍时才成立。
   同理，我们也可以证明$k=5,7,...$时与上述相同，综上该语言非上下文无关。