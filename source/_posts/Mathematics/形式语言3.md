---
title: 形式语言与计算复杂性(二)：上下文无关语言
date: 2021-06-27 15:00
# updated: 0000-00-00 00:00
mathjax: true
meta:
    date: true
categories: 
    - Mathematics
tags:
    - Lecture
---

{% post_link Mathematics/形式语言1 Lecture 0：绪论 %}<br>
{% post_link Mathematics/形式语言2 Lecture 1：正则语言 %}
Lecture 2: 上下文无关语言
{% post_link Mathematics/形式语言4 Lecture 3：Church-Turing %}

---

<!-- more -->

# 1. 上下文无关文法

在这一节课中，我们将介绍表达能力更强、形式也更复杂的语言——上下文无关语言。上下文无关语言(Context Free Language, CFL)是由根据上下文无关文法所生成的字符串的集合，上下文无关文法(Contex-Free Grammars, CFG)是有一系列替换规则组成的语法规则，每个替换规则由终结符和非终结符组成。非终结符，亦称为变量，是可以被替换的。例如下例是一个CFG。

$$\begin{aligned}
    &A \to 0A1 \\\\
    &A \to B \\\\
    &B \to \sigma
\end{aligned}$$

使用上下文无关文法，我们可以生成符合文法的字符串，例如使用上面描述的文法可以生成字符串$000\\#111$，$A\Rightarrow0A1\Rightarrow00A11\Rightarrow000A111\Rightarrow000B111\Rightarrow000\\#111$，对应的解析树如图所示。我们将根据该文法生成的所有字符串组成的集合称为该语法的语言，即$\lbrace w\in\Sigma^\ast|A\stackrel{\ast}{\Rightarrow} w\rbrace$。

<img src="1_1.png" width="25%" height="25%">

## 1.1 CFG的定义

> 一个上下文无关文法CFG是一个四元组$(V,\Sigma,R,S)$，其中
> 1. $V$是变量集合
> 2. $\Sigma$是终结符集合
> 3. $R$是规则集
> 4. $S\in V$是开始变量

从定义上看，CFG与FA相比十分类似，例如CFG的变量集等价于FA的符号集$\Sigma$，CFG的规则集$R$等价于FA的转移函数$\delta$。不过，两者不同的地方更多，例如CFG的终结符集$\Sigma$中的元素不可再被推导。

此外，还有两个比较重要的概念：
- Yield，也就是直接推导，即能从$uAw$直接通过一步得到$uvw$
- Derives，是间接推导，即通过若干个步骤:$u\stackrel{\ast}{\Rightarrow}v=u\Rightarrow u_1\Rightarrow u_2 \Rightarrow\cdots\Rightarrow u_k\Rightarrow v$

## 1.2 CFG的歧义性

首先我们来认识一下最左推导：

> 给定文法$G$，一个字符串$w$的最左推导是指，每次推导步骤中最先替换最左边的变量。

CFG中所谓的歧义性，是指一个语法能通过不同的方式生成同一个字符串，即有多个不同的最左推导。对这样的语法，我们称其为有歧义的语法。下图是一个有歧义的语法的例子，两种不同的最左推导可以产生同样的字符串。

<img src="1_2.png" width="60%" height="60%">

## 1.3 Chomsky Normal Form

所谓的Chomsky Normal Form(CNF)，是一种形式上极其简单的CFG，其规则集$R$仅包含两种形式

$$\begin{aligned}
    &A \to BC \\\\
    &A \to a
\end{aligned}$$

其中$A,B,C$是任意变量，且$B,C$不能是开始符，$a$是终结符。除了这两种形式之外，有时会允许出现$S\to\varepsilon$这个特殊的规则，其中$S$是开始符。基于CNF，我们可以跟好的研究CFG与CFL之间的等价性：

> **定理**
> 所有的上下文无关语言都是由CNF形式的CFG生成的

因为CFL是由CFG生成的，即CFL$\equiv$CFG，而接下来我们将给出将任意CFG转换为CNF的方法，该方法证明了CNF$\equiv$CFG，因此上述定理也被证明了：
1. 添加一个新的开始符$S_0$，并添加新规则$S_0\to S$，即新开始符yield旧开始符。该步骤保证了新开始符不会出现在规则的右边
2. 删除所有的涉及到非开始符的$\varepsilon$规则，即形如$A\to\varepsilon$的规则
   1. 如果存在规则$R\to uAv$，则在删除上述规则的同时添加$R\to uv$
   2. 同样的，如果存在规则$R\to A$，则添加规则$R\to\varepsilon$(若之前删除过$R\to\varepsilon$则不添加)
3. 删除所有的形如$A\to B$的规则，当存在规则$B\to u$时，添加规则$A\to u$(若之前删除过$A\to u$则不添加，$u$可以为变量或终结符)
4. 将剩下的规则转换为合适的形式
   1. 将规则$A\to u_1u_2\cdots u_k$($k\ge3$，$u_i$可以是终结符或变量)替换为多个规则：$A\to u_1A_1,A_1\to u_2A_2,...,A_{k-2}=u_{k-1}u_k$
   2. 对所有的终结符$v_i$，将其替换为变量$V_i$并添加规则$V_i=v_i$

下面，我们通过一个例子将CFG转换为CNF形式：

$$\begin{aligned}
    & S \to ASA|aB \\\\
    & A \to B|S \\\\
    & B \to b|\varepsilon
\end{aligned}$$

1. 添加新的开始符
   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB \\\\
    & A \to B|S \\\\
    & B \to b|\varepsilon
   \end{aligned}$$
2. 删除$\varepsilon$规则
   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB|a \\\\
    & A \to B|S|\varepsilon \\\\
    & B \to b
   \end{aligned}$$

   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB|a|SA|AS|S \\\\
    & A \to B|S \\\\
    & B \to b
   \end{aligned}$$
3. 删除形如$A\to B$的规则
   $$\begin{aligned}
    & S_0 \to S \\\\
    & S \to ASA|aB|a|SA|AS \\\\
    & A \to B|S \\\\
    & B \to b
   \end{aligned}$$

   $$\begin{aligned}
    & S_0 \to ASA|aB|a|SA|AS \\\\
    & S \to ASA|aB|a|SA|AS \\\\
    & A \to B|S \\\\
    & B \to b
   \end{aligned}$$

   $$\begin{aligned}
    & S_0 \to ASA|aB|a|SA|AS \\\\
    & S \to ASA|aB|a|SA|AS \\\\
    & A \to b|ASA|aB|a|SA|AS \\\\
    & B \to b
   \end{aligned}$$

4. 转换为合适的形式
   $$\begin{aligned}
    & S_0 \to AA_1|UB|a|SA|AS \\\\
    & S \to AA_1|UB|a|SA|AS \\\\
    & A \to b|AA_1|UB|a|SA|AS \\\\
    & A_1 \to SA \\\\
    & U \to a \\\\
    & B \to b
   \end{aligned}$$

---

# 2. Pushdown Automata

## 2.1 定义

正如正则语言可以被FA识别，CFG也可以被一种特殊的自动机所识别，即所谓的Pushdown Automata(PDA)，就是比NFA多了一个栈的自动机：

> 一个PDA是一个六元组$(Q,\Sigma, \Gamma, \sigma, q_0, F)$，其中
> 1. $Q$是状态的有限集
> 2. $\Sigma$是输入字母表的有限集
> 3. $\Gamma$是栈字母表的有限集
> 4. $Q\times \Sigma_\varepsilon\times\Gamma_\varepsilon\to\mathcal{P}(Q\times\Gamma_\varepsilon)$是转移函数，可以看到转移后得到的是状态集
> 5. $q_0\in Q$是开始状态
> 6. $F\subseteq Q$是终止状态集

PDA与FA相比，其能力更为强大，可以识别NFA中无法识别的语言，如$\lbrace 0^n1^n|n\ge0\rbrace$：

<img src="2_1.png" width="60%" height="60%">

在这个PDA中(图中右上角)，结点之间的边的标签是一个形如$a,b\to c$的伪二元组，其中$a\in\Sigma$是PDA的输入信号，PDA根据输入信号转移状态。$b\to c$则是将当前栈顶元素$b$替换为$c$。需要注意的是，在本课程的PDA的所有图例中，**$\varepsilon\to a$都表示入栈操作，$a\to\varepsilon$表示出栈操作，相应的，$\varepsilon\to\varepsilon$表示不对栈进行任何操作**。例如上图中，$q_1$转移到$q_2$时，$\varepsilon,\varepsilon\to\\$$，栈由空变为包含一个$\\$$，这就是一个入栈操作。

此外，我们还给出一个能识别语言$\lbrace a^ib^jc^k|i,j,k\ge0\ and\ i=j\ or\ i=k\rbrace$的PDA，此图中，上半分支识别$a^ib^ic^k$，下半分支识别$a^ib^jc^i$。

<img src="2_2.png" width="50%" height="50%">

## 2.2 PDA与CFG的等价性

> **定理**
> 一个语言是上下文无关的当且仅当存在PDA能识别它
> **引理1**
> 一个语言是上下文无关的，那么存在PDA能识别它
> **引理2**
> PDA能识别的语言是上下文无关语言

### 2.2.1 证明引理一

给定任意CFG $G$，我们可以将其转换为PDA，进而证明引理1：
1. 首先我们构造一个仅包含开始状态$q_{start}$、循环状态$q_{loop}$、终止状态$q_{accept}$这三个状态的PDA，如下图所示。
   <img src="2_4.png" width="35%" height="35%">
2. 将标志符\\$和开始变量入栈，并在$q_{start}$和$q_{loop}$之间添加边$\varepsilon,\varepsilon\to S\\$$
3. 重复以下步骤：
   1. 对所有形如$A\to BCD$的语法，我们按**从右至左**的规则在PDA中添加一个从$q_{loop}$到$q_{loop}$的自循环。即$q_{loop} \stackrel{\varepsilon,A\to D}{\longrightarrow}\bigcirc \stackrel{\varepsilon,\varepsilon\to C}{\longrightarrow}\bigcirc \stackrel{\varepsilon,\varepsilon\to B}{\longrightarrow}q_{loop}$
   <img src="2_3.png" width="30%" height="30%">
   2. 对所有的终结符$a$，我们同样添加一个从$q_{loop}$到$q_{loop}$的自循环，即$q_{loop} \stackrel{\varepsilon,a\to\varepsilon}{\longrightarrow}q_{loop}$
4. 最后，添加$q_{loop}$到$q_{accept}$的边$\varepsilon,\\$\to\varepsilon$

上面的文字描述不清不楚，我们通过例子进行更形象的说明，我们可以将以下CFG转换为PDA：
$$\begin{aligned}
    &S \to aTb | b \\\\
    &T \to Ta | \varepsilon
\end{aligned}$$

<img src="2_5.png" width="40%" height="40%">

### 2.2.2 证明引理二

该引理的证明思路，给定一个PDA $P$，我们想要构造出对应的CFG $G$，使得$G$所生成的字符串能被$P$识别。如何做呢？首先，对$P$中的任意两个状态$p$和$q$，我们先构造一个变量$A_{pq}\in G$。我们给$A_{pq}$赋予一个特殊的性质，它能生成所有让$P$从状态$p$转移到状态$q$的字符串，并且$p$和$q$这两个状态的栈都为空。即，$P$从状态$p$转移到状态$q$的过程中，栈可能会变化，但在$p$和$q$这两个状态时栈一定为空。
然后我们稍微的修改给定的$P$，使它具备以下性质：
1. 只有一个接受状态
2. 在进入接受状态之前，栈被清空
3. 在每次状态转移时，它的栈只能进栈或者退栈，不能使用替换操作。我们可以使用先出栈再进栈来模拟替换操作。

那么，基于以上修改后的$P$以及$A_{pq}$，我们考虑一个字符串$x=a,...,b$，$P$对$x$的计算的第一步肯定是将$a$入栈。而计算的最后一步则分为两种情况：

1. 第一种情况是$a$出栈(先入后出)，这时候我们可以使用规则$A_{pq}\to aA_{rs}b$来模拟这种情况，其中$r$是$P$接收$a$后的状态，$s$是$P$接收$b$之前的状态。
   <img src="3_1.png" width="60%" height="60%">
2. 第二种情况是某个中间字符$x_i$出栈，这说明$P$在中间某个过程中栈被清空了,我们可以使用规则$A_{pq}\to A_{pr}A_{rq}$来模拟，其中$P$在状态$r$时栈为空。
   <img src="3_2.png" width="60%" height="60%">

接下来我们就可以进行引理2的证明了。给定PDA $P=(Q,\Sigma, \Gamma, \delta, q_0, \lbrace q_{accept}\rbrace)$，我们首先构造CFG $G$的开始变量，令其为$A_{q_0,q_{accept}}$，然后以下面的规则构造$G$的语法：
1. **对每个$p,q,r,s\in Q, u\in\Gamma$以及$a,b\in\Sigma_{\varepsilon}$，如果$\delta(p,a,\varepsilon)$包含$(r,u)$**(意味着$P$接收输入$a$，从状态$p$转移到$r$，并将$u$入栈)**并且$\delta(s,b,u)$包含$(q,\varepsilon)$**(意味着$P$接收输入$b$，从状态$s$转移到$q$，并将$u$出栈)，**那么我们添加语法$A_{pq}\to aA_{rs}b$**
2. **对每个$p,q,r\in Q$，我们添加语法$A_{pq}\to A_{pr}A_{rq}$**
3. **最后，对每个$p\in Q$，我们添加语法$A_{pp}\to\varepsilon$**


## 2.3 总结

首先，由引理2我们可以得到两个声明：
> **声明1**：如果$A_{pq}$生成$x$，那么$x$能将$P$从空栈的状态$p$转移到空栈的状态$q$。
> **声明2**：如果$x$能将$P$从空栈的状态$p$转移到空栈的状态$q$，那么$A_{pq}$生成$x$。

> **推论**：所有的正则语言都是上下文无关的。

这是因为，所有的正则语言都恒等于一个NFA，而任意NFA都是一个特殊的PDA，即没有栈空间的PDA，而PDA上下文无关语言是等价的。因此，正则语言都是上下文无关的。

---

# 3. 非上下文无关语言

与NFA相似，对于PDA无法识别的语言，我们称之为非上下文无关语言。同样的，我们可以用Pumping Lemma来证明一个语言是上下文无关的。

> **CFG的Pumping Lemma**
> 如果$A$是上下文无关语言，那么存在一个pumping length $p$，使得对于$A$中任意长度至少为$p$的字符串$s$，$s$可以被分为5部分$uvxyz$且满足以下情况：
> 1. $uv^ixy^iz \in A, i\ge0$
> 2. $|vy| > 0$
> 3. $|vxy| \le p$

---

# 4. 确定的上下文无关语言

在前文我们了解到，FA分为NFA和DFA。同样的，PDA也有确定性与非确定性之分，而且PDA是非确定的，当然也存在确定的PDA，我们称为DPDA，相对应的语言称为确定的CFL(DCFL)。在此我们给出DPDA的定义：

> **DPDA**
> 一个确定的DPA是一个六元组$(Q,\Sigma,\Gamma, \delta,q_0,F)$，其中
> 1. $Q$是有限状态集
> 2. $\Sigma$是有限输入字母表
> 3. $\Gamma$是有限栈字母表
> 4. $\delta:Q\times\Sigma_\varepsilon\times\Gamma_\varepsilon\to(Q\times\Gamma_\varepsilon)\cup\lbrace\emptyset\rbrace$是转移函数
> 5. $q_0\in Q$是开始状态
> 6. $F\subseteq Q$是终止状态集

其转移函数$\delta$必须满足：对于每一个$q\in Q, a\in \Sigma, x\in\Gamma$，以下四个状态的值都不为$\emptyset$: $\delta(q,a,x),\delta(q,a,\varepsilon),\delta(q,\varepsilon,x),\delta(q,\varepsilon,\varepsilon)$

最后，举两个例子，语言$\lbrace0^n1^n|n\ge0\rbrace$是DCFL，而$\lbrace a^ib^jc^k|i,j,k\ge0\ and\ i=j\ or\ i=k\rbrace$则是NCFL。

---

# 作业

1. Recall the CFG $G_4$ that we gave in Example 2.4. For convenience, let's rename its variables with single letters as follows.
$$\begin{aligned}
    &E \to E+T|T \\\\
    &T \to T\times F|F \\\\
    &F \to (E)|a
\end{aligned}$$

   Give parse trees and derivations for each string.
    1. a
    2. a+a
    3. a+a+a
    4. ((a))
   
   **Answer**
   1. $$\begin{aligned}
       E &\Rightarrow T \\\\
         &\Rightarrow F \\\\
         & \Rightarrow a
      \end{aligned}$$
   
   <img src="e11.png" width="2%" height="2%">

   ---

   2. $$\begin{aligned}
       E &\Rightarrow E+T \\\\
         &\Rightarrow T+T \\\\
         &\Rightarrow F+T \\\\
         &\Rightarrow a+T \\\\
         &\Rightarrow a+F \\\\
         &\Rightarrow a+a
      \end{aligned}$$
   
   <img src="e12.png" width="15%" height="15%">

   ---

   3. $$\begin{aligned}
       E &\Rightarrow E+T \\\\
         &\Rightarrow E+T+T \\\\
         &\Rightarrow T+T+T \\\\
         & \Rightarrow F+T+T \\\\
         & \Rightarrow a+T+T \\\\
         & \Rightarrow a+F+T \\\\
         & \Rightarrow a+a+T \\\\
         & \Rightarrow a+a+F \\\\
         & \Rightarrow a+a+a \\\\
      \end{aligned}$$
   
   <img src="e13.png" width="20%" height="20%">

   ---
   4. $$\begin{aligned}
       E &\Rightarrow T \\\\
         &\Rightarrow F \\\\
         &\Rightarrow (E) \\\\
         & \Rightarrow (T) \\\\
         & \Rightarrow (F) \\\\
         & \Rightarrow ((E)) \\\\
         & \Rightarrow ((T)) \\\\
         & \Rightarrow ((F)) \\\\
         & \Rightarrow ((a)) \\\\
      \end{aligned}$$
        
    <img src="e14.png" width="60%" height="60%">

2. Give a context-free grammar that generates the language
   $$A=\lbrace a^ib^jc^k|i=j\ or\ j=k\ where\ i,j,j\ge0\rbrace$$
   Is your grammar ambiguous? Why or why not?

   **Answer**
$$\begin{aligned}
    S &\to UT|XY \\\\
    U &\to aUb|\varepsilon \\\\
    T &\to cT|\varepsilon \\\\
    X &\to aX|\varepsilon \\\\
    Y &\to bYc|\varepsilon
\end{aligned}$$
   该CFG是歧义的，例如对于字符串$abc$，有两种生成过程

   <img src="e2.png" width="80%" height="80%">

3. Give an informal description of a pushdown automaton that recognizes the language $A$ in Exercise above.
   
   **Answer**
$$\begin{aligned}
    &Q = \lbrace q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8\rbrace \\\\
    &\Sigma = \lbrace a,b,c\rbrace \\\\
    &\Gamma = \lbrace a,b,\\$\rbrace \\\\
    & q_0 = q_1 \\\\
    & F = \lbrace q_4,q_8\rbrace \\\\
    & \delta 参考下图
\end{aligned}$$

   <img src="e3.png" width="90%" height="90%">

4. Convert the following CFG into an equivalent CFG in Chomsky normal form, using the procedure given in Theorem 2.9
$$\begin{aligned}
   &A \to BAB|B\varepsilon \\\\
   &B \to 00|\varepsilon
\end{aligned}$$

   **Answer**
   1. 添加新的开始规则
   $$\begin{aligned}
      &S \to A \\\\
      &A \to BAB|B\varepsilon \\\\
      &B \to 00|\varepsilon
   \end{aligned}$$
   2. 删除$\varepsilon$规则
   $$\begin{aligned}
      &S \to A \\\\
      &A \to BAB|B\varepsilon|AB|BA|A|\varepsilon \\\\
      &B \to 00
   \end{aligned}$$

   $$\begin{aligned}
      &S \to A|\varepsilon \\\\
      &A \to BAB|B|AB|BA|A \\\\
      &B \to 00
   \end{aligned}$$
   3. 删除形如$A\to B$的规则
   $$\begin{aligned}
      &S \to BAB|00|AB|BA|\varepsilon \\\\
      &A \to BAB|00|AB|BA \\\\
      &B \to 00
   \end{aligned}$$
   4. 化为合适的形式
   $$\begin{aligned}
      &S \to XB|YY|AB|BA|\varepsilon \\\\
      &A \to XB|YY|AB|BA \\\\
      &X \to BA \\\\
      &B \to YY \\\\
      &Y \to 0
   \end{aligned}$$

5. Show that $F=\lbrace a^ib^j|i=kj\ for\ some\ positive\ integer\ k\rbrace$ is not context free.
   **Answer(该证明未必正确)**
   假设$F$是上下文无关的，那么根据pumping lemma，令$p$为$F$的pumping length。首先我们考虑$k=3$的字符串$s=a^{3p}b^p$，根据pumping lemma，$s$可以被任意划分为五个部分$s=uvxyz$，且$|vy|>0$。现在我们分两种情况讨论：
   1. 考虑$v$和$y$中至少有一个是同时包含$a$和$b$两种字符，那么上$s'=uv^2xy^2z$中因为$v^2$和$y^2$会导致$s'$中出现$b$在$a$前的乱序，即$s'\not\in F$，因此这种情况不符合$F的定义。
   2. 考虑$v$和$y$都只包含一种字符：
      1. $v$和$y$中都只包含$a$，假设$|v|=m$，$|y|=n$，则$s'=uv^2xy^2z=a^{3p+m+n}b^p$，此时当且仅当$m+n$是$p$的整数倍时$s'\in F$，然而事实上$p$可以是任意值，例如$m+n=5$对$p=5$成立，但对$p=4$却不成立。此外，我们选用的字符串$s=a^{3p}b^p$，我们也可以选定字符串$s=a^{3(p+2)}b^{p+2}$。
      2. $v$和$y$中都只包含$b$，与上相似，假设$|v|=m$，$|y|=n$，则$s'=uv^2xy^2z=a^{3p}b^{p+m+n}$，当且仅当$3p$是$p+m+n$的整数倍时才成立。
      3. $v$中只包含$a$，$y$中只包含$b$，假设$|v|=m$，$|y|=n$，则$s'=uv^2xy^2z=a^{3p+m}b^{p+n}$，当且仅当$3p+m$是$p+n$的整数倍时才成立。
   同理，我们也可以证明$k=5,7,...$时与上述相同，综上该语言非上下文无关。