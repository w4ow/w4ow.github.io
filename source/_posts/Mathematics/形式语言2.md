---
title: 形式语言与计算复杂性--一：正则语言
date: 2021-06-23 15:00
# updated: 0000-00-00 10:00
mathjax: true
meta:
    date: true
categories: 
    - Mathematics
tags:
    - Lecture
---

{% post_link Mathematics/形式语言1 Lecture 0：绪论 %}
Lecture 1：正则语言

---

<!-- more -->

有限状态机是，一个理想的计算机(或者称为计算模型)，可以通过正则语言来区分。


# 1 有限状态机

一个包含*开*与*关*两个状态的自动门就是一个有限状态机

<img src="finite_automata.png" width="80%" height="80%">

> **有限状态机(DFA)定义**：
> 
> 有限状态机是一个五元组$(Q,\Sigma,\delta,q_0,F)$
> - $Q$是被称为状态的有限集合
> - $\Sigma$是被称为字母表的有限集合
> - $\delta$是状态转移函数$Q\times\Sigma\to Q$
> - $q_0\in Q$是初始状态
> - $F\subseteq Q$是终止状态集

<img src="fa-1.png" width="80%" height="80%">

## 1.1 有限状态机的作用

有限状态机的主要作用是求解特定类型的问题，首先先对问题进行定义

**问题定义**

给定字符串集合$S$以及布尔函数$f:S\to\lbrace 0,1\rbrace$，$x\in S$，计算$f(x)$。

更进一步地，可以将上述问题转换为：给定集合$A\subseteq S, x\in S$，计算$x\in A$是否成立。在该定义中$x\in A\Rightarrow f(x)=1$, $x\not\in A\Rightarrow f(x)=0$。

**问题求解**

给定一个布尔函数$f:S\to\lbrace{0,1}\rbrace$，$S$是基于字母表$\Sigma$的字符串集合(例如$S=\lbrace{0,10,010,...}\rbrace$), $S$的子集${A}\subseteq{S}$, 一个自动机$M$以及一种能被$M$识别的语言$L(M)=\lbrace{s}\in{S}|{M}\ {accepts}\ {s}\rbrace$，那么所有问题可以被形式化为布尔问题：给定${x}\in{S},{x}\in{A}$，求解${A}=L(M)$是否为真。

**有限状态机示例**

- 例1：
  <img src="ex1.png" width="50%" height="50%">
  $\Sigma=\lbrace 0, 1\rbrace, A=\lbrace w|w至少包含一个1且以偶数个0结尾\rbrace$
- 例2：
  <img src="ex2.png" width="30%" height="30%">
  $\Sigma=\lbrace 0, 1\rbrace, A=\lbrace w|w至少包含一个1且以1结尾\rbrace$
- 例3：
  <img src="ex3.png" width="30%" height="30%">
  $\Sigma=\lbrace 0, 1\rbrace, A=\lbrace w|w以偶数个(包括0个)0结尾\rbrace$
- 例4：
  <img src="ex4.png" width="50%" height="50%">
  $\Sigma=\lbrace a, b\rbrace, A=\lbrace w|w的开始符号与结束符号相同\rbrace$
- 例5：
  <img src="ex5.png" width="50%" height="50%">
  $\Sigma=\lbrace {0, 1, 2}\rbrace$, 
  $A=\lbrace w|w的和是3的倍数\rbrace$

## 1.2 正则语言
>在以上的例子中,$A$就是正则语言。所谓**正则语言，就是能被某些有限自动机识别的语言。**而**识别**就是，给定机器$M$以及语言$A$，$A=\lbrace w|M\ accepts\ w\rbrace$

---

# 2 预备知识

## 2.1 定义有限自动机FA

例：假设字符表$\Sigma=\lbrace 0,1\rbrace$，且语言$A$为有奇数个$1$的字符串集合。

1. 列出所有的可能性
   - even
   - odd
2. 将可能性表示为状态，即图的结点
   <img src="1_2_1_1.png" width="20%" height="20%">
3. 标出状态转移箭头
   <img src="1_2_1_2.png" width="20%" height="20%">
4. 标出初始状态和结束状态
   <img src="1_2_1_3.png" width="20%" height="20%">

## 2.2 定义正则操作

在定义正则语言后，可以定义正则语言的正则操作，假定$A,B$为语言：
- Union: $A\cup B=\lbrace x|x\in A\ or\ x\in B\rbrace$
- Concatenation: $A\circ B=\lbrace xy|x\in A\ and\ y\in B\rbrace$
- Star: $A^{\ast}=\lbrace x_1...x_k|k\ge 0\ and\ x_i\in A\rbrace$，类似于$\lbrace A^0, A^1, A^2,...\rbrace$缝合成一个集合。

例如，$\Sigma=\lbrace a,...,z\rbrace$, $A=\lbrace good, bad\rbrace$, $\lbrace boy, girl\rbrace$，则有
- $A\cup B=\lbrace good, bad, boy, girl\rbrace$
- $A\circ B=\lbrace goodboy, goodgirl, badboy, badgirl\rbrace$
- $A^{\ast}=\lbrace \epsilon, good, bad, goodgood, goodbad, badgood, badbad, goodgoodgood, goodgoodbad,...\rbrace$

正则语言有一个重要的特性，即**封闭性**。所谓的封闭性是指对集合中的任意对象进行某种操作，其结果仍在该集合中，我们称该集合在该操作上是封闭的。
**正则语言在Union和Concatenation上是封闭的**，即，若$A_1,A_2$是正则语言，那么$A_1\cup A_2$和$A_1\circ A_2$也是正则语言。

## 2.3 构造法证明$A_1\cup A_2$的封闭性
假定$M_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，$M_2=\lbrace Q_2, \Sigma, \delta_2, q_2, F_2\rbrace$识别$A_2$，下面构造$M=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$来识别$A_1\cup A_2$
1. $Q=\lbrace(r_1, r_2)|r_1\in Q_1\ and\ r_2\in Q_2\rbrace$
2. 字母表$\Sigma$与$M_1,M_2$的字母表相同
3. $\delta((r_1, r_2),a) = (\delta_1(r_1,a), \delta_2(r_2, a))$
4. $q_0=(q_1,q_2)$
5. $F=\lbrace (r_1, r_2)|r_1\in F_1\ or\ r_2\in F_2\rbrace$

---

# 3 非确定性

## 3.1 (非)确定性自动机的定义
在一个自动机FA中，如果下一个状态是确定的，则称其为确定性自动机DFA，反之则为非确定自动机NFA。
> 形式地，一个NFA是一个五元组$(Q,\Sigma,\delta,q_0,F)$
> - $Q$是被称为状态的有限集合
> - $\Sigma$是被称为字母表的有限集合
> - $\delta$是状态转移函数$Q\times\Sigma_{\varepsilon}\to \mathcal{P}(Q)$
> - $q_0\in Q$是初始状态
> - $F\subseteq Q$是终止状态集
与在定义中，NFA与DFA最大的不同是第三条，DFA的状态转移函数是$Q\times\Sigma\to Q$，**转移后的状态是一个确定的状态**；NFA的状态转移函数$Q\times\Sigma_{\varepsilon}\to \mathcal{P}(Q)$，该函数**允许接收空操作$\varepsilon$，且转以后的状态是一个状态集合**。

## 3.2 NFA与DFA的等价性

所谓FA的等价，是指两个机器能识别相同的语言。

> **一个重要的定理：每一个NFA都有一个等价的DNA**
> **一个重要的推论：一个语言是正则的当且仅当存在NFA能识别它**

**等价性的证明(NFA到DFA的转换)**：

令$N=(Q,\Sigma,\delta,q_0,F)$是任意一个能识别语言$A$的NFA，我们可以构造一个对应的DFA $M=(Q',\Sigma',\delta',q_0',F')$来识别$A$:
1. 当$N$中不包含$\varepsilon$边时：
   1. $Q'=\mathcal{P}(Q)$，我们可以将$\mathcal{P}(Q)$构造为$Q$的幂集。
   2. $\delta(R,a)=\lbrace q\in Q|q\in\delta(r,a)\ for\ some\ r\in R\rbrace$
   3. $q_0'=\lbrace q_0\rbrace$
   4. $F'=\lbrace R\in Q'|R\ contains\ an\ accept\ state\ of\ N\rbrace$
2. 当$N$中包含$\varepsilon$边时：
   1. 对于$M$中的任意状态$R$，定义$E(R)$是一个集合，包含了所有从状态$R$通过$0$或多条$\varepsilon$边可以到达的状态
   2. $\delta'(R, a)=\lbrace q\in Q|q\in E(\delta(r,a))\ for\ some\ r\in R\rbrace$
   3. $q_0'=E(\lbrace q_0\rbrace)$

例如，给定如下的NFA：
<img src="2_1.png" width="40%" height="40%">
我们可以将其转换为对应的DFA:
1. 列出状态幂集
   <img src="2_2.png" width="60%" height="60%">
2. 因为$\Sigma=\lbrace a,b\rbrace$，我们需要对幂集中的每个状态画出其转移
   <img src="2_3.png" width="65%" height="65%">
3. 添加开始和结束
   <img src="2_4.png" width="65%" height="65%">
4. 删除没有入边的结点
   <img src="2_5.png" width="55%" height="55%">

同样的，我们也可以给出包含$\varepsilon$边NFA-DFA转换
<img src="2_6.png" width="40%" height="40%">
<img src="2_7.png" width="55%" height="55%">

通过该定理，我们可以证明正则语言封闭性:
1. $A_1\cup A_2$，我们可以构造如图的机器NFA $N$来识别。
   <img src="3_1.png" width="40%" height="40%">

   证明见上一节
2. $A_1\circ A_2$，我们可以构造如图的机器NFA $N$来识别。
   <img src="3_2.png" width="40%" height="40%">

    证明：
    令$N_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，$N2=\lbrace Q_2, \Sigma, \delta_2, q_2, F_2\rbrace$识别$A_2$，令$N=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$来识别$A_1\circ A_2$
    1. $Q=Q_1\cup Q_2$
    2. $q_0=q_1$
    3. $F=F_2$
    4. 定义状态转移函数$\delta$
       $$\delta(q,a)=\begin{cases}
        \delta_1(q,a) & q\in Q_1\ and\ q\not\in F_1 \\\\
        \delta_1(q,a) & q\in F_1\ and\ a\not=\varepsilon \\\\
        \delta_1(q,a)\cup\lbrace q_2\rbrace & q\in F_1\ and\ a=\varepsilon \\\\
        \delta_2(q,a) & q\in Q_2
        \end{cases}$$
3. $A^\ast$，我们可以构造如图的机器NFA $N$来识别。
   <img src="3_3.png" width="40%" height="40%">

   证明：令$N_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，构造$N=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$来识别$A_1^\ast$
   1. $Q=Q_1\cup \lbrace q_0\rbrace$
   2. $q_0$是新的开始状态
   3. $F=F_1\cup\lbrace q_0\rbrace$，新的开始状态也是结束状态
   4. 定义状态转移函数$\delta$
       $$\delta(q,a)=\begin{cases}
        \delta_1(q,a) & q\in Q_1\ and\ q\not\in F_1 \\\\
        \delta_1(q,a) & q\in F_1\ and\ a\not=\varepsilon \\\\
        \delta_1(q,a)\cup\lbrace q_1\rbrace & q\in F_1\ and\ a=\varepsilon \\\\
        \lbrace q_1\rbrace & q=q_0\ and\ a=\varepsilon \\\\
        \emptyset & q=q_0\ and\ a\not=\varepsilon
        \end{cases}$$


---

# 4. 正则语言与正则表达式的关系

## 4.1 定义
正则表达式是一种适用于各种编程语言的通用语法规则，用于描述正则语言。例如，对于正则表达式$(0\cup 1)^\ast$描述了所有由$0$和$1$组成的语言。
> 正则表达式的定义：
> 如果$R$满足以下条件之一，则$R$是正则表达式：
> 1. 符合定义的语言
> 2. $\lbrace\varepsilon\rbrace$
> 3. $\emptyset$
> 4. $R_1\cup R_2$，其中$R_1$和$R_2$都是正则表达式
> 5. $R_1\circ R_2$，其中$R_1$和$R_2$都是正则表达式
> 6. $R_1^\ast$, 其中$R_1$是正则表达式

几个重要的例子(令$\Sigma=\lbrace0, 1\rbrace$)：
- $0^\ast 10^\ast=\lbrace w|w仅包含一个1\rbrace$
- $\Sigma^\ast1\Sigma^\ast=\lbrace w|w至少包含一个1\rbrace$
- $(\Sigma\Sigma\Sigma)^\ast=\lbrace w|w的长度是3的倍数\rbrace$
- $(0\cup\varepsilon)(1\cup\varepsilon)=\lbrace\varepsilon,0,1,01\rbrace$
- $1^\ast\emptyset=\emptyset$，注意$\emptyset$代表不被任何FA接收，任意包含$\emptyset$的字符串都等价于$\emptyset$
- $\emptyset^\ast=\lbrace\varepsilon\rbrace$，这种情况十分特殊

## 4.2 两个引理

> 引理1：如果一个语言能被正则表达式描述，那么该语言是正则的

证明：
我们可以将正则表达式$R$转换为NFA，我们考虑六种情况
1. $R=a$, $a\in\Sigma$。那么$L(R)=\lbrace a\rbrace$，并且下图的NFA可以识别$L(R)$
   <img src="4_1.png" width="20%" height="20%">
2. $R=\varepsilon$,那么$L(R)=\lbrace\varepsilon\rbrace$，可以构造如下NFA
   <img src="4_2.png" width="10%" height="10%">
3. $R=\emptyset$，那么$L(R)=\emptyset$
   <img src="4_3.png" width="10%" height="10%">
4. $R=R_1\cup R_2$
5. $R=R_1\circ R_2$
6. $R=R_1^\ast$

相应的，给定一个正则表达式，我们可以构造出对应的NFA，例如$(ab\cup a)^\ast$
   <img src="4_4.png" width="80%" height="80%">

> 引理2：如果一个语言是正则的，那么它能被正则表达式描述