---
title: 形式语言与计算复杂性(一)：正则语言
date: 2021-06-23 15:00
# updated: 0000-00-00 10:00
mathjax: true
meta:
    date: true
categories: 
    - Mathematics
tags:
    - Lecture
---

{% post_link Mathematics/形式语言1 Lecture 0：绪论 %}
Lecture 1：正则语言

---

<!-- more -->

有限状态机是一个理想的计算机(或者称为计算模型)，可以通过正则语言来区分。其特点是内存极其有限。


# 1 有限状态机

> **定义**：
> 
> 有限状态机(DFA)是一个五元组$(Q,\Sigma,\delta,q_0,F)$
> - $Q$是被称为状态的有限集合
> - $\Sigma$是被称为字母表的有限集合
> - $\delta$是状态转移函数$Q\times\Sigma\to Q$
> - $q_0\in Q$是初始状态
> - $F\subseteq Q$是终止状态集

我们可以认为FA是一个内存大小仅为$1$的机器，该机器在每个时刻接收输入字符串(输入信号)$\Sigma$中的一个字符，并根据状态转移函数$\delta$来改变当前内存的状态。

<img src="fa-1.png" width="80%" height="80%">

## 1.1 有限状态机的作用

我们提出有限状态机的是为了求解特定类型的问题，更具体的说，FA是用于判断一个字符串是否属于一种语言。首先对问题进行定义：

**问题定义**

给定字符串集合$S$以及布尔函数$f:S\to\lbrace 0,1\rbrace$，$x\in S$，计算$f(x)$。更进一步地，可以将上述问题转换为：给定集合$A\subseteq S, x\in S$，计算$x\in A$是否成立。在该定义中$x\in A\Rightarrow f(x)=1$, $x\not\in A\Rightarrow f(x)=0$。

**问题求解**

给定一个布尔函数$f:S\to\lbrace{0,1}\rbrace$，$S$是基于字母表$\Sigma$的字符串集合(例如$S=\lbrace{0,10,010,...}\rbrace$), 语言${A}\subseteq{S}$是$S$的子集。 定义一个自动机$M$以及一种能被$M$识别的语言$L(M)=\lbrace{s}\in{S}|{M}\ {accepts}\ {s}\rbrace$，那么所有问题可以被形式化为布尔问题：给定${x}\in{S},{x}\in{A}$，求解${A}=L(M)$是否为真，即判断$A$是否是一种能被$M$识别的语言。

**有限状态机示例**

- 例1：
  <img src="ex1.png" width="50%" height="50%">

  $\Sigma=\lbrace 0, 1\rbrace, A=\lbrace w|w至少包含一个1且以偶数个0结尾\rbrace$

- 例2：
  <img src="ex2.png" width="30%" height="30%">

  $\Sigma=\lbrace 0, 1\rbrace, A=\lbrace w|w至少包含一个1且以1结尾\rbrace$

- 例3：
  <img src="ex3.png" width="30%" height="30%">

  $\Sigma=\lbrace 0, 1\rbrace, A=\lbrace w|w以偶数个(包括0个)0结尾\rbrace$

- 例4：
  <img src="ex4.png" width="50%" height="50%">

  $\Sigma=\lbrace a, b\rbrace, A=\lbrace w|w的开始符号与结束符号相同\rbrace$

- 例5：
  <img src="ex5.png" width="50%" height="50%">

  $\Sigma=\lbrace {0, 1, 2}\rbrace， A=\lbrace w|w的和是3的倍数\rbrace$

## 1.2 正则语言
>在以上的例子中,$A$就是正则语言。所谓**正则语言，就是能被某些有限自动机识别的语言。**而**识别**就是，给定机器$M$以及语言$A$，$A=\lbrace w|M\ accepts\ w\rbrace$

---

# 2 预备知识

## 2.1 有限自动机的设计

对于一个给定的正则语言$A$设计一个对应FA总共有四步操作，下面以一个例子来说明。

例：假设字符表$\Sigma=\lbrace 0,1\rbrace$，语言$A$是包含奇数个$1$的字符串集合。

1. 列出所有的可能性。在该例子中，一个字符串$x$只有两种可能：包含偶数个$1$或者包含奇数个$1$
   - even
   - odd
2. 将可能性表示为状态。
   <img src="1_2_1_1.png" width="20%" height="20%">
3. 标出状态转移箭头。该FA只能接受字母表$\Sigma$的信号，即$01$信号，且字符串$x$会随着输入信号改变奇偶性
   <img src="1_2_1_2.png" width="20%" height="20%">
4. 标出初始状态和结束状态
   <img src="1_2_1_3.png" width="20%" height="20%">

## 2.2 基于语言的运算

假定$A,B$为语言，我们可以定义基于语言的三种运算：
- Union: $A\cup B=\lbrace x|x\in A\ or\ x\in B\rbrace$
- Concatenation: $A\circ B=\lbrace xy|x\in A\ and\ y\in B\rbrace$
- Star: $A^{\ast}=\lbrace x_1...x_k|k\ge 0\ and\ x_i\in A\rbrace$，类似于幂集。

例如，$\Sigma=\lbrace a,...,z\rbrace$, $A=\lbrace good, bad\rbrace$, $\lbrace boy, girl\rbrace$，则有
- $A\cup B=\lbrace good, bad, boy, girl\rbrace$
- $A\circ B=\lbrace goodboy, goodgirl, badboy, badgirl\rbrace$
- $A^{\ast}=\lbrace \epsilon, good, bad, goodgood, goodbad, badgood, badbad, goodgoodgood, goodgoodbad,...\rbrace$

> 正则语言有一个重要的特性，即**封闭性**。所谓的封闭性是指对集合中的任意对象进行某种运算，如果其结果仍在该集合中，则称该集合在该操作上是封闭的。**正则语言在以上三种运算上是封闭的**，即，若$A_1,A_2$是正则语言，那么$A_1\cup A_2$、$A_1\circ A_2$和$A^{\ast}$也是正则语言。

我们可以通过构造法先证明正则语言在$\cup$运算上的封闭性

**构造法证明$A_1\cup A_2$的封闭性**<span id='prof1'></span>
假定$M_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，$M_2=\lbrace Q_2, \Sigma, \delta_2, q_2, F_2\rbrace$识别$A_2$，下面构造$M=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$来识别$A_1\cup A_2$
1. $Q=\lbrace(r_1, r_2)|r_1\in Q_1\ and\ r_2\in Q_2\rbrace$
2. 字母表$\Sigma$与$M_1,M_2$的字母表相同
3. $\delta((r_1, r_2),a) = (\delta_1(r_1,a), \delta_2(r_2, a))$
4. $q_0=(q_1,q_2)$
5. $F=\lbrace (r_1, r_2)|r_1\in F_1\ or\ r_2\in F_2\rbrace$

对于另外两种操作的证明需要引入新的概念，即非确定自动机NFA。

---

# 3 非确定性

## 3.1 非确定自动机NFA
在一个自动机FA中，如果下一个状态是确定的，则称其为确定自动机DFA，反之则为非确定自动机NFA。
> 形式地，一个NFA是一个五元组$(Q, \Sigma, \delta, q_0, F)$
> - $Q$是被称为状态的有限集合
> - $\Sigma$是被称为字母表的有限集合
> - $\delta$是状态转移函数$Q\times\Sigma_{\varepsilon}\to \mathcal{P}(Q)$
> - $q_0\in Q$是初始状态
> - $F\subseteq Q$是终止状态集

与在定义中，NFA与DFA最大的不同是第三条，DFA的状态转移函数是$Q\times\Sigma\to Q$，即**转移后的状态是一个确定的状态**；NFA的状态转移函数$Q\times\Sigma_{\varepsilon}\to \mathcal{P}(Q)$，该函数**允许接收空信号$\varepsilon$，且转移后的状态是一个状态集合**。下图就是一个NFA的例子，$q_1$在接收$1$后可以跳转到$q_1$或者$q_2$，而$q_2$则允许接收$\varepsilon$。

<img src="2_1_1.png" width="60%" height="60%">

## 3.2 NFA与DFA的等价性

所谓FA的等价，是指两个机器能识别相同的语言。

> **定理：每一个NFA都有一个等价的DNA**
> **推论：一个语言是正则的当且仅当存在NFA能识别它**

**等价性的证明**：

证明思路：将NFA转换为等价的DFA。

令$N=(Q,\Sigma,\delta,q_0,F)$是能识别语言$A$的NFA，我们可以构造一个对应的DFA $M=(Q',\Sigma',\delta',q_0',F')$来识别$A$:
1. $N$和$M$的字母表$\Sigma$相同。
2. 将$N$的状态集$Q'$构造为$Q'=\mathcal{P}(Q)$，$\mathcal{P}(Q)$为$Q$的幂集。
3. $N$的终止状态为$F'=\lbrace R\in Q'|R\ contains\ an\ accept\ state\ of\ N\rbrace$
4. 接下来考虑两种情况：
   1. 当$N$中不包含$\varepsilon$边时：
      1. $\delta'(R,a)=\lbrace q\in Q|q\in\delta(r,a)\ for\ some\ r\in R\rbrace$，其中$R$是$Q'$中的一个状态，$a$是一个输入信号。
      2. $q_0'=\lbrace q_0\rbrace$
   2. 当$N$中包含$\varepsilon$边时，对于$M$中的任意状态$R$，定义$E(R)$是一个包含了所有从$R$通过$0$或多条$\varepsilon$边可以到达的状态的集合：
      1. $\delta'(R, a)=\lbrace q\in Q|q\in E(\delta(r,a))\ for\ some\ r\in R\rbrace$
      2. $q_0'=E(\lbrace q_0\rbrace)$

基于以上方法可以将任意NFA转换为对应的DFA。例如，给定如下的不包含$\varepsilon$的NFA：

<img src="2_1.png" width="25%" height="25%">

我们可以将其转换为对应的DFA:
1. 列出状态幂集
   
   <img src="2_2.png" width="40%" height="40%">

2. 因为$\Sigma=\lbrace a,b\rbrace$，我们需要对幂集中的每个状态画出其状态转移
   
   <img src="2_3.png" width="45%" height="45%">

3. 添加开始和结束
   
   <img src="2_4.png" width="45%" height="45%">

4. 删除没有入边的结点
   
   <img src="2_5.png" width="35%" height="35%">

同样的，我们也可以给出包含$\varepsilon$边NFA-DFA转换

<center><img src="2_6.png" width="25%" height="25%" style="display: inline-block"><img src="2_7.png" width="45%" height="45%" style="display: inline-block"></center>

通过该定理，我们可以证明正则语言封闭性:
1. 构造如图的机器NFA $N$来识别$A_1\cup A_2$。
   <img src="3_1.png" width="40%" height="40%">

   证明见[前文证明](#prof1)
2. 构造如图的NFA $N$来识别$A_1\circ A_2$。
   <img src="3_2.png" width="40%" height="40%">

    证明：
    令$N_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，$N2=\lbrace Q_2, \Sigma, \delta_2, q_2, F_2\rbrace$识别$A_2$，令$N=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$
    1. $Q=Q_1\cup Q_2$
    2. $q_0=q_1$
    3. $F=F_2$
    4. 定义状态转移函数$\delta$
       $$\delta(q,a)=\begin{cases}
        \delta_1(q,a) & q\in Q_1\ and\ q\not\in F_1 \\\\
        \delta_1(q,a) & q\in F_1\ and\ a\not=\varepsilon \\\\
        \delta_1(q,a)\cup\lbrace q_2\rbrace & q\in F_1\ and\ a=\varepsilon \\\\
        \delta_2(q,a) & q\in Q_2
        \end{cases}$$
3. 构造如图的机器NFA $N$来识别$A^\ast$。
   <img src="3_3.png" width="40%" height="40%">

   证明：令$N_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，构造$N=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$
   1. $Q=Q_1\cup \lbrace q_0\rbrace$
   2. $q_0$是新的开始状态
   3. $F=F_1\cup\lbrace q_0\rbrace$，新的开始状态也是结束状态
   4. 定义状态转移函数$\delta$
       $$\delta(q,a)=\begin{cases}
        \delta_1(q,a) & q\in Q_1\ and\ q\not\in F_1 \\\\
        \delta_1(q,a) & q\in F_1\ and\ a\not=\varepsilon \\\\
        \delta_1(q,a)\cup\lbrace q_1\rbrace & q\in F_1\ and\ a=\varepsilon \\\\
        \lbrace q_1\rbrace & q=q_0\ and\ a=\varepsilon \\\\
        \emptyset & q=q_0\ and\ a\not=\varepsilon
        \end{cases}$$

---

# 4. 正则语言与正则表达式的关系

## 4.1 定义
我们可以使用正则运算$\cup,\circ, ^{\ast}$构建正则表达式，并描述正则语言。例如，对于正则表达式$(0\cup 1)^\ast$描述了所有由$0$和$1$组成的语言。
> 正则表达式的定义：
> 如果$R$满足以下条件之一，则$R$是正则表达式：
> 1. $\lbrace a\rbrace$, $a\in\Sigma$
> 2. $\lbrace\varepsilon\rbrace$
> 3. $\emptyset$
> 4. $R_1\cup R_2$，其中$R_1$和$R_2$都是正则表达式
> 5. $R_1\circ R_2$，其中$R_1$和$R_2$都是正则表达式
> 6. $R_1^\ast$, 其中$R_1$是正则表达式

几个重要的例子(令$\Sigma=\lbrace0, 1\rbrace$)：
- $0^\ast 10^\ast=\lbrace w|w仅包含一个1\rbrace$
- $\Sigma^\ast1\Sigma^\ast=\lbrace w|w至少包含一个1\rbrace$
- $(\Sigma\Sigma\Sigma)^\ast=\lbrace w|w的长度是3的倍数\rbrace$
- $(0\cup\varepsilon)(1\cup\varepsilon)=\lbrace\varepsilon,0,1,01\rbrace$
- $1^\ast\emptyset=\emptyset$，注意$\emptyset$代表不被任何FA接收，任意包含$\emptyset$的字符串都等价于$\emptyset$
- $\emptyset^\ast=\lbrace\varepsilon\rbrace$，这种情况十分特殊

## 4.2 正则表达式与FA的等价性

> 定理：一个语言是正则的，当且仅当存在一个正则表达式能描述它

下面，我们通过两个引理，来证明上述定理，即正则表达式与正则语言的等价性。

> 引理1：如果一个语言能被正则表达式描述，那么该语言是正则的

证明：
我们可以将任意正则表达式$R$转换为NFA，而NFA与FA是等价的，故而正则表达式与FA是等价的。考虑六种情况
1. $R=a$, $a\in\Sigma$。那么$L(R)=\lbrace a\rbrace$，并且下图的NFA可以识别$L(R)$
   
   <img src="4_1.png" width="10%" height="10%">

2. $R=\varepsilon$,那么$L(R)=\lbrace\varepsilon\rbrace$，可以构造如下NFA
   
   <img src="4_2.png" width="5%" height="5%">

3. $R=\emptyset$，那么$L(R)=\emptyset$
   
   <img src="4_3.png" width="5%" height="5%">

4. $R=R_1\cup R_2$
5. $R=R_1\circ R_2$
6. $R=R_1^\ast$

相应的，给定一个正则表达式，我们可以构造出对应的NFA，例如$(ab\cup a)^\ast$

   <img src="4_4.png" width="60%" height="60%">

> 引理2：如果一个语言是正则的，那么它能被正则表达式描述

对该引理的证明思路：DFA$\Rightarrow$GNFA$\Rightarrow$正则表达式

首先我们引入一个新的概念：广义NFA(Generalized NFA, GNFA)，如下图所示：

<img src="4_5.png" width="40%" height="40%">

GNFA有以下几个特点：
1. GNFA的转移信号，或者说边的label，可以是正则表达式、字母或者$\varepsilon$。
2. 开始状态与其他所有状态都由直接的转移关系，或者说有直接的边相连，且初始状态没有入边。
3. 只有一个结束状态，所有状态都直接与结束状态相连，结束状态没有出边。
4. 除了开始状态和结束状态，任意一个状态都会到达其他所有状态，且任意一个状态都有自身环转移。

给定一个DFA，我们可以通过以下几个步骤将其转换为GNFA：
1. 添加一个新的初始状态，并通过$\varepsilon$转移到旧的初始状态
2. 添加一个新的结束状态，并通过$\varepsilon$转移自旧的结束状态集
3. 如果两个结点之间存在多条方向相同的边，通过$\cup$将其合并为一条边
4. 如果两个状态之间没有边，则添加label为$\emptyset$的新边。

随后，通过逐个删除GNFA中的节点，并修改相应的边的label，直至GNFA中只剩开始结点和终止结点。这两个结点之间的边的label就是最终的正则表达式。下图是一个DFA转换为正则表达式的例子：

<img src="4_6.png" width="40%" height="40%">

一个更复杂的例子

<img src="4_7.png" width="60%" height="60%">

---

# 4. 非正则语言

FA的能力十分有限，大多数的语言都不能被FA所识别，例如$B=\lbrace 0^n1^n|n\ge0\rbrace$，机器需要记住目前为止读取了多少个$0$，而FA因为没有额外内存而无法做到这一点。对这样的语言，我们称为非正则语言。

首先介绍两个术语：pumping lemma以及pumping length

> **Pumping Lemma定理**
> 如果$A$是正则语言，那么存在一个数$p$(即pumping length)，当$s$是$A$中任意一个长度至少为$p$的子串时，$s$可以被分为三部分，即$s=xyz$，并且$s$满足以下三种情况
> 1. 对于任意$i\ge0, xy^iz\in A$
> 2. $|y|>0$，而$x$和$y$允许为$\varepsilon$
> 3. $|xy|\le p$，即$x$和$y$的总长度不超过$p$

> Pumping Length
> pumping length是指所有字符串都存在一个相邻子串，该部分可以被重复任意次，重复后的字符串仍然是该语言，这个子串的长度即为pumping length

## 4.1 Pumping Lemma的证明

令$M=(Q,\Sigma,\delta,q_0,F)$
- 令$p$是$M$的状态数，即$p=|Q|$
- $A$中任意字符串$s$都可转换为三部分$xyz$
- 如果$s$的长度$n$大于等于$p$，我们考虑$M$接收$s$时的状态序列：
  - 这个状态序列的长度为$n+1$(因为包含开始状态)，而$n\ge p$
  - 因此这状态序列肯定包含一个重复状态
  - 根据这个重复状态将$s$划分为$xyz$

## 4.2 举例

证明$B=\lbrace 0^n1^n|n\ge0\rbrace$不是正则的

**证明**
1. 假设$B$是正则的，那么$B$中存在pumping length $p$
2. 我们选择一个子串$0^p1^p$，并将该子串分为三部分$xyz$，由pumping lemma可知，对任意$i\ge0, xy^iz\in B$
3. 考虑三种情况
   1. 子串$y$由$0$组成，那么$xyz$中，$xy=0^i$，$z=0^{p-i}1^p$。现在考虑$xyyz$，多出来的$y$会导致$0$的个数多于$1$的个数，所以子串$y$不可能由$0$组成
   2. 子串$y$由$1$组成，同样的，会导致$1$的个数多于$0$的个数
   3. 子串$y$由$0$和$1$组成，那么$xyyz$中，$yy$的存在会导致$1$出现在$0$前的乱序，也是不可取的
4. 因此，无论怎么划分，划分后的子串都不属于$B$，因此$B$不是正则的。


# 第二次作业

1. The formal description of a DFA $M$ is $(\lbrace q_1,q_2,q_3,q_4,q_5\rbrace,\lbrace u,d\rbrace, \delta, q_3, \lbrace q_3\rbrace)$, where $\delta$ is given by the following table. Give the state diagram of this machine.
   
   |  |$u$|$d$|
   |-|-|-|
   $q_1$|$q_1$|$q_2$|
   $q_2$|$q_1$|$q_3$|
   $q_3$|$q_2$|$q_4$|
   $q_4$|$q_3$|$q_5$|
   $q_5$|$q_4$|$q_6$|

   **Answer**

   <img src="e1.png" width="60%" height="60%">

2. Give state diagrams of DFAs recognizing the following languages. In all parts, the alphabet is $\lbrace 0, 1\rbrace$
   1. $\lbrace w|w\ begins\ with\ a\ 1\ and\ ends\ with\ a\ 0\rbrace$
   2. $\lbrace w|w\ contains\ at\ least\ three\ 1s\rbrace$
   3. $\lbrace w|w\ contains\ the\ substring\ 0101(i.e.,\ w=x0101y\ for\ some\ x\ and\ y)\rbrace$
   
   **Answer**
   1. <img src="e21.png" width="35%" height="35%">
   ---
   2. <img src="e22.png" width="50%" height="50%">
   ---
   3. <img src="e23.png" width="60%" height="60%">

3. Use the construction given in Theorem 1.39 to convert the following two NFA to equivalent DFA.
   
   <img src="e3.png" width="35%" height="35%">

   **Answer**
   1. <img src="e31.png" width="35%" height="35%">
   ---
   2. <img src="e32.png" width="40%" height="40%">
   
4. Use the procedure described in Lemma 1.60 to convert the following finite automata to regular expresssions.
   
   <img src="e4.png" width="40%" height="40%">

   **Answer**
   1. <img src="e41.png" width="70%" height="70%">
   ---
   3. <img src="e42.png" width="80%" height="80%">

5. Use the pumping lemma to show that the following languages are not regular.
   $A_1=\lbrace 0^n1^n2^n|n\ge0\rbrace$

   **Answer**
   1. 假定$A_1$是正则的，那么$A_1$肯定存在pumping length，假设为$p$，考虑字符串$s=0^p1^p2^p\in A_1$
   2. 因为$A_1$是正则的，根据pumping lemma，$s$可以被分为$xyz$三部分，且对任意$i\ge0$，有$xy^i\in A_1$
   3. 现考虑以下几种情况：
      1. 子串$y$全由$0$组成，则$x=0^i,y=0^j,z=0^{p-i-j}1^p2^p$，那么$xyyz=0^{p+j}y^pz^p$，$0$的个数多于$1$和$2$，不属于$A_1$
      2. 子串$y$全由$1$组成，同上
      3. 子串$y$全由$2$组成，同上
      4. 子串$y$由$0$和$1$组成，则$xyyz$中会出现$1$在$0$前的乱序
      5. 子串$y$由$1$和$2$组成，同上
      6. 子串$y$由$1$、$2$和$3$组成，同上
      7. 子串$y$由$1$和$3$组成，不符合$A_1$语法
   4. 因此无论什么情况，$s$都不符合$A_1$语法，因此$A_1$不符合pumping lemma，故其为非正则语言。