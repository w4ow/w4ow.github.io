---
title: 形式语言与计算复杂性(一)：正则语言
date: 2021-06-23 15:00
# updated: 0000-00-00 10:00
mathjax: true
meta:
    date: true
categories: 
    - Mathematics
tags:
    - Lecture
---

{% post_link Mathematics/形式语言1 Lecture 0：绪论 %}
Lecture 1：正则语言
{% post_link Mathematics/形式语言3 Lecture 2：上下文无关语言 %}<br>
{% post_link Mathematics/形式语言4 Lecture 3：Church-Turing %}<br>
{% post_link Mathematics/形式语言5 Lecture 4：可判定性 %}<br>
{% post_link Mathematics/形式语言6 Lecture 5：可规约性 %}<br>
{% post_link Mathematics/形式语言7 Lecture 6：时间复杂度 %}
---

<!-- more -->

# 1 有限自动机

有限自动机(Finite Antomata, FA)是本课程中所涉及到的最简单的“计算机”，我们可以认为FA是一个内存大小仅为$1$的计算机，FA在该每个时刻接收输入信号(即$\Sigma$中的字母)，并根据状态转移函数$\delta$来改变当前内存的状态。比如我们日常生活中的空调，我们就可以将其简化为包含开/关两个状态的FA，并可根据遥控器开关信号来改变当前状态。

> **FA形式化定义**：
> 
> 有限状态机(FA)是一个五元组$(Q,\Sigma,\delta,q_0,F)$
> - $Q$是被称为状态的有限集合
> - $\Sigma$是被称为字母表的有限集合，代表FA的输入信号
> - $\delta$是状态转移函数$Q\times\Sigma\to Q$
> - $q_0\in Q$是初始状态
> - $F\subseteq Q$是终止状态集

我们提出FA是为了求解特定类型的问题，更具体的说是关于“语言”的问题。**所谓的语言，在形式上是字符串的集合$A=\lbrace w|w\in\Sigma^\ast\rbrace$**(语言是字母表幂集的子集)，而我们在这门课所要学习的就是:给定一个能识别特定语言$A$的机器$M$，判断一个字符串$w$是否能被$M$**识别**。举个更贴地气的例子，我们可以把语言比作我们人类所使用的语言(如汉语)，把机器$M$比作一个人(比如会汉语和英语的小明)。我们现在对小明输入了一个字符串$w$，如果$w$是一句俄语，那么小明自然无法识别，普通话则反之。

一些简单的语言可以用FA来表示，我们称这类能被FA识别的语言为**正则语言(Regular Language, RL)**。例如语言$A=\lbrace w|w至少包含一个1且以偶数个0结尾\rbrace$(如$100,0100,0110000$)就是一个正则语言，我们可以构造如下图的FA来识别$A$，即$L(M)=A$，随后我们就可以输入任意字符串$w$，来判断$w$是否能被$M$识别。

<img src="fa-1.png" width="60%" height="60%">

- 例2：$A=\lbrace w|w至少包含一个1且以1结尾\rbrace$
  
  <img src="ex2.png" width="25%" height="25%">

- 例3：$A=\lbrace w|w以0结尾\rbrace$
  
  <img src="ex3.png" width="25%" height="25%">

- 例4：$A=\lbrace w|w的开始符号与结束符号相同\rbrace$
  
  <img src="ex4.png" width="40%" height="40%">

- 例5：$A=\lbrace w|w的和是3的倍数\rbrace$
  
  <img src="ex5.png" width="45%" height="45%">

---

# 2 FA的构造与相关性质 

## 2.1 构造FA

那么，给定一个正则语言$A$，如何设计对应的FA呢？总共有四个步骤，我们以语言$A=\lbrace w|w包含奇数个1\rbrace$为例说明(这个过于简单，其实挺难的)：

1. 列出所有可能，本例中就俩可能：奇数个$1$或偶数个$1$(实际上对大部分正则语言都很难列出所有可能，例如上面4个例子，凭空想出所有可能非常人所能)
2. 将所有可能表示为状态：$q_{odd}$和$q_{even}$，并画为结点。
3. 在结点之间标出状态转移。例如本例中，$q_{even}$接收了$1$则会转移到$q_{odd}$。
4. 标出初始状态和结束状态。本例中，开始时$w$为空，也就是偶数个$1$，所以开始状态为$q_{even}$，而我们希望$w$最终为奇数个$1$，所以终止状态为$q_{odd}$。
   <img src="1_2.png" width="25%" height="25%">
在实际应用中，如果不事先给出所有状态，我们很难应用这个方法，在后面的习题中就可以看出来。

## 2.2 基于语言的运算

假定$A,B$为任意语言语言，我们可以定义基于语言的三种运算：
- Union: $A\cup B=\lbrace x|x\in A\ or\ x\in B\rbrace$
- Concatenation: $A\circ B=\lbrace xy|x\in A\ and\ y\in B\rbrace$
- Star: $A^{\ast}=\lbrace x_1...x_k|k\ge 0\ and\ x_i\in A\rbrace$，类似于幂集。

例如，$\Sigma=\lbrace a,...,z\rbrace$, $A=\lbrace good, bad\rbrace$, $B=\lbrace boy, girl\rbrace$，则有
- $A\cup B=\lbrace good, bad, boy, girl\rbrace$
- $A\circ B=\lbrace goodboy, goodgirl, badboy, badgirl\rbrace$
- $A^{\ast}=\lbrace \epsilon, good, bad, goodgood, goodbad, \cdots\rbrace$

> 正则语言有一个重要的特性，即**封闭性**。所谓的封闭性是指对集合中的任意对象进行某种运算，如果其结果仍在该集合中，则称该集合在该操作上是封闭的(例如在自然数集合$\mathcal{N}$上，加法和乘法操作是封闭的)。**正则语言在以上三种运算上是封闭的**，即，若$A_1,A_2$是正则语言，那么$A_1\cup A_2$、$A_1\circ A_2$和$A^{\ast}$也是正则语言。

我们可以通过构造法先证明正则语言在$\cup$运算上的封闭性

**构造法证明$A_1\cup A_2$的封闭性**<span id='prof1'></span>
假定$M_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，$M_2=\lbrace Q_2, \Sigma, \delta_2, q_2, F_2\rbrace$识别$A_2$，下面构造$M=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$来识别$A_1\cup A_2$
1. $Q=\lbrace(r_1, r_2)|r_1\in Q_1\ \mathrm{and}\ r_2\in Q_2\rbrace$
2. 三个FA的字母表相同，都为$\Sigma$
3. $\delta((r_1, r_2),a) = (\delta_1(r_1,a), \delta_2(r_2, a))$
4. $q_0=(q_1,q_2)$
5. $F=\lbrace (r_1, r_2)|r_1\in F_1\ or\ r_2\in F_2\rbrace$

证明另外两种操作的封闭性需要引入新的概念，非确定自动机NFA。

---

# 3 非确定自动机

## 3.1 NFA与DFA

前两节我们所涉及的都是确定的自动机，在一个自动机FA中，当前状态在接受了一个信号后，如果所转移的下一个状态是确定的，则称其为确定自动机DFA，反之则为非确定自动机NFA。

> 形式地，一个NFA是一个五元组$(Q, \Sigma, \delta, q_0, F)$
> - $Q$是被称为状态的有限集合
> - $\Sigma$是被称为字母表的有限集合
> - $\delta$是状态转移函数$Q\times\Sigma_{\varepsilon}\to \mathcal{P}(Q)$
> - $q_0\in Q$是初始状态
> - $F\subseteq Q$是终止状态集

NFA与DFA最大的不同在于，DFA的状态转移函数是$Q\times\Sigma\to Q$，即**转移后的状态是一个确定的状态**；NFA的状态转移函数$Q\times\Sigma_{\varepsilon}\to \mathcal{P}(Q)$，该函数**允许接收空信号$\varepsilon$，且转移后的状态是一个状态集合**。下图就是一个NFA的例子，$q_1$在接收$1$后可以跳转到$q_1$或者$q_2$，而$q_2$则允许接收$\varepsilon$。

<img src="2_1_1.png" width="60%" height="60%">

尽管NFA与DFA看起来有很大不同，但实际上两者的表达能力是完全相同的，而且对任意一个NFA，都可以将其转换为等价的DFA。首先我们给出一个定理以及一个推理：
> **定理：每一个NFA都有一个等价的DFA。等价是指两个机器能识别相同的语言。**
> **推论：一个语言是正则的当且仅当存在NFA能识别它**<span id='lemma1'></span>

随后，我们给出如何构造与NFA等价的DFA的方法，这个方法可以将任意NFA转换为DFA，因此该方法**也是对上述定理的证明**：

**构造与NFA等价的DFA**：

令$N=(Q,\Sigma,\delta,q_0,F)$是能识别语言$A$的NFA，我们可以构造一个对应的DFA $M=(Q',\Sigma,\delta',q_0',F')$来识别$A$:
1. $N$和$M$的字母表$\Sigma$相同。
2. 令$M$的状态集$Q'=\mathcal{P}(Q)$，即$Q$的幂集。
3. $M$的终止状态为$F'=\lbrace R\in Q'|R\ \mathrm{contains\ an\ accept\ state\ of}\ N\rbrace$，即$Q'$中所有包含$F$中的任意状态的集合。
4. 对于转移函数$\delta'$和开始状态$q_0'$，我们考虑两种情况：
   1. 当$M$中不包含$\varepsilon$边时：
      1. $\delta'(R,a)=\lbrace q\in Q|q\in\delta(r,a)\ \mathrm{for\ some}\ r\in R\rbrace$，其中$R$是$Q'$中的一个状态，$a$是一个输入信号。
      2. $q_0'=\lbrace q_0\rbrace$
   2. 当$M$中包含$\varepsilon$边时，对于$M$中的任意状态$R$，定义$E(R)$是一个包含了所有从$R$通过$0$或多条$\varepsilon$边可以到达的状态的集合：
      1. $\delta'(R, a)=\lbrace q\in Q|q\in E(\delta(r,a))\ \mathrm{for\ some}\ r\in R\rbrace$
      2. $q_0'=E(\lbrace q_0\rbrace)$
5. (可选)最后删除所有没有入边的状态及其出边，因为没有入边的状态是无法到达的。

基于以上方法可以将任意NFA转换为对应的DFA。例如，给定如下的不包含$\varepsilon$的NFA，我们可以将其转换为对应的DFA:

<img src="2_1.png" width="20%" height="20%">

1. 列出状态幂集
   
   <img src="2_2.png" width="30%" height="30%">

2. 对幂集中的每个状态画出其状态转移。可以看到在NFA中状态$2$通过信号$a$可以转移到$2$或$3$两个状态，因此在DFA中$2$需要转移到$\lbrace2,3\rbrace$状态，其余类推。
   
   <img src="2_3.png" width="30%" height="30%">

3. 添加开始和结束
   
   <img src="2_4.png" width="30%" height="30%">

4. 删除没有入边的结点
   
   <img src="2_5.png" width="25%" height="25%">

同样的，我们也可以给出包含$\varepsilon$边NFA-DFA转换

<center><img src="2_6.png" width="20%" height="20%" style="display: inline-block"><img src="2_7.png" width="45%" height="45%" style="display: inline-block"></center>

## 3.2 正则语言封闭性证明

通过该定理，我们可以证明正则语言封闭性:
1. 构造如图的NFA $N$来识别$A_1\cup A_2$。
   
   <img src="3_1.png" width="40%" height="40%">

   证明见[前文](#prof1)
2. 构造如图的NFA $N$来识别$A_1\circ A_2$。
   
   <img src="3_2.png" width="45%" height="45%">

    证明：
    令$N_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，$N2=\lbrace Q_2, \Sigma, \delta_2, q_2, F_2\rbrace$识别$A_2$，令$N=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$
    1. $Q=Q_1\cup Q_2$
    2. $q_0=q_1$
    3. $F=F_2$
    4. 定义状态转移函数$\delta$
       $$\delta(q,a)=\begin{cases}
        \delta_1(q,a) & q\in Q_1\ \mathrm{and}\ q\not\in F_1 \\\\
        \delta_1(q,a) & q\in F_1\ \mathrm{and}\ a\not=\varepsilon \\\\
        \delta_1(q,a)\cup\lbrace q_2\rbrace & q\in F_1\ \mathrm{and}\ a=\varepsilon \\\\
        \delta_2(q,a) & q\in Q_2
        \end{cases}$$
3. 构造如图的NFA $N$来识别$A^\ast$。
   
   <img src="3_3.png" width="46%" height="46%">

   证明：令$N_1=\lbrace Q_1, \Sigma, \delta_1, q_1, F_1\rbrace$识别$A_1$，构造$N=\lbrace Q, \Sigma, \delta, q_0, F\rbrace$
   1. $Q=Q_1\cup \lbrace q_0\rbrace$
   2. $q_0$是新的开始状态
   3. $F=F_1\cup\lbrace q_0\rbrace$，新的开始状态也是结束状态
   4. 定义状态转移函数$\delta$
       $$\delta(q,a)=\begin{cases}
        \delta_1(q,a) & q\in Q_1\ \mathrm{and}\ q\not\in F_1 \\\\
        \delta_1(q,a) & q\in F_1\ \mathrm{and}\ a\not=\varepsilon \\\\
        \delta_1(q,a)\cup\lbrace q_1\rbrace & q\in F_1\ \mathrm{and}\ a=\varepsilon \\\\
        \lbrace q_1\rbrace & q=q_0\ \mathrm{and}\ a=\varepsilon \\\\
        \emptyset & q=q_0\ \mathrm{and}\ a\not=\varepsilon
        \end{cases}$$

---

# 4. 正则表达式

正则表达式是用于描述正则语言的一套符号系统，该符号系统由$\Sigma$和正则运算$\cup,\circ, ^{\ast}$构成。例如，对于正则表达式$(0\cup 1)^\ast$描述了所有由$0$和$1$组成的语言。

## 4.1 定义
> **正则表达式**：<span id='def1'></span>
> 如果$R$满足以下条件之一，则$R$是正则表达式：
> 1. $\lbrace a\rbrace$, $a\in\Sigma$。即一个字母表$\Sigma$中的字母就是一个最简单的正则表达式
> 2. $\lbrace\varepsilon\rbrace$
> 3. $\emptyset$
> 4. $R_1\cup R_2$，其中$R_1$和$R_2$都是正则表达式
> 5. $R_1\circ R_2$，其中$R_1$和$R_2$都是正则表达式
> 6. $R_1^\ast$, 其中$R_1$是正则表达式

几个重要的例子(令$\Sigma=\lbrace0, 1\rbrace$)：
- $0^\ast 10^\ast=\lbrace w|w仅包含一个1\rbrace$
- $\Sigma^\ast1\Sigma^\ast=\lbrace w|w至少包含一个1\rbrace$
- $(\Sigma\Sigma\Sigma)^\ast=\lbrace w|w的长度是3的倍数\rbrace$
- $(0\cup\varepsilon)(1\cup\varepsilon)=\lbrace\varepsilon,0,1,01\rbrace$
- $1^\ast\emptyset=\emptyset$，注意$\emptyset$代表不被任何FA接收，任意包含$\emptyset$的字符串都等价于$\emptyset$
- $\emptyset^\ast=\lbrace\varepsilon\rbrace$，这种情况十分特殊

## 4.2 正则表达式与FA的等价性

正则表达式与FA都会用于描述正则语言的一种形式化的方式，且正则表达式与FA等价的，换句话说，NFA$\equiv$DFA$\equiv$正则表达式$\equiv$正则语言。

> 定理：一个语言是正则的，当且仅当存在一个正则表达式能描述它

下面，我们通过两个引理，来证明上述定理，即正则表达式与正则语言的等价性。

### 4.2.1 正则表达式转换为NFA

> 引理1：如果一个语言能被正则表达式描述，那么该语言是正则的

证明：
我们可以将任意描述语言的正则表达式$R$转换为NFA，而N由前面的[NFA-RL等价定理](#lemma1)可知NFA能识别的语言是正则的。考虑我们根据[正则表达式的定义](#def1)给出6条正则表达式-NFA转换规则:
1. $R=a$, $a\in\Sigma$。那么$L(R)=\lbrace a\rbrace$，并且下图的NFA可以识别$L(R)$
   
   <img src="4_1.png" width="10%" height="10%">

2. $R=\varepsilon$,那么$L(R)=\lbrace\varepsilon\rbrace$，可以构造如下NFA
   
   <img src="4_2.png" width="5%" height="5%">

3. $R=\emptyset$，那么$L(R)=\emptyset$
   
   <img src="4_3.png" width="5%" height="5%">

4. $R=R_1\cup R_2$
5. $R=R_1\circ R_2$
6. $R=R_1^\ast$

根据以上转换规则，我们可以尝试转换一个正则表达式，例如$(ab\cup a)^\ast$

   <img src="4_4.png" width="45%" height="45%">

### 4.2.2 DFA转换为正则表达式

> 引理2：如果一个语言是正则的，那么它能被正则表达式描述

首先我们引入一个新的概念：广义NFA(Generalized NFA, GNFA)，如下图所示：

<img src="4_5.png" width="35%" height="35%">

GNFA有以下几个特点：
1. GNFA的转移信号，或者说边的label，可以是正则表达式、字母或者$\varepsilon$。
2. 开始状态与其他所有状态都由直接的转移关系，或者说有直接的边相连，且初始状态没有入边。
3. 只有一个结束状态，所有状态都直接与结束状态相连，结束状态没有出边。
4. 除了开始状态和结束状态，任意一个状态都会到达其他所有状态，且任意一个状态都有自身环转移。

有了GNFA，我们可以通过DFA$\Rightarrow$GNFA$\Rightarrow$正则表达式来证明上述引理。给定一个DFA，我们可以通过以下几个步骤将其转换为GNFA：
1. 添加一个新的初始状态，并通过$\varepsilon$转移到旧的初始状态
2. 添加一个新的结束状态，并通过$\varepsilon$转移自旧的结束状态集
3. 如果两个结点之间存在多条方向相同的边，通过$\cup$将其合并为一条边
4. 如果两个状态之间没有边，则添加label为$\emptyset$的新边。

构造完成GNFA后，我们逐个删除GNFA中的节点，并修改相应的边的label，直至GNFA中只剩开始结点和终止结点。这两个结点之间的边的label就是最终的正则表达式。下图是一个DFA转换为正则表达式的例子：

<img src="4_6.png" width="40%" height="40%">

一个更复杂的例子

<img src="4_7.png" width="60%" height="60%">

---

# 4. 非正则语言

FA的能力十分有限，大多数的语言都不能被FA所识别，例如$B=\lbrace 0^n1^n|n\ge0\rbrace$，机器需要记住目前为止读取了多少个$0$，而FA因为没有额外内存而无法做到这一点。对这样的语言，我们称为非正则语言。给定一个语言，如何判定它是否正则呢？这时就轮到pumping lemma出场了

## 4.1 Pumping Lemma

> **Pumping Length**
> pumping length是指：同一个语言内的所有字符串都存在一个特殊的子串，该子串可以被重复任意次，重复后的字符串仍然属于该语言，这个子串的长度即为pumping length
> <br>
> **Pumping Lemma**
> 如果$A$是正则语言，那么存在一个数$p$(即pumping length)，当$s$是$A$中任意一个长度至少为$p$的子串时，$s$可以被分为三部分，即$s=xyz$，并且$s$满足以下三个性质
> 1. 对于任意$i\ge0, xy^iz\in A$
> 2. $|y|>0$，$x$和$y$允许为$\varepsilon$
> 3. $|xy|\le p$，即$x$和$y$的总长度不超过$p$

**Pumping Lemma的证明**
令$M=(Q,\Sigma,\delta,q_0,F)$
- 令$p$是$M$的状态数，即$p=|Q|$
- $A$中任意长度至少为$p$字符串$s$都可划分为三部分$xyz$
- 对$s$，我们考虑$M$接收$s$时的**状态序列**：假设这个状态序列的长度为$n+1$(因为包含开始状态)，而$n\ge p$，因此这状态序列肯定包含一个重复状态$p_r$。我们可以根据这个重复状态将$s$划分为$xyz$，其中$x$是第一个$p_r$之前的状态序列，$y$是两个$p_r$之间的状态序列，$z$是第二个$p_r$之后的状态序列。因为$y$从$p_r$出发最终又回到$p_r$，因此它重复任意次，该字符串依然属于该语言。
  
## 4.2 非正则语言的证明

证明语言$B=\lbrace 0^n1^n|n\ge0\rbrace$不是正则的

**证明**
1. 假设$B$是正则的，那么$B$中存在pumping length $p$
2. 我们选择一个子串$0^p1^p$，并将该子串分为三部分$xyz$，由pumping lemma可知，对任意$i\ge0, xy^iz\in B$
3. 考虑三种情况
   1. 子串$y$由$0$组成，那么$xyz$中，$xy=0^i$，$z=0^{p-i}1^p$。现在考虑$xyyz$，多出来的$y$会导致$0$的个数多于$1$的个数，所以子串$y$不可能由$0$组成
   2. 子串$y$由$1$组成，同样的，会导致$1$的个数多于$0$的个数
   3. 子串$y$由$0$和$1$组成，那么$xyyz$中，$yy$的存在会导致$1$出现在$0$前的乱序，也是不可取的
4. 因此，无论怎么划分，划分后的子串都不属于$B$，因此语言$B$不是正则的。

---

# 第二次作业

1. The formal description of a DFA $M$ is $(\lbrace q_1,q_2,q_3,q_4,q_5\rbrace,\lbrace u,d\rbrace, \delta, q_3, \lbrace q_3\rbrace)$, where $\delta$ is given by the following table. Give the state diagram of this machine.
   
   |  |$u$|$d$|
   |-|-|-|
   $q_1$|$q_1$|$q_2$|
   $q_2$|$q_1$|$q_3$|
   $q_3$|$q_2$|$q_4$|
   $q_4$|$q_3$|$q_5$|
   $q_5$|$q_4$|$q_6$|

   **Answer**

   <img src="e1.png" width="60%" height="60%">

2. Give state diagrams of DFAs recognizing the following languages. In all parts, the alphabet is $\lbrace 0, 1\rbrace$
   1. $\lbrace w|w\ begins\ with\ a\ 1\ and\ ends\ with\ a\ 0\rbrace$
   2. $\lbrace w|w\ contains\ at\ least\ three\ 1s\rbrace$
   3. $\lbrace w|w\ contains\ the\ substring\ 0101(i.e.,\ w=x0101y\ for\ some\ x\ and\ y)\rbrace$
   
   **Answer**
   1. <img src="e21.png" width="35%" height="35%">
   ---
   2. <img src="e22.png" width="50%" height="50%">
   ---
   3. <img src="e23.png" width="60%" height="60%">

3. Use the construction given in Theorem 1.39 to convert the following two NFA to equivalent DFA.
   
   <img src="e3.png" width="35%" height="35%">

   **Answer**
   1. <img src="e31.png" width="21%" height="21%">
   ---
   2. <img src="e32.png" width="30%" height="30%">
   
4. Use the procedure described in Lemma 1.60 to convert the following finite automata to regular expresssions.
   
   <img src="e4.png" width="40%" height="40%">

   **Answer**
   1. <img src="e41.png" width="70%" height="70%">
   ---
   2. <img src="e42.png" width="80%" height="80%">

5. Use the pumping lemma to show that the following languages are not regular.
   $A_1=\lbrace 0^n1^n2^n|n\ge0\rbrace$

   **Answer**
   1. 假定$A_1$是正则的，那么$A_1$肯定存在pumping length，假设为$p$，考虑字符串$s=0^p1^p2^p\in A_1$
   2. 因为$A_1$是正则的，根据pumping lemma，$s$可以被分为$xyz$三部分，且对任意$i\ge0$，有$xy^i\in A_1$
   3. 现考虑以下几种情况：
      1. 子串$y$全由$0$组成，则$x=0^i,y=0^j,z=0^{p-i-j}1^p2^p$，那么$xyyz=0^{p+j}y^pz^p$，$0$的个数多于$1$和$2$，不属于$A_1$
      2. 子串$y$全由$1$组成，同上
      3. 子串$y$全由$2$组成，同上
      4. 子串$y$由$0$和$1$组成，则$xyyz$中会出现$1$在$0$前的乱序
      5. 子串$y$由$1$和$2$组成，同上
      6. 子串$y$由$1$、$2$和$3$组成，同上
      7. 子串$y$由$1$和$3$组成，不符合$A_1$语法
   4. 因此无论什么情况，$s$都不符合$A_1$语法，因此$A_1$不符合pumping lemma，故其为非正则语言。