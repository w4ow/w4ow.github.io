---
title: 死锁问题
date: 2015-03-16 14:12
updated: 2015-03-16 14:12
mathjax: true
meta:
    date: false
categories: 
    - Computer Science
    - Operating System
tags:
    - Deadlock
---

关于死锁的一些归纳和总结

---

<!-- more -->

## 1. 死锁产生的原因和必要条件

进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。

1. 可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。
2. 不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。

因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点：

1. 系统资源不足。这是**根本原因**，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时；
2. 进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。

对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4：

1. 互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用；
2. 请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源；
3. 不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占；
4. 循环等待。若干个进程形成循环等待链。

## 2. 死锁的预防

通过破坏死锁的必要条件来控制死锁的策略称为**死锁预防**，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。

1. 破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的**优点是安全简单易实现**，**缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源**。
2. 破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。**缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”**。
3. 破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。**缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高**。

## 3. 死锁的避免

与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的**前提是每个进程清除自己需要多少资源**，因此死锁避免还是有局限性的。

1. 系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全；
2. 银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。

## 4. 银行家算法

银行家算法有5种数据结构：

1. 系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲；
2. 最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k；
3. 分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数；
4. 需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源；
5. 请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。

当某个进程i对j类资源提出k个请求是，需要**按照下列步骤检查**：

1. 若$Request[j]<=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错；
2. 若$Request[j]<=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i；
3. 系统进行试探性分配，并修改相应的表：
    - Available[j] -= Request[j];
    - Allocation[i][j] += Request[j];
    - Need[i][j] -= Request[j];
4. 调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。

**判断当前状态是否安全**

添加两个数组：

- Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa；
- Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。

检查当前状态的完整过程如下：

1. 初始化Work和Finish。Work[j]=Available[j], Finish[i]=false;
2. 在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4:
    - Finish[h] = false;
    - Need[h][j] <= Work[j]
3. 由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2
4. 若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。

## 5. 死锁检测

## 6. 死锁解除