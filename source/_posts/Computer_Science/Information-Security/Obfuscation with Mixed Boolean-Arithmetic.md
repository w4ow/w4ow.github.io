---
title: 基于Mixed Boolean-Arithmetic的混淆
date: 2019-09-16 13:00
updated: 2019-10-11 16:41
mathjax: true
meta:
    date: false
categories: 
    - Computer Science
    - Information Security
tags:
    - MBA Obfuscation
---

基础介绍

---

<!-- more -->

## Introduction

软件保护用于保护程序免受不必要的分析，程序混淆是软件保护的一种手段。**程序混淆**是指对代码进行转换使程序变的难以理解。混淆以两种主要方式隐藏程序的语义：1.改变code和data(例如，改变数据的值)，2.添加无关信息(例如垃圾代码)。MBA(Mixed Boolean-Arithmetic)混淆技术结合两种方法来混淆常见的数学表达式，例如重写运算符、引入新的运算符和常量等。

## 1. Background

### 1.1 程序混淆的定义及应用

**混淆是对程序的动态转换行为，其目的是使程序的分析变的困难，同时保证程序的可观察性**。

混淆通常有四个属性：

- 功能：混淆后的程序必须具有与原始程序相同的功能；
- 效率：与原始程序相比，混淆后的程序的大小和执行时间必须是可接受的；
- 健壮性：混淆程序必须比原始程序更难分析；
- 正确性：混淆后的程序应当与源程序有相同的语义和功能。

软件混淆应用领域包括软件加密、打包、反调试或防篡改等，应用范围包括但不限于：

- 恶意检测：避免恶意软件的恶意检测；
- 保护知识产权：保护商业软件中的算法或协议；
- 权限管理：无论是通过许可检查来保护对软件的访问，还是通过数字版权管理(DRM)方案保护数字内容，这些技术通常都会嵌入关键信息(例如加密密钥和协议)，并且使用混淆来保护这些信息。嵌入在程序中的DRM方案(例如VOD服务或视频游戏保护)目前是现代环境中混淆的主要来源之一；
- 保护个人敏感数据：例如，在移动应用程序中，设备中保存了大量敏感数据(例如银行帐户详细信息)。混淆可以保护这些数据以及处理数据的协议。

### 1.2 理论混淆和实际混淆

#### 1.2.1 密码混淆

密码混淆旨在为混淆提供一个正式的上下文，特别是围绕量化分析给定程序$P$的混淆程序$\mathcal O(P)$的难度。

软件混淆的正式研究由Barak等人发起，他们引入了虚拟黑匣子(VBB)的概念作为混淆程序的最佳属性。VBB保证任何可以从程序$\mathcal O(P)$的输入/输出行为中学到的，从$P$中也可以学到。 Barak提出了**不可区分混淆**的定义：如果两个相同大小的程序P1和P2实现相同的功能，则它们的混淆$\mathcal O(P_1)$和$\mathcal O(P_2)$应无法区分。

Goldwasser等人提供了**最佳可能混淆**的定义：从$\mathcal O(P)$中提取的任何信息都可以通过类似大小的其他功能相同的的程序取得。 他们还证明，对于有效的混淆器，不可区分混淆和最佳混淆是等价的。

2013年，Garg等人提出了通用的不可区分混淆，该混淆基于三个组成部分：作为计算模型的分支程序，完全同态加密和多线性映射。

#### 1.2.2 实际混淆

密码混淆在实际上难以应用，因此商用混淆一般都是基于不同程序转换的组合。一些最常用的商用混淆有strong.protect和Arxan3。混淆主要在以下三个层次上工作：

**源代码混淆**
在源代码上操作的混淆，这种混淆能够充分利用编程语言的特性。因为混淆步骤是在编译之前进行的，因此它也更容易集成到现有的编译链中。这种方法的主要缺点是对不同的语言需要设计不同的混淆。

**中间代码混淆**
IR设计的目的之一是独立于任何源语言或目标语言，因此在IR上进行混淆更加通用，能够处理不同高级语言和汇编语言的程序，但同时这种混淆集成更加困难，因为很难将混淆器添加到现有的编译工具链中。

**汇编语言混淆**
与IR和源码相比，汇编级混淆会导致大量信息的丢失，因此很难实现仅在汇编时工作的通用混淆器。

### 1.3 程序分析

程序分析指对程序进行分析，从而得到有用信息。从反汇编程序中可以推断出控制流和数据流两种不同的信息，因此可以从数据流和控制流两种不同的角度分析程序。

**控制流**：程序的控制流规定了程序的执行过程，通常用**Control Flow Graph(CFG)**和**Call Graph(CG)**表示控制流。在CFG中，节点被称为Basic Block(BB)，每一个BB包含多条指令，并且BB中的代码都是顺序执行的。而CFG中的edge则表示BB之间的可能执行路径。在CG中，节点代表一个函数，边代表函数之间的调用。

**数据流**：和控制流不同，数据流没有固定的图形表示：不同的数据流分析会产生不同的表示。典型的数据流分析是**到达定义**，该分析中包括确定每个变量可能已定义的位置。这些信息可以从CFG中观察每个BB的输入和输出提取。

程序分析的手段也分为两类：

**静态分析**
程序的静态分析无需执行程序，而是分析程序源码(可通过反汇编获得，但反汇编通常比较困难)。静态分析的第一步通常是重建函数的CFG或程序的CG(可以利用工具)。为了模拟程序的运行，可以使用**符号执行**。静态分析可以安全分析潜在恶意二进制文件，因为不需要执行。但是由于静态分析会分析程序所有可能的执行路径，所以可能会导致过度分析。

**动态分析**
程序的动态分析是在特定输入上完成的，并推断出所采用的执行路径和数据修改的信息。由于仅分析了可能的执行路径的子集，因此可能导致分析不足。动态分析的例子包括：

- 调试：在执行期间，逐步或使用断点以交互方式观察程序。
- 跟踪：记录每条执行的指令，并离线分析(执行后)。
- 数据污染：标记一个或多个变量，并在程序执行时观察它们对程序的影响。

大多数动态分析技术也可以静态地用于符号执行。

### 1.4 经典混淆技术

#### 1.4.1 控制流混淆

几种简单地控制流混淆技术：inlining和outlining、Opaque Predicate、Control Flow Flattening等

**inlining & outlining**
内联指用程序本身来代替对函数g的调用。即，若函数$f$调用函数$g$，则可以使用内联将函数$g$的代码插入到函数$f$中，使两者成为一体，从而省去调用。外联则相反，是将函数内一段代码独立成一个函数。这两种技术都能够达到修改函数的CFG和CG的目的，但不修改程序的功能，从而达到控制流混淆的技术。

**Opaque Predicate**
不透明谓词是是控制流复杂化的混淆技术，这种方法可以再混淆工具Obfuscator-LLVM中找到。传统的不透明谓词用于在CFG中创建伪分支。例如，
$$\forall x, y \in \mathbb{N}, \mathrm{if} \ x = y^2,
\mathrm{then} \ P = (x \equiv 0\ mod\ 4) \vee (x \equiv 1\ mod\ 4) \equiv True $$
上面的例子中$P$的值始终为$true$，则$P=flase$的分支将永远不会执行，那么就可以在这些不会被执行的路径中插入垃圾代码以达到混淆的目的。
应对不透明谓词的方法通常是通过使用符号执行来收集不透明谓词，并使用SMT求解器来解决混淆。

**Control Flow Flattening**
控制流扁平化的想法是通过在数据流中编码控制流的信息来完全改变函数CFG的结构。实现此目的的一种方法是为BB编号，并创建一个使用变量管理执行的调度程序，该变量确定BB的执行顺序。在每个BB的末尾，变量都会更新，执行将返回到调度程序。

#### 1.4.2 数据流混淆

常见数据流混淆技术：变量拆分、改变变量表示、编码等。

**变量拆分**
将一个变量拆分为多个变量，可以增加程序分析的难度。例如：
$$\mathcal{O}(x) \to x_1 \times a + x_2$$
其中$\mathcal{O}(x)$代表混淆转换，即将变量$x$拆分为$x_1, x_2$等。

**改变变量表示**
通过改变变量的表示形式，可以隐藏变量的值以及应用与于变量的操作。例如，一般计算机中使用二进制表示整数，可以通过改成使用三进制表示整数从而达到隐藏数据的目的

**编码**
编码是最常见的数据流混淆技术之一。编码旨在防止变量的值在程序执行过程中显式的出现在内存中。这项技术被借用到密码白盒领域。实际上，混淆中的编码通常是仿射函数，因为它们很容易相互转换并且在性能开销较小。传统上，变量必须在进行计算之前先解码，计算之后还需重新编码。

#### 1.4.3 白盒

白盒加密技术是加密技术和实际混淆技术之间的交叉领域，其目的是在**白盒攻击环境**中保护程序中的加密算法，即程序的运行环境是可控的。与理论上可以应用于任何程序并隐藏数据或算法的混淆相比，只有加密算法是白盒，并且该过程可以使用算法的特殊性来帮助隐藏所使用的密钥。白盒密码术是混淆密码算法中的重要概念，通常是混淆器中必不可少的。

### 1.5 混淆技术的评价指标

程序的复杂性是指其：

- 指令数量
- 控制流复杂性
- 数据流复杂性

因此Collberg等人基于此提出了三种指标来评价混淆转换：

1. *Potency*：即上述提及的程序的复杂度，如果混淆转换增加了程序复杂性，则它是有效的转换。在论文*MBA-Blast*中提到可以通过4中方法增加程序复杂性：(1)增加布尔运算符和算术运算符的数量；(2)引入新的整数或bit向量；(3)隐藏真实参数；(4)打乱计算顺序。
2. *Resilience*：即混淆对反混淆的健壮性。
3. *Cost*：主要分为两部分：产生混淆程序的代价，以及与原始程序相比，混淆程序所需的额外执行时间和空间。
4. *Correctness*：混淆后的程序应当与源程序有相同的语义和功能。

另一个常见的度量标准是**隐身性**，即检测到混淆的难度。Collberg定义了**隐秘隐身**(分析人员无法确定是否已应用混淆)和**局部隐身**(分析人员无法确定在何处应用了混淆)。

## 2. 已有工作

### 2.1 MBA表达式

MBA(混合布尔算数)表达式是混合了算术运算符(加法、乘法等)和布尔运算符(与、或、非等)的表达式。

#### 2.1.1 多项式MBA表达式

下面给出了一些有关MBA表达式的定义：

**Definition 1**(多项式MBA表达式)
MBA表达式$E$，
$$E = \sum_{i \in I} a_i \left( \prod_{j \in J_i} e_{i,j}(x_0,...,x_{t-1}) \right)$$
其中累和与累积是模$2^n$的，$a_i$是一个常数，$e_{i,j}$是变量$x_0,...,x_{t-1} \ in \ \lbrace 0,1 \rbrace ^n$的按位表达式，具体公式参加论文。
根据定义，多项式MBA表达式的组合仍然是多项式MBA表达式。
为简洁起见，本文其余部分中的“MBA表达式”一词代表多项式MBA表达式。此外，本研究仅限于常用的运算符：算术{+，-，×}和布尔值{∧，∨，⊕，¬}，对于此类运算符，我们同时使用按位和布尔项。

#### 2.1.2 基于MBA的混淆

**表达式的混淆**
使用MBA表达式混淆运算符的过程依赖于两部分：

- MBA重写：用等效的MBA表达式重写所选的运算符。
- 身份的插入：假定$e$是将被混淆的表达式的一部分，那么$e$可以被写为$f(f^{-1}(e))$，其中$f$为在$\mathbb{Z}/2^n \mathbb{Z}$上的可逆函数。在周等人的工作中，$f$是仿射函数。由于该过程与编码过程非常接近，因此我们通常将此步骤称为编码步骤。
为了强化混淆的效果，还可以交替多次使用上述两个方法，交替多次使用在现实场景中十分流行。

**不透明常量**
对于常量也可以使用MBA表达式来混淆隐藏。隐藏常量使用**置换多项式**，它们是$\mathbb{Z}/2^n \mathbb{Z}$上的可逆多项式。常数混淆(或不透明常数)按以下方式构造：

- 令多项式$P \in P_m(\mathbb{Z}/2^n \mathbb{Z})$，$Q$是$P$的反函数：$P(Q(X))=X, \forall X \in \mathbb{Z}/2^n \mathbb{Z}$
- 令$K\in \mathbb{Z}/2^n \mathbb{Z}$是想要隐藏的常量
- 令$E$是变量$(x_1,...,x_t)\in (\mathbb{Z}/2^n \mathbb{Z})^t$非平凡等于0的MBA表达式，例如$E=x+y-(x\oplus y)-2\times (x\land y)$

那么$K$可以被$P(E+Q(K))=P(Q(K))=K$替换，无论$(x_1,...,x_t)$取何值该替换始终成立。

#### 2.1.3 生成新的MBA等式

Zhou等人提供了一个生成新的MBA等式的方法，该方法是从**定理1**中推导出来的的：

**Theorem 1**
令$n$是bit位数，$s$为按位表达式的数量，$t$为变量的数量，令

- $(X_1,...,X_k,...,X_t) \in \lbrace \lbrace 0, 1 \rbrace ^n \rbrace ^t$是变量的n位表示的向量
- $e_0,...,e_j,...,e_{s-1}$是按位表达式
- $e = \sum_{j=0}^{s-1} a_j e_j$是一个线性MBA表达式，有$a_j$个整数
- 后续见论文

### 2.2 表达式简化

对表达式进行简化有两种方法：

1. 计算两个相等对象的统一表示(规范形式)
2. 寻找一个相等，但更简洁的表示形式

第一种简化方法是研究最多的，因为它可以证明表达式的等价性并检查是否等于零。但是，规范形式未必是最简单的形式。
由于混淆的设计既可以应对人工分析和自动分析，因此程序和表达式的**简洁性**定义是二义的：对于人类而言，**可读性**更重要；而对于机器而言，性能问题则更重要。

算术多项式的简洁性难以定义，例如：
$$(x-3)^2-x^2+7x-7=x+2$$
$$(1+x)^100=1+100x+...+100x^99+x^100$$
有时多项式展开后更简洁，有时不展开更易读。

布尔函数的简化通常是将表达式规约为范式。

### 2.3 比特向量逻辑

计算机系统需要一个适合于机器逻辑的框架，用以描述元素和对这些元素的操作。在机器级别上，对象使用位向量(例如二进制)表示，处理器上任意可用的运算可以用来构建表达式。
位向量逻辑适用于这种机器表示形式：每个对象都由一个位向量表示，传统上考虑的运算符为：算术$+,-,\times,/$，布尔值$\oplus,\wedge,\lor,\lnot$，移位$\ll,\gg$，串联$\circ$等。
通常实现位向量逻辑的工具是SMT求解器，例如Z3和Boolector。尽管它们是约束求解器，而不是简化器，但它们有时提供简化，例如Z3的简化函数。

### 2.4 术语重写

重写系统由一组对象以及转换这些对象的操作组成。在术语重写的情况下，那些对象是术语(或表达式)。

### 2.5 DAG表示

在计算机中，程序可以用抽象语法树AST和有向无环图DAG表示，同样的，表达式也可以用这两种图来表示。

**Definition 5**：DAG representation.
MBA表达式的DAG表示是一个有下列特征的有向无环图：

- 所有的叶子节点表示常量或变量，其他节点表示算术操作或位操作；
- 边代表操作顺序；
- 仅有一个根节点；
- 公共表达式在图中仅出现一次。

值得注意的是，DAG表示与紧凑术语图表示是等价的。

### 2.6 优化与反混淆

编译器通常具有与机器无关的优化阶段，该阶段程序的以IR表示(例如LLVM)。执行效率更高的代码其可读性较差，优化有时与反混淆有一个共同的目标。例如，消除死代码或常量替换(使用常量代替值不会改变的变量)能够提高代码可读性。某些混淆技术甚至可能无法抵抗优化过程，这类混淆实在是毫无用处。在本节中，我们介绍两种可以在理论上对任何程序进行混淆的优化技术，它们基于程序的行为而不是基于其描述：**超优化**和**程序合成**。

#### 2.6.1 超优化

超优化即为单个无循环汇编指令序列找到最佳代码。一般最佳代码是指执行最快的代码，或者时代码体积择最小的代码。
Massalin等提出的超优化方法时暴力法，它列举了增加长度的指令序列，并选择与目标序列等价的最低成本序列。

尽管超优化在一些混淆中是有用的，但它不能运行在我们定义的上下文中，否则会导致两个问题：

- 对于超优化来说，最佳代码的定义基于性能(更快、更小)，这与我们的可读性目标不同；
- 与混淆相比，优化的对象的代码长度较小(例如优化只能操作10余条指定，而混淆可以操作更多)。

#### 2.6.2 程序合成

程序合成是根据用户意图自动寻找可执行程序的过程，这种意图是通过各种形式的约束来表达的，例如输入输出示例、演示、自然语言等。程序合成已经有了许多实际应用：生成最佳代码序列（超优化可以看作是程序合成的特殊情况）、自动执行重复的编程任务、优化对性能至关重要的内部循环等。

## 3. MBA简化的难点

### 3.1 操作符不兼容

布尔运算和算术运算难以交互，因此需要特殊方法来处理混合计算。IDEA是90年代提出分组密码，以结合使用整数算术和按位运算符而闻名。IDEA的主要特征之一是缺少S盒，取而代之的是，它依赖于三个关键组件：

- 乘法$\odot$
- 加法$\boxplus$
- 位异或$\oplus$

IDEA的方法为本工作中的混合计算提供了灵感。同样的，密码学中加密的研究和混淆也有许多相似之处。

### 3.2 已有的MBA简化工具

**1. SMT求解器**

位向量逻辑是处理MBA表达式的良好理论框架，实现位向量逻辑的工具有SMT求解器。SMT求解器包括Z3、Boolector、Yices。
Z3使用位向量的原理，提供了多项式简化以及布尔运算简化，同时prove方法能够实现证明MBA表达式及其简化之间的等价性。但是Z3对于本文要解决的MBA表达式，其处理效率并不高，Z3中提出的两个步骤很有启发：第一个是**重写**，用以执行基本简化，重写通常是SMT求解器中所谓的预处理部分。第二步称为**位爆破**(也称为**平整化**)，即用二进制数代替整数重写整个公式。Boolector和Yices不能简化MBA表达式，只能证明MBA表达及其简化是等效的。

**编译器中的优化pass**

现代编译器(如LLVM)中的优化pass可以简化部分的MBA表达式，但是对复杂MBA就显得无能为力了。

### 3.3 表达式的复杂性指标

对一个MBA表达式，其复杂性的定义是比较困难的。例如表达式$x+y$和$(x \lor y) + (\lnot x \lor y) - (\lnot x)$，两个表达式对任意输入$x,y$，其计算结果都是相同的，但是左侧明显比右侧更简洁。
如何科学的定义表达式的复杂性，这里介绍几个常用的指标。

**1. DAG节点数**

由于可以使用DAG来表示一个expression，因此可以用DAG的节点数来衡量表达式的复杂性，节点越多越复杂。

**2. MBA交替**

MBA运算之所以复杂，是因为它混合了布尔计算和算术计算，因此可以使用MBA交替来衡量连接不同类型操作的操作数。例如$x \land y + x$，该表达式的MBA交替为1。纯算术或纯布尔表达式的MBA替换为0。
我们定义操作符$op \in \lbrace +,-,\times, \oplus,\wedge,\lor,\lnot \rbrace$，则MBA交替是DAG中连接不同类型的运算符的边的数目。即：对于一个图$G=(V,E)$，其MBA交替$alt_{MBA}(G)$是：
$$alt_{MBA}(G) = |\lbrace (v_1, v_2), type(v_1) \not = type(v_2) \rbrace |, (v_1, v_2) \in E$$
这些边代表了简化MBA表达式的难点，因为包含相同类型边的子图可以通过经典简化技术进行简化，而包含不同类型的子图则很难简化。

**3. 平均位向量大小**

在[Obfuscation with Mixed Boolean-Arithmetic Expressions](https://tel.archives-ouvertes.fr/tel-01623849/)这篇文献中还提到了一个称为平均位向量大小的指标。在DAG中，对于一个节点$v$，其位向量大小$bvsize(v)$是：

- 若$v$是不是操作符，则它表示变量或常量的位数，位数可以从上下文中推导。
- 若$v$是操作符：
    - 若$v \in \lbrace +,-,\times, \oplus, \lor \rbrace$，且$v_1,v_2$为操作对象，则$bvsize(v)=max(bvsize(v_1),bvsize(v_2))$，即位数最大的那个；
    - 若$v$为布尔操作$\land$，则$bvsize(v)=min(bvsize(v_1),bvsize(v_2))$，即位数最小的那个，例如$0b10110101 \land 0b1111$，前者的高四位经操作后都为0，所以取后者位数；
    - 若$v$为一元操作符$\lbrace \lnot, - \rbrace$，则$bvsize(v)=bvsize(v_1)$。

增加变量的位数，可能会使混淆的破解变难罢了，但是变量位数的增加对表达式的复杂性并无影响，因此位向量大小作为评价表达式的复杂性无多大意义。

## 4. MBA混淆技术分析

本章介绍如何对表达式进行混淆和去混淆。随后提出了基于位和基于字的两种方法。两种方法在GitHub上都可找到：arybo是用C和Python实现的，并且是基于位爆方法的；SSPAM是用Python实现的，并且可以通过使用模式匹配在字级上工作。

### 4.1 手动重建混淆过程

#### 4.1.1 从汇编到源码

使用Miasm逆向工程框架生成了混淆表达式的Python代码，并删除了与标志有关的表达式。源码以及反汇编的Python代码可参见论文图4.1、图4.2，得到的最终表达式见论文。

#### 4.1.2 其他混淆

在分析该MBA混淆表达的示例时，必须对其进行简化，以便排除与MBA混淆不相关的技术。

**位向量尺寸扩展**
在4.1.1中得到的表达式中，有两条是这样的：
$$f=((0x0D000000+0x67000000 \times (e+e-(0xFF \land d))) \gg 0x18)$$
$$R = (0xFF \land (0xC2 + 0xE5 \times (0x22 \lor (0xAE)f) + (0xFFFFB22D)f))$$
最终结果$R$是8位的(因为与上8位的0xFF)，所以可以将所有的表达式都简化为8位。但是由于存在位移操作，作者的做法是将$f$中的常量右移了24位，其余的都是直接截取后8位，最后再将16进制数转换成10进制。

**编码**
1.4.2节中介绍了使用编码的数据流混淆技术：相关变量在写入内存之前先进行编码，然后在读取时进行解码。传统上编码是一个仿射函数。 因此，此处作者使用了编码函数$x \mapsto 229x + 247$，解码函数为$x \mapsto 237 \times (x-247)$。

#### 4.1.3 MBA表达式的反混淆

本节举例介绍了如何得出混淆表达式，很多推导没看懂，在此不再整理。

### 4.2 使用位爆炸的简化

第一个简化方法是基于比特向量逻辑，即位爆炸方法。

#### 4.2.1 描述

操作布尔表达式的范式是**代数范式ANF**，ANF是只包含$\oplus$和$\land$的表达式。

## 5. MBA混淆技术的健壮性

### 5.1 MBA混淆应对黑盒攻击的健壮性

黑盒共计通过程序的输入和输出来推断程序的信息，为此通常要考虑两个问题：找到一个函数的良好近似需要多少个输入/输出对，以及应该使用哪种算法来构建该近似，在黑盒中重构函数的难度通常取决于函数本身，有几种策略可以提高重构函数的难度：
- 添加不影响计算结果的变量；
- 增加位向量的大小，因为这会增加可能的重构函数的解空间；
- 增加表达式的节点数，因为这也会减慢输入/输出对的计算。
操作符混合并不能明显提高对黑盒攻击的抵抗性，因为它仅能减缓黑盒攻击的速度，而不能使反混淆攻击失败。

### 5.2 针对简化工具的弹性
因为简化工具使用表达式的实际描述，因此它是白盒攻击。

#### 5.2.1 位爆炸

爆破方法的最大优势是将MBA简化问题转换为布尔表达式简化问题，该领域已经有很多前人展开过工作。使用位爆炸法时，我们可以使用几种范式来为任何表达式提供唯一的表示形式。
位爆炸的主要缺点是布尔表达式的规范化在内存和时间上代价很高。
另一个问题是，从布尔表达式到字级表达式的识别并不容易。在尝试识别一个运算符时，我们提供了一些技巧，但是识别包含多个运算符的更复杂表达式的问题显然是将来需要解决的问题。
作者使用*arybo*工具反混淆了几个MBA混淆表达式，当表达式位数为8位时只用了0.09s就能正确识别出原始表达式，但是当表达式位数为12位时，解析时间达到了61.32s。对于位数量较少的表达式，使用位爆破的简化非常有效。因此，可以通过提高位数来提高MBA混淆表达式的弹性。不过，作者在3.4.3节中介绍的还原方法可以轻松简化这种混淆。

#### 5.2.2 符号简化

因为使用符号简化的算法在字级别上起作用，所以简化不受表达式位数增加的影响，另外，AST表达式的“大小”也远小于位爆破方法中的表示。例如，x+y在字级具有3个节点，可容纳任意数量的位；而4位的位爆破法则有3、6、17、41个节点。
这种方法的主要缺点是，它高度依赖于所选的重写规则集。即使具有所有混淆规则的列表，也不能保证具有令人满意的反混淆。
对于该种方法，作者使用了SSPAM工具来进行测试。对于使用一般混淆(公共可用)的混淆方法混淆的表达式，SSPAM都能够很快的进行发混淆。随后作者又使用Algorithm 2对原表达式进行混淆，每个表达式都会生成20个混淆表达式，这些混淆表达式作为输入送入SSPAM中，SSPAM不能从20个混淆表达式中成功反混淆出原表达式。
